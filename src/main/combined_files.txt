==================================================
路径：.\生成此代码的脚本.py
==================================================
import os

def combine_files(output_file='combined_files.txt'):
    current_dir = os.path.abspath('.')
    output_path = os.path.abspath(output_file)
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk('.'):
            if os.path.abspath(root) == os.path.dirname(output_path):
                if output_file in files:
                    files.remove(output_file)

            for file in sorted(files):
                file_path = os.path.join(root, file)
                abs_path = os.path.abspath(file_path)

                if abs_path == output_path:
                    continue

                outfile.write(f'{"="*50}\n')
                outfile.write(f'路径：{file_path}\n')
                outfile.write(f'{"="*50}\n')
                
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='replace') as infile:
                        content = infile.read()
                        outfile.write(content)
                        if not content.endswith('\n'):
                            outfile.write('\n')
                except Exception as e:
                    outfile.write(f'!!! 读取失败：{str(e)}\n')
                outfile.write('\n\n')
    
    print(f'GG：{output_file}')

if __name__ == '__main__':
    combine_files()


==================================================
路径：.\java\cn\fandmc\flametech\Main.java
==================================================
package cn.fandmc.flametech;

import cn.fandmc.flametech.commands.FlameTechCommand;
import cn.fandmc.flametech.commands.FlameTechTabCompleter;
import cn.fandmc.flametech.config.ConfigManager;
import cn.fandmc.flametech.constants.ConfigKeys;
import cn.fandmc.flametech.gui.manager.GUIManager;
import cn.fandmc.flametech.items.manager.ItemManager;
import cn.fandmc.flametech.listeners.BlockBreakListener;
import cn.fandmc.flametech.listeners.PlayerInteractListener;
import cn.fandmc.flametech.listeners.multiblock.OreWasherListener;
import cn.fandmc.flametech.materials.manager.MaterialManager;
import cn.fandmc.flametech.multiblock.manager.MultiblockManager;
import cn.fandmc.flametech.recipes.manager.RecipeManager;
import cn.fandmc.flametech.unlock.manager.UnlockManager;
import cn.fandmc.flametech.utils.FoliaUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.Objects;

public class Main extends JavaPlugin {

    private static Main instance;
    private ConfigManager configManager;
    private ItemManager itemManager;
    private RecipeManager recipeManager;
    private MultiblockManager multiblockManager;
    private UnlockManager unlockManager;
    private GUIManager guiManager;
    private MaterialManager materialManager;

    @Override
    public void onEnable() {
        instance = this;

        try {
            printStartupBanner();

            FoliaUtils.initialize(this);

            initializeManagers();

            registerCommands();

            registerListeners();

            registerDefaultContent();
        } catch (Exception e) {
            MessageUtils.logError("Failed to enable FlameTech plugin: " + e.getMessage());
            e.printStackTrace();
            setEnabled(false);
        }
    }

    @Override
    public void onDisable() {
        try {
            // 保存数据
            if (unlockManager != null) {
                unlockManager.saveAllData();
            }

        } catch (Exception e) {
            MessageUtils.logError("Error during plugin disable: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void printStartupBanner() {
        getLogger().info("""
                
                  ______ _                   _______        _    \s
                 |  ____| |                 |__   __|      | |   \s
                 | |__  | | __ _ _ __ ___   ___| | ___  ___| |__ \s
                 |  __| | |/ _` | '_ ` _ \\ / _ \\ |/ _ \\/ __| '_ \\\s
                 | |    | | (_| | | | | | |  __/ |  __/ (__| | | |
                 |_|    |_|\\__,_|_| |_| |_|\\___|_|\\___|\\___|_| |_|
                 热力科技
                """);

        MessageUtils.logInfo("FlameTech v" + getDescription().getVersion() + " by " +
                String.join(", ", getDescription().getAuthors()));
        MessageUtils.logInfo("运行于: " + getServer().getName() + " " + getServer().getVersion());
    }

    private void initializeManagers() {
        if (!getDataFolder().exists()) {
            getDataFolder().mkdirs();
        }

        this.configManager = new ConfigManager(this);
        saveDefaultConfig();

        this.itemManager = new ItemManager(this);
        this.materialManager = new MaterialManager(this);
        this.multiblockManager = new MultiblockManager(this);
        this.recipeManager = new RecipeManager(this);

        // UnlockManager 必须在 RecipeManager 和 MultiblockManager 之后初始化
        // 因为它需要从这些管理器中加载解锁信息
        this.unlockManager = new UnlockManager(this);

        this.guiManager = new GUIManager(this);
    }

    private void registerCommands() {
        Objects.requireNonNull(getCommand("flametech")).setExecutor(new FlameTechCommand(this));
        Objects.requireNonNull(getCommand("flametech")).setTabCompleter(new FlameTechTabCompleter());
    }

    private void registerListeners() {
        getServer().getPluginManager().registerEvents(new PlayerInteractListener(this), this);
        getServer().getPluginManager().registerEvents(new BlockBreakListener(this), this);
        getServer().getPluginManager().registerEvents(new OreWasherListener(this), this);
    }

    private void registerDefaultContent() {
        // 注册顺序很重要
        // 1. 先注册物品
        itemManager.registerDefaultItems();

        // 2. 注册材料
        materialManager.registerDefaultMaterials();

        // 3. 再注册多方块结构
        multiblockManager.registerDefaultStructures();

        // 4. 然后注册配方
        recipeManager.registerDefaultRecipes();

        // 5. 最后注册解锁项（依赖于上面的内容）
        unlockManager.registerDefaultUnlockables();

        // 6. 注册GUI
        guiManager.registerDefaultGUIs();
    }

    /**
     * 重载插件配置
     */
    public void reloadPluginConfig() {
        try {
            reloadConfig();
            configManager.reloadConfig();

            // 重载各个管理器
            itemManager.reload();
            materialManager.reload();
            multiblockManager.reload();
            recipeManager.reload();

            // UnlockManager 的重载必须在其他管理器之后
            // 因为它需要重新加载解锁信息
            unlockManager.reload();

            guiManager.reload();

        } catch (Exception e) {
            MessageUtils.logError("Failed to reload configuration: " + e.getMessage());
            throw e;
        }
    }

    // Getter methods
    public static Main getInstance() {
        return instance;
    }

    public ConfigManager getConfigManager() {
        return configManager;
    }

    public ItemManager getItemManager() {
        return itemManager;
    }

    public MaterialManager getMaterialManager() {
        return materialManager;
    }

    public RecipeManager getRecipeManager() {
        return recipeManager;
    }

    public MultiblockManager getMultiblockManager() {
        return multiblockManager;
    }

    public UnlockManager getUnlockManager() {
        return unlockManager;
    }

    public GUIManager getGuiManager() {
        return guiManager;
    }

    public boolean isDebugMode() {
        return getConfig().getBoolean(ConfigKeys.DEBUG_ENABLED, false);
    }

    public String getPluginVersion() {
        return getDescription().getVersion();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\commands\FlameTechCommand.java
==================================================
package cn.fandmc.flametech.commands;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.constants.Permissions;
import cn.fandmc.flametech.utils.BookUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.Map;

/**
 * FlameTech主命令执行器
 */
public class FlameTechCommand implements CommandExecutor {

    private final Main plugin;
    private final Map<String, SubCommand> subCommands = new HashMap<>();

    public FlameTechCommand(Main plugin) {
        this.plugin = plugin;
        registerSubCommands();
    }

    private void registerSubCommands() {
        subCommands.put("help", new HelpCommand());
        subCommands.put("guide", new GuideCommand());
        subCommands.put("open", new OpenCommand());
        subCommands.put("reload", new ReloadCommand());
        subCommands.put("info", new InfoCommand());
    }

    @Override
    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command,
                             @NotNull String label, String[] args) {

        if (args.length == 0) {
            sendHelp(sender);
            return true;
        }

        String subCommandName = args[0].toLowerCase();
        SubCommand subCommand = subCommands.get(subCommandName);

        if (subCommand != null) {
            return subCommand.execute(sender, args);
        } else {
            sendHelp(sender);
            return true;
        }
    }

    private void sendHelp(CommandSender sender) {
        // 使用列表格式发送帮助消息
        MessageUtils.sendLocalizedMessageList(sender, Messages.COMMAND_HELP_MESSAGES);
    }

    // 内部接口
    private interface SubCommand {
        boolean execute(CommandSender sender, String[] args);
    }

    // 帮助命令
    private class HelpCommand implements SubCommand {
        @Override
        public boolean execute(CommandSender sender, String[] args) {
            if (!sender.hasPermission(Permissions.COMMAND_HELP)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_ERROR_NO_PERMISSION);
                return true;
            }

            sendHelp(sender);
            return true;
        }
    }

    // 指南书命令
    private class GuideCommand implements SubCommand {
        @Override
        public boolean execute(CommandSender sender, String[] args) {
            if (!sender.hasPermission(Permissions.COMMAND_GUIDE)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_ERROR_NO_PERMISSION);
                return true;
            }

            if (!(sender instanceof Player player)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_GUIDE_ONLY_PLAYER);
                return true;
            }

            try {
                player.getInventory().addItem(BookUtils.createGuideBook());

                String bookName = plugin.getConfigManager().getLang(Messages.GUIDE_BOOK_DISPLAY_NAME);
                MessageUtils.sendLocalizedMessage(player, Messages.COMMAND_GUIDE_SUCCESS,
                        "%book%", bookName);

                return true;
            } catch (Exception e) {
                MessageUtils.logError("Error giving guide book: " + e.getMessage());
                MessageUtils.sendLocalizedMessage(player, Messages.COMMAND_ERROR_GENERIC);
                return true;
            }
        }
    }

    // 打开GUI命令
    private class OpenCommand implements SubCommand {
        @Override
        public boolean execute(CommandSender sender, String[] args) {
            if (!sender.hasPermission(Permissions.COMMAND_OPEN)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_ERROR_NO_PERMISSION);
                return true;
            }

            if (!(sender instanceof Player player)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_GUIDE_ONLY_PLAYER);
                return true;
            }

            String guiName = args.length > 1 ? args[1] : "main";

            try {
                boolean success = plugin.getGuiManager().openGUI(player, guiName);
                if (!success) {
                    MessageUtils.sendLocalizedMessage(player, Messages.COMMAND_OPEN_INVALID_GUI,
                            "%gui%", guiName);
                }
                return true;
            } catch (Exception e) {
                MessageUtils.logError("Error opening GUI: " + e.getMessage());
                MessageUtils.sendLocalizedMessage(player, Messages.COMMAND_OPEN_ERROR);
                return true;
            }
        }
    }

    // 重载命令
    private class ReloadCommand implements SubCommand {
        @Override
        public boolean execute(CommandSender sender, String[] args) {
            if (!sender.hasPermission(Permissions.COMMAND_RELOAD)) {
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_ERROR_NO_PERMISSION);
                return true;
            }

            try {
                plugin.reloadPluginConfig();
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_RELOAD_SUCCESS);
                return true;
            } catch (Exception e) {
                MessageUtils.logError("Error reloading plugin: " + e.getMessage());
                MessageUtils.sendMessage(sender, "&c重载插件时发生错误: " + e.getMessage());
                return true;
            }
        }
    }

    private class InfoCommand implements SubCommand {
        @Override
        public boolean execute(CommandSender sender, String[] args) {
            if (!sender.hasPermission(Permissions.ADMIN)) {
                // 非管理员只显示解锁进度
                if (sender instanceof Player player) {
                    Map<String, Object> playerStats = plugin.getUnlockManager().getPlayerStatistics(player);
                    MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_PLAYER_PROGRESS,
                            "%unlocked%", String.valueOf(playerStats.getOrDefault("total_unlocked", 0)),
                            "%total%", String.valueOf(playerStats.getOrDefault("total_available", 0)));
                }
                return true;
            }

            try {
                // 管理员信息
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_TITLE);

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_VERSION,
                        "%version%", plugin.getPluginVersion());

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_ITEMS,
                        "%count%", String.valueOf(plugin.getItemManager().getRegisteredItemCount()));

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_RECIPES,
                        "%count%", String.valueOf(plugin.getRecipeManager().getRecipeCount()));

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_MULTIBLOCKS,
                        "%count%", String.valueOf(plugin.getMultiblockManager().getRegisteredStructureCount()));

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_GUIS,
                        "%count%", String.valueOf(plugin.getGuiManager().getRegisteredGUICount()));

                String debugStatus = plugin.isDebugMode() ?
                        plugin.getConfigManager().getLang(Messages.COMMON_STATUS_ENABLED) :
                        plugin.getConfigManager().getLang(Messages.COMMON_STATUS_DISABLED);

                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_DEBUG,
                        "%status%", debugStatus);

                // 如果是玩家，显示解锁进度
                if (sender instanceof Player player) {
                    Map<String, Object> playerStats = plugin.getUnlockManager().getPlayerStatistics(player);
                    MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_INFO_PLAYER_PROGRESS,
                            "%unlocked%", String.valueOf(playerStats.getOrDefault("total_unlocked", 0)),
                            "%total%", String.valueOf(playerStats.getOrDefault("total_available", 0)));
                }

                return true;
            } catch (Exception e) {
                MessageUtils.logError("Error showing plugin info: " + e.getMessage());
                MessageUtils.sendLocalizedMessage(sender, Messages.COMMAND_ERROR_GENERIC);
                return true;
            }
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\commands\FlameTechTabCompleter.java
==================================================
package cn.fandmc.flametech.commands;

import cn.fandmc.flametech.constants.Permissions;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabCompleter;
import org.bukkit.util.StringUtil;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * FlameTech命令Tab补全器
 */
public class FlameTechTabCompleter implements TabCompleter {

    private static final List<String> MAIN_COMMANDS = Arrays.asList(
            "help", "guide", "open", "reload", "info"
    );

    private static final List<String> GUI_NAMES = Arrays.asList(
            "main", "basic_machines", "tools"
    );

    @Override
    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command,
                                      @NotNull String alias, String[] args) {
        List<String> completions = new ArrayList<>();

        if (args.length == 1) {
            // 第一级命令补全
            List<String> availableCommands = new ArrayList<>();

            for (String cmd : MAIN_COMMANDS) {
                if (hasPermissionForCommand(sender, cmd)) {
                    availableCommands.add(cmd);
                }
            }

            StringUtil.copyPartialMatches(args[0], availableCommands, completions);

        } else if (args.length == 2) {
            String subCommand = args[0].toLowerCase();

            if ("open".equals(subCommand) && sender.hasPermission(Permissions.COMMAND_OPEN)) {
                StringUtil.copyPartialMatches(args[1], GUI_NAMES, completions);
            }
        }

        return completions;
    }

    private boolean hasPermissionForCommand(CommandSender sender, String command) {
        return switch (command) {
            case "help" -> sender.hasPermission(Permissions.COMMAND_HELP);
            case "guide" -> sender.hasPermission(Permissions.COMMAND_GUIDE);
            case "open" -> sender.hasPermission(Permissions.COMMAND_OPEN);
            case "reload" -> sender.hasPermission(Permissions.COMMAND_RELOAD);
            case "info" -> sender.hasPermission(Permissions.ADMIN);
            default -> false;
        };
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\config\ConfigManager.java
==================================================
package cn.fandmc.flametech.config;

import cn.fandmc.flametech.constants.ConfigKeys;
import cn.fandmc.flametech.constants.FileConstants;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.ChatColor;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * 配置管理器 - 统一管理插件配置和语言文件
 */
public class ConfigManager {

    private final JavaPlugin plugin;
    private FileConfiguration config;
    private File configFile;

    private FileConfiguration langConfig;
    private String currentLanguage;
    private File langFile;

    // 缓存系统
    private final ConcurrentMap<String, String> langCache = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, List<String>> langListCache = new ConcurrentHashMap<>();
    private long lastReloadTime;

    public ConfigManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.lastReloadTime = System.currentTimeMillis();

        initializeConfig();
        initializeLanguage();
    }

    private void initializeConfig() {
        this.configFile = new File(plugin.getDataFolder(), FileConstants.CONFIG_FILE);

        // 创建默认配置文件
        if (!configFile.exists()) {
            plugin.saveResource(FileConstants.CONFIG_FILE, false);
        }

        this.config = YamlConfiguration.loadConfiguration(configFile);
    }

    private void initializeLanguage() {
        // 获取语言设置
        this.currentLanguage = config.getString(ConfigKeys.LANGUAGE, FileConstants.DEFAULT_LANGUAGE);

        // 创建语言文件夹
        File langFolder = new File(plugin.getDataFolder(), FileConstants.LANG_FOLDER);
        if (!langFolder.exists()) {
            langFolder.mkdirs();
        }

        // 加载语言文件
        loadLanguageFile();
    }

    private void loadLanguageFile() {
        this.langFile = new File(plugin.getDataFolder(), FileConstants.getLangFilePath(currentLanguage));

        // 创建默认语言文件
        if (!langFile.exists()) {
            plugin.saveResource(FileConstants.getLangFilePath(currentLanguage), false);
        }

        this.langConfig = YamlConfiguration.loadConfiguration(langFile);

        // 清空缓存
        clearCache();

        MessageUtils.logInfo("加载语言文件: " + currentLanguage);
    }

    /**
     * 重载配置
     */
    public void reloadConfig() {
        try {
            // 重载主配置
            if (configFile.exists()) {
                config = YamlConfiguration.loadConfiguration(configFile);
            }

            // 检查语言是否变更
            String newLanguage = config.getString(ConfigKeys.LANGUAGE, FileConstants.DEFAULT_LANGUAGE);
            if (!newLanguage.equals(currentLanguage)) {
                this.currentLanguage = newLanguage;
                loadLanguageFile();
            } else {
                // 重载当前语言文件
                reloadLanguage();
            }

            lastReloadTime = System.currentTimeMillis();
            MessageUtils.logInfo("已重载");

        } catch (Exception e) {
            MessageUtils.logError("Failed to reload configuration: " + e.getMessage());
            throw new RuntimeException("Configuration reload failed", e);
        }
    }

    /**
     * 重载语言文件
     */
    private void reloadLanguage() {
        if (langFile.exists()) {
            langConfig = YamlConfiguration.loadConfiguration(langFile);
            clearCache();
        }
    }

    /**
     * 获取本地化字符串
     */
    public String getLang(String path) {
        if (path == null || path.isEmpty()) {
            return "";
        }

        // 尝试从缓存获取
        String cached = langCache.get(path);
        if (cached != null) {
            return cached;
        }

        // 从配置文件获取
        String message = getLanguageString(path);

        // 处理颜色代码
        message = ChatColor.translateAlternateColorCodes('&', message);

        // 存入缓存
        langCache.put(path, message);

        return message;
    }

    /**
     * 获取本地化字符串列表
     */
    public List<String> getStringList(String path) {
        if (path == null || path.isEmpty()) {
            return new ArrayList<>();
        }

        // 尝试从缓存获取
        List<String> cached = langListCache.get(path);
        if (cached != null) {
            return new ArrayList<>(cached);
        }

        // 从配置文件获取
        List<String> result = new ArrayList<>();

        if (langConfig != null) {
            List<?> list = langConfig.getList(path);
            if (list != null) {
                for (Object obj : list) {
                    if (obj instanceof String str) {
                        result.add(ChatColor.translateAlternateColorCodes('&', str));
                    }
                }
            }
        }

        // 如果没有找到，返回默认值
        if (result.isEmpty()) {
            String errorMessage = "&cLanguage list not found: " + path;
            result.add(ChatColor.translateAlternateColorCodes('&', errorMessage));
        }

        // 存入缓存
        langListCache.put(path, new ArrayList<>(result));

        return result;
    }

    private String getLanguageString(String path) {
        if (langConfig == null) {
            return "&cLanguage configuration not found";
        }

        String message = langConfig.getString(path);
        if (message == null) {
            return "&cLanguage key not found: " + path;
        }

        return message;
    }

    /**
     * 获取带参数替换的本地化字符串
     */
    public String getLang(String path, String... replacements) {
        String message = getLang(path);

        // 替换参数
        for (int i = 0; i < replacements.length; i += 2) {
            if (i + 1 < replacements.length) {
                message = message.replace(replacements[i], replacements[i + 1]);
            }
        }

        return message;
    }

    /**
     * 安全地获取本地化字符串，如果语言文件未加载则返回默认消息
     * 主要用于初始化阶段和错误处理
     */
    public String getSafeLang(String path, String defaultMessage, String... replacements) {
        if (langConfig == null) {
            // 语言文件还未加载，使用默认消息
            String message = defaultMessage;
            for (int i = 0; i < replacements.length; i += 2) {
                if (i + 1 < replacements.length) {
                    message = message.replace(replacements[i], replacements[i + 1]);
                }
            }
            return ChatColor.translateAlternateColorCodes('&', message);
        }

        // 语言文件已加载，使用正常的获取方法
        return getLang(path, replacements);
    }

    /**
     * 清空缓存
     */
    private void clearCache() {
        langCache.clear();
        langListCache.clear();
    }

    /**
     * 保存默认语言文件
     */
    public void saveDefaultLanguage() {
        File langFolder = new File(plugin.getDataFolder(), FileConstants.LANG_FOLDER);
        if (!langFolder.exists()) {
            langFolder.mkdirs();
        }

        File defaultLangFile = new File(langFolder, currentLanguage + FileConstants.LANG_FILE_EXTENSION);
        if (!defaultLangFile.exists()) {
            plugin.saveResource(FileConstants.getLangFilePath(currentLanguage), false);
        }

        loadLanguageFile();
    }

    /**
     * 设置配置值
     */
    public void setConfigValue(String path, Object value) {
        config.set(path, value);
        saveConfig();
    }

    /**
     * 获取配置值
     */
    public Object getConfigValue(String path, Object defaultValue) {
        return config.get(path, defaultValue);
    }

    /**
     * 保存配置文件
     */
    public void saveConfig() {
        try {
            config.save(configFile);
        } catch (IOException e) {
            MessageUtils.logError("Failed to save configuration: " + e.getMessage());
        }
    }

    /**
     * 获取统计信息
     */
    public ConfigStatistics getStatistics() {
        return new ConfigStatistics(
                langCache.size(),
                langListCache.size(),
                lastReloadTime,
                currentLanguage,
                configFile.length(),
                langFile != null ? langFile.length() : 0
        );
    }

    // Getter方法
    public FileConfiguration getConfig() { return config; }
    public FileConfiguration getLangConfig() { return langConfig; }
    public String getCurrentLanguage() { return currentLanguage; }
    public long getLastReloadTime() { return lastReloadTime; }

    /**
     * 配置统计信息
     */
    public static class ConfigStatistics {
        private final int langCacheSize;
        private final int langListCacheSize;
        private final long lastReloadTime;
        private final String currentLanguage;
        private final long configFileSize;
        private final long langFileSize;

        public ConfigStatistics(int langCacheSize, int langListCacheSize, long lastReloadTime,
                                String currentLanguage, long configFileSize, long langFileSize) {
            this.langCacheSize = langCacheSize;
            this.langListCacheSize = langListCacheSize;
            this.lastReloadTime = lastReloadTime;
            this.currentLanguage = currentLanguage;
            this.configFileSize = configFileSize;
            this.langFileSize = langFileSize;
        }

        // Getter方法
        public int getLangCacheSize() { return langCacheSize; }
        public int getLangListCacheSize() { return langListCacheSize; }
        public long getLastReloadTime() { return lastReloadTime; }
        public String getCurrentLanguage() { return currentLanguage; }
        public long getConfigFileSize() { return configFileSize; }
        public long getLangFileSize() { return langFileSize; }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\constants\ConfigKeys.java
==================================================
package cn.fandmc.flametech.constants;

public final class ConfigKeys {

    // General config
    public static final String LANGUAGE = "language";
    public static final String UPDATE_CHECKER_ENABLED = "update-checker.enabled";
    public static final String DEBUG_ENABLED = "debug.enabled";
    public static final String DEBUG_LOG_TOOL_USAGE = "debug.log_tool_usage";

    // Tool config
    public static final String TOOLS_EXPLOSIVE_ENABLED = "tools.explosive_pickaxe.enabled";
    public static final String TOOLS_EXPLOSIVE_RADIUS = "tools.explosive_pickaxe.explosion_radius";
    public static final String TOOLS_EXPLOSIVE_MAX_BLOCKS = "tools.explosive_pickaxe.max_blocks";
    public static final String TOOLS_EXPLOSIVE_MAX_DURABILITY_DAMAGE = "tools.explosive_pickaxe.max_durability_damage";
    public static final String TOOLS_EXPLOSIVE_PERMISSION_CHECK = "tools.explosive_pickaxe.permission_check";

    public static final String TOOLS_SMELTING_ENABLED = "tools.smelting_pickaxe.enabled";
    public static final String TOOLS_SMELTING_PARTICLE_EFFECTS = "tools.smelting_pickaxe.particle_effects";
    public static final String TOOLS_SMELTING_SOUND_EFFECTS = "tools.smelting_pickaxe.sound_effects";
    public static final String TOOLS_SMELTING_SUCCESS_RATE = "tools.smelting_pickaxe.success_rate";

    private ConfigKeys() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\constants\FileConstants.java
==================================================
package cn.fandmc.flametech.constants;

/**
 * 文件和路径相关常量
 */
public final class FileConstants {

    // 配置文件
    public static final String CONFIG_FILE = "config.yml";

    // 语言文件
    public static final String LANG_FOLDER = "lang";
    public static final String LANG_FILE_EXTENSION = ".yml";
    public static final String DEFAULT_LANGUAGE = "zh_cn";

    // 路径分隔符
    public static final String PATH_SEPARATOR = "/";

    // 构建语言文件路径的工具方法
    public static String getLangFilePath(String language) {
        return LANG_FOLDER + PATH_SEPARATOR + language + LANG_FILE_EXTENSION;
    }

    private FileConstants() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\constants\ItemKeys.java
==================================================
package cn.fandmc.flametech.constants;

public final class ItemKeys {

    // NBT Keys
    public static final String FLAME_TECH_GUIDE = "flame_tech_guide";
    public static final String EXPLOSIVE_PICKAXE = "explosive_pickaxe";
    public static final String SMELTING_PICKAXE = "smelting_pickaxe";


    // Item IDs
    public static final String ID_MAGNET = "magnet";
    public static final String ID_EXPLOSIVE_PICKAXE = "explosive_pickaxe";
    public static final String ID_SMELTING_PICKAXE = "smelting_pickaxe";
    public static final String ID_ENHANCED_CRAFTING_TABLE = "enhanced_crafting_table";

    // Recipe IDs
    public static final String RECIPE_MAGNET = "recipe.magnet";
    public static final String RECIPE_EXPLOSIVE_PICKAXE = "recipe.explosive_pickaxe";
    public static final String RECIPE_SMELTING_PICKAXE = "recipe.smelting_pickaxe";

    // Multiblock IDs
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_TABLE = "multiblock.enhanced_crafting_table";

    private ItemKeys() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\constants\Messages.java
==================================================
package cn.fandmc.flametech.constants;

public final class Messages {
    // Command messages
    public static final String COMMAND_HELP_MESSAGES = "command.help.messages";
    public static final String COMMAND_HELP_TITLE = "command.help.title";
    public static final String COMMAND_HELP_LINE1 = "command.help.line1";
    public static final String COMMAND_HELP_LINE2 = "command.help.line2";
    public static final String COMMAND_HELP_LINE3 = "command.help.line3";
    public static final String COMMAND_HELP_LINE4 = "command.help.line4";
    public static final String COMMAND_HELP_LINE5 = "command.help.line5";
    public static final String COMMAND_RELOAD_SUCCESS = "command.reload.success";
    public static final String COMMAND_GUIDE_SUCCESS = "command.guide.success";
    public static final String COMMAND_GUIDE_ONLY_PLAYER = "command.guide.only_player";
    public static final String COMMAND_OPEN_INVALID_GUI = "command.open.invalid_gui";
    public static final String COMMAND_OPEN_ERROR = "command.open.error";
    public static final String COMMAND_INFO_TITLE = "command.info.title";
    public static final String COMMAND_INFO_VERSION = "command.info.version";
    public static final String COMMAND_INFO_ITEMS = "command.info.items";
    public static final String COMMAND_INFO_RECIPES = "command.info.recipes";
    public static final String COMMAND_INFO_MULTIBLOCKS = "command.info.multiblocks";
    public static final String COMMAND_INFO_GUIS = "command.info.guis";
    public static final String COMMAND_INFO_DEBUG = "command.info.debug";
    public static final String COMMAND_INFO_PLAYER_PROGRESS = "command.info.player_progress";
    public static final String COMMAND_ERROR_GENERIC = "command.error.generic";
    public static final String COMMAND_ERROR_NO_PERMISSION = "command.error.no_permission";

    // Common messages
    public static final String COMMON_ERROR_GENERIC = "common.error.generic";
    public static final String COMMON_ERROR_INVALID_PLAYER = "common.error.invalid_player";
    public static final String COMMON_ERROR_PERMISSION_DENIED = "common.error.permission_denied";
    public static final String COMMON_ERROR_OPERATION_FAILED = "common.error.operation_failed";
    public static final String COMMON_STATUS_ENABLED = "common.status.enabled";
    public static final String COMMON_STATUS_DISABLED = "common.status.disabled";

    // GUI messages
    public static final String GUI_COMMON_BACK = "common.navigation.back";
    public static final String GUI_COMMON_NEXT_PAGE = "common.navigation.next_page";
    public static final String GUI_COMMON_PREVIOUS_PAGE = "common.navigation.previous_page";
    public static final String GUI_COMMON_CLOSE = "common.navigation.close";
    public static final String GUI_COMMON_NO_NEXT_PAGE = "common.placeholders.no_next_page";
    public static final String GUI_COMMON_NO_PREVIOUS_PAGE = "common.placeholders.no_previous_page";
    public static final String GUI_BUTTONS_BASIC_MACHINES_NAME = "gui.buttons.basic_machines.name";
    public static final String GUI_BUTTONS_BASIC_MACHINES_LORE = "gui.buttons.basic_machines.lore";
    public static final String GUI_BUTTONS_TOOLS_NAME = "gui.buttons.tools.name";
    public static final String GUI_BUTTONS_TOOLS_LORE = "gui.buttons.tools.lore";
    public static final String GUI_ITEM_RECIPE_INGREDIENT_AMOUNT = "gui.item_recipe.ingredient_amount";
    public static final String GUI_ITEM_RECIPE_TYPE_INDICATOR_NAME = "gui.item_recipe.type_indicator.name";
    public static final String GUI_ITEM_RECIPE_TYPE_INDICATOR_TYPE = "gui.item_recipe.type_indicator.type";
    public static final String GUI_ITEM_RECIPE_TYPE_INDICATOR_SOURCE = "gui.item_recipe.type_indicator.source";
    public static final String GUI_ITEM_RECIPE_TYPE_INDICATOR_USAGE_LINE1 = "gui.item_recipe.type_indicator.usage_line1";
    public static final String GUI_ITEM_RECIPE_TYPE_INDICATOR_USAGE_LINE2 = "gui.item_recipe.type_indicator.usage_line2";
    public static final String GUI_ITEM_RECIPE_RESULT_TITLE = "gui.item_recipe.result.title";
    public static final String GUI_ITEM_RECIPE_RESULT_AMOUNT = "gui.item_recipe.result.amount";
    public static final String GUI_ITEM_RECIPE_RESULT_INSTRUCTION_LINE1 = "gui.item_recipe.result.instruction_line1";
    public static final String GUI_ITEM_RECIPE_RESULT_INSTRUCTION_LINE2 = "gui.item_recipe.result.instruction_line2";
    public static final String GUI_ITEM_RECIPE_UNKNOWN_STRUCTURE = "gui.item_recipe.unknown_structure";
    public static final String GUI_ITEM_RECIPE_ENHANCED_CRAFTING_TABLE = "gui.item_recipe.enhanced_crafting_table";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_NOT_FOUND = "gui.recipe_viewer.structure_not_found";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_LAYOUT_ERROR = "gui.recipe_viewer.structure_layout_error";
    public static final String GUI_RECIPE_VIEWER_OPERATION_FAILED = "gui.recipe_viewer.operation_failed";
    public static final String GUI_RECIPE_VIEWER_VIEW_RECIPES_NAME = "gui.recipe_viewer.view_recipes.name";
    public static final String GUI_RECIPE_VIEWER_VIEW_RECIPES_LORE = "gui.recipe_viewer.view_recipes.lore";
    public static final String GUI_RECIPE_VIEWER_RECIPES_LIST_ERROR = "gui.recipe_viewer.recipes_list_error";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_LOAD_FAILED = "gui.recipe_viewer.structure_load_failed";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_LOAD_FAILED_LORE = "gui.recipe_viewer.structure_load_failed.lore";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_INFO_NAME = "gui.recipe_viewer.structure_info.name";
    public static final String GUI_RECIPE_VIEWER_STRUCTURE_INFO_LORE = "gui.recipe_viewer.structure_info.lore";
    public static final String GUI_RECIPE_VIEWER_LANGUAGE_KEY_NOT_FOUND = "gui.recipe_viewer.language_key_not_found";
    public static final String GUI_STRUCTURE_LAYOUT_TITLE = "gui.structure_layout.title";
    public static final String GUI_STRUCTURE_LAYOUT_EMPTY_LAYER_NAME = "gui.structure_layout.empty_layer.name";
    public static final String GUI_STRUCTURE_LAYOUT_EMPTY_LAYER_LORE = "gui.structure_layout.empty_layer.lore";
    public static final String GUI_STRUCTURE_LAYOUT_OVERSIZED_NAME = "gui.structure_layout.oversized.name";
    public static final String GUI_STRUCTURE_LAYOUT_OVERSIZED_LORE = "gui.structure_layout.oversized.lore";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_CRAFTING_TABLE_NAME = "gui.structure_layout.block.crafting_table_name";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_CRAFTING_TABLE_LORE = "gui.structure_layout.block.crafting_table_lore";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_DISPENSER_NAME = "gui.structure_layout.block.dispenser_name";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_DISPENSER_LORE = "gui.structure_layout.block.dispenser_lore";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_GENERIC_NAME = "gui.structure_layout.block.generic_name";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_GENERIC_LORE = "gui.structure_layout.block.generic_lore";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_COORDINATES = "gui.structure_layout.block.coordinates";
    public static final String GUI_STRUCTURE_LAYOUT_BLOCK_MAIN_MARKER = "gui.structure_layout.block.main_marker";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_UP_ENABLED = "gui.structure_layout.layer_up.enabled";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_UP_DISABLED = "gui.structure_layout.layer_up.disabled";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_UP_ENABLED_LORE = "gui.structure_layout.layer_up.enabled_lore";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_UP_DISABLED_LORE = "gui.structure_layout.layer_up.disabled_lore";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_DOWN_ENABLED = "gui.structure_layout.layer_down.enabled";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_DOWN_DISABLED = "gui.structure_layout.layer_down.disabled";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_DOWN_ENABLED_LORE = "gui.structure_layout.layer_down.enabled_lore";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_DOWN_DISABLED_LORE = "gui.structure_layout.layer_down.disabled_lore";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_INFO_NAME = "gui.structure_layout.layer_info.name";
    public static final String GUI_STRUCTURE_LAYOUT_LAYER_INFO_LORE = "gui.structure_layout.layer_info.lore";
    public static final String GUI_STRUCTURE_LAYOUT_STRUCTURE_INFO_NAME = "gui.structure_layout.structure_info.name";
    public static final String GUI_STRUCTURE_LAYOUT_STRUCTURE_INFO_LORE = "gui.structure_layout.structure_info.lore";
    public static final String GUI_STRUCTURE_RECIPES_TITLE = "gui.structure_recipes.title";
    public static final String GUI_STRUCTURE_RECIPES_NO_RECIPES = "gui.structure_recipes.no_recipes";
    public static final String GUI_STRUCTURE_RECIPES_NO_RECIPES_LORE = "gui.structure_recipes.no_recipes_lore";
    public static final String GUI_STRUCTURE_RECIPES_CLICK_VIEW_RECIPE = "gui.structure_recipes.click_view_recipe";
    public static final String GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_NAME = "gui.structure_recipes.recipe_locked_name";
    public static final String GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_LORE_EXP = "gui.structure_recipes.recipe_locked_lore_exp";
    public static final String GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_LORE_CLICK = "gui.structure_recipes.recipe_locked_lore_click";
    public static final String GUI_STRUCTURE_RECIPES_UNLOCK_FAILED_DEFAULT = "gui.structure_recipes.unlock_failed_default";
    public static final String GUI_STRUCTURE_RECIPES_ERROR_OPEN_RECIPE = "gui.structure_recipes.error_open_recipe";
    public static final String GUI_STRUCTURE_RECIPES_ERROR_CLICK_EVENT = "gui.structure_recipes.error_click_event";
    public static final String ITEM_BUILDER_BORDER_ITEM_NAME = "items.border_item.name";
    public static final String ITEM_BUILDER_BACK_BUTTON_NAME = "items.buttons.back.name";
    public static final String ITEM_BUILDER_NEXT_PAGE_BUTTON_NAME = "items.buttons.next_page.name";
    public static final String ITEM_BUILDER_PREVIOUS_PAGE_BUTTON_NAME = "items.buttons.previous_page.name";
    public static final String ITEM_BUILDER_PAGE_INFO_NAME = "items.buttons.page_info.name";
    public static final String ITEM_BUILDER_PAGE_INFO_CURRENT_PAGE = "items.buttons.page_info.current_page";
    public static final String ITEM_BUILDER_PAGE_INFO_TOTAL_ITEMS = "items.buttons.page_info.total_items";
    public static final String ITEMS_EXPLOSIVE_PICKAXE_NAME = "items.explosive_pickaxe.name";
    public static final String ITEMS_EXPLOSIVE_PICKAXE_DISPLAY_NAME = "items.explosive_pickaxe.display_name";
    public static final String ITEMS_EXPLOSIVE_PICKAXE_LORE = "items.explosive_pickaxe.lore";
    public static final String ITEMS_EXPLOSIVE_PICKAXE_LORE_RADIUS_FEATURE = "items.explosive_pickaxe.lore.radius_feature";
    public static final String ITEMS_SMELTING_PICKAXE_NAME = "items.smelting_pickaxe.name";
    public static final String ITEMS_SMELTING_PICKAXE_LORE = "items.smelting_pickaxe.lore";
    public static final String RECIPES_EXPLOSIVE_PICKAXE_NAME = "recipes.explosive_pickaxe.name";
    public static final String RECIPES_SMELTING_PICKAXE_NAME = "recipes.smelting_pickaxe.name";

    // Recipe registration messages
    public static final String RECIPES_REGISTER_ALL_SUCCESS = "recipes.register.all_success";
    public static final String RECIPES_REGISTER_ALL_FAILED = "recipes.register.all_failed";
    public static final String RECIPES_REGISTER_EXPLOSIVE_PICKAXE_FAILED = "recipes.register.explosive_pickaxe_failed";
    public static final String RECIPES_REGISTER_SMELTING_PICKAXE_FAILED = "recipes.register.smelting_pickaxe_failed";

    // Multiblock messages
    public static final String MULTIBLOCK_NOT_UNLOCKED = "multiblock.not_unlocked";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_CREATED = "multiblock.enhanced_crafting_table.created";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_HINT = "multiblock.enhanced_crafting_table.hint";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_ERROR = "multiblock.enhanced_crafting_table.error";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_NO_RECIPE = "multiblock.enhanced_crafting_table.no_recipe";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_INVENTORY_FULL = "multiblock.enhanced_crafting_table.inventory_full";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_CRAFT_SUCCESS = "multiblock.enhanced_crafting_table.craft_success";
    public static final String MULTIBLOCK_ENHANCED_CRAFTING_CRAFT_PARTIAL = "multiblock.enhanced_crafting_table.craft_partial";

    // Unlock messages
    public static final String UNLOCK_SUCCESS = "unlock.success";
    public static final String UNLOCK_INSUFFICIENT_EXP = "unlock.insufficient_exp";
    public static final String UNLOCK_ALREADY_UNLOCKED = "unlock.already_unlocked";
    public static final String UNLOCK_ITEM_NOT_FOUND = "unlock.item_not_found";
    public static final String UNLOCK_PLAYER_NOT_FOUND = "unlock.player_not_found";
    public static final String UNLOCK_ERROR = "unlock.error";

    // Recipe messages
    public static final String RECIPE_NOT_UNLOCKED = "recipe.not_unlocked";
    public static final String RECIPE_NOT_FOUND = "recipe.errors.not_found";
    public static final String RECIPE_INVALID = "recipe.errors.invalid";

    // Tool messages
    public static final String TOOLS_EXPLOSIVE_COOLDOWN = "tools.explosive_pickaxe.cooldown_message";
    public static final String TOOLS_EXPLOSIVE_NO_PERMISSION = "tools.explosive_pickaxe.no_permission";
    public static final String TOOLS_EXPLOSIVE_ERROR = "tools.explosive_pickaxe.error";
    public static final String TOOLS_SMELTING_MESSAGE = "tools.smelting_pickaxe.smelting_message";
    public static final String TOOLS_SMELTING_NO_PERMISSION = "tools.smelting_pickaxe.no_permission";
    public static final String TOOLS_SMELTING_ERROR = "tools.smelting_pickaxe.error";
    public static final String TOOLS_SPECIAL_TOOL_DEFAULT_LORE = "tools.special_tool.default_lore";
    public static final String TOOLS_SPECIAL_TOOL_DISPLAY_NAME_FORMAT = "tools.special_tool.display_name_format";

    // Config Manager messages
    public static final String CONFIG_FILE_LOADED = "debug.config_loaded";
    public static final String LANGUAGE_FILE_LOADED = "debug.language_file_loaded";
    public static final String CONFIG_RELOAD_COMPLETED = "debug.config_reload_completed";
    public static final String CONFIG_LANGUAGE_NOT_FOUND = "errors.config.language_not_found";
    public static final String CONFIG_LANGUAGE_KEY_NOT_FOUND = "errors.config.language_key_not_found";
    public static final String CONFIG_LANGUAGE_LIST_NOT_FOUND = "errors.config.language_list_not_found";

    // Error messages
    public static final String ERROR_CONFIG_LOAD_FAILED = "errors.config.load_failed";
    public static final String ERROR_CONFIG_SAVE_FAILED = "errors.config.save_failed";
    public static final String ERROR_CONFIG_RELOAD_FAILED = "errors.config.reload_failed";
    public static final String ERROR_ITEM_CREATION_FAILED = "errors.item.creation_failed";
    public static final String ERROR_GUI_OPEN_FAILED = "errors.gui.open_failed";
    public static final String ERROR_MULTIBLOCK_ACTIVATION_FAILED = "errors.multiblock.activation_failed";
    public static final String ERROR_DATA_SAVE_FAILED = "errors.data.save_failed";
    public static final String ITEMS_MAGNET_NAME = "items.magnet.name";
    public static final String ITEMS_MAGNET_LORE = "items.magnet.lore";
    public static final String TOOLS_MAGNET_COOLDOWN = "tools.magnet.cooldown_message";
    public static final String TOOLS_MAGNET_NO_ITEMS = "tools.magnet.no_items_found";
    public static final String TOOLS_MAGNET_SUCCESS = "tools.magnet.success_message";
    public static final String TOOLS_MAGNET_NO_PERMISSION = "tools.magnet.no_permission";
    public static final String RECIPES_MAGNET_NAME = "recipes.magnet.name";
    // Guide book
    public static final String GUIDE_BOOK_DISPLAY_NAME = "guide_book.display_name";

    private Messages() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\constants\Permissions.java
==================================================
package cn.fandmc.flametech.constants;

public final class Permissions {

    // Base permissions
    public static final String BASE = "flametech";
    public static final String ADMIN = "flametech.admin";
    public static final String USE = "flametech.use";

    // Command permissions
    public static final String COMMAND_HELP = "flametech.command.help";
    public static final String COMMAND_GUIDE = "flametech.command.guide";
    public static final String COMMAND_OPEN = "flametech.command.open";
    public static final String COMMAND_RELOAD = "flametech.command.reload";

    // Tool permissions
    public static final String TOOLS_EXPLOSIVE_PICKAXE = "flametech.tools.explosive_pickaxe";
    public static final String TOOLS_SMELTING_PICKAXE = "flametech.tools.smelting_pickaxe";

    // Multiblock permissions
    public static final String MULTIBLOCK_ENHANCED_CRAFTING = "flametech.multiblock.enhanced_crafting";

    private Permissions() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\exceptions\FlameTechException.java
==================================================
package cn.fandmc.flametech.exceptions;

/**
 * FlameTech插件基础异常类
 */
public class FlameTechException extends Exception {

    private final String errorCode;

    public FlameTechException(String message) {
        super(message);
        this.errorCode = "UNKNOWN";
    }

    public FlameTechException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public FlameTechException(String message, Throwable cause) {
        super(message, cause);
        this.errorCode = "UNKNOWN";
    }

    public FlameTechException(String message, String errorCode, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }

    @Override
    public String toString() {
        return String.format("FlameTechException[%s]: %s", errorCode, getMessage());
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\exceptions\MultiblockException.java
==================================================
package cn.fandmc.flametech.exceptions;

/**
 * 多方块结构相关异常
 */
public class MultiblockException extends FlameTechException {

    private final String structureId;

    public MultiblockException(String message, String structureId) {
        super(message, "MULTIBLOCK_ERROR");
        this.structureId = structureId;
    }

    public MultiblockException(String message, String structureId, Throwable cause) {
        super(message, "MULTIBLOCK_ERROR", cause);
        this.structureId = structureId;
    }

    public String getStructureId() {
        return structureId;
    }

    @Override
    public String toString() {
        return String.format("MultiblockException[%s]: %s (Structure: %s)",
                getErrorCode(), getMessage(), structureId);
    }

    // 静态工厂方法
    public static MultiblockException invalidStructure(String structureId) {
        return new MultiblockException("Invalid multiblock structure", structureId);
    }

    public static MultiblockException structureNotFound(String structureId) {
        return new MultiblockException("Multiblock structure not found", structureId);
    }

    public static MultiblockException structureMismatch(String structureId) {
        return new MultiblockException("Structure layout does not match", structureId);
    }

    public static MultiblockException activationFailed(String structureId, Throwable cause) {
        return new MultiblockException("Failed to activate multiblock structure", structureId, cause);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\exceptions\RecipeException.java
==================================================
package cn.fandmc.flametech.exceptions;

/**
 * 配方相关异常
 */
public class RecipeException extends FlameTechException {

    private final String recipeId;

    public RecipeException(String message, String recipeId) {
        super(message, "RECIPE_ERROR");
        this.recipeId = recipeId;
    }

    public RecipeException(String message, String recipeId, Throwable cause) {
        super(message, "RECIPE_ERROR", cause);
        this.recipeId = recipeId;
    }

    public String getRecipeId() {
        return recipeId;
    }

    @Override
    public String toString() {
        return String.format("RecipeException[%s]: %s (Recipe: %s)",
                getErrorCode(), getMessage(), recipeId);
    }

    // 静态工厂方法
    public static RecipeException invalidRecipe(String recipeId) {
        return new RecipeException("Invalid recipe configuration", recipeId);
    }

    public static RecipeException recipeNotFound(String recipeId) {
        return new RecipeException("Recipe not found", recipeId);
    }

    public static RecipeException ingredientMismatch(String recipeId) {
        return new RecipeException("Recipe ingredients do not match", recipeId);
    }

    public static RecipeException registrationFailed(String recipeId, Throwable cause) {
        return new RecipeException("Failed to register recipe", recipeId, cause);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\base\BaseGUI.java
==================================================
package cn.fandmc.flametech.gui.base;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;

import java.util.HashMap;
import java.util.Map;

/**
 * 所有GUI的基类
 */
public abstract class BaseGUI implements InventoryHolder {

    protected final Main plugin;
    protected final String guiId;
    protected final String title;
    protected final int size;
    protected final Inventory inventory;
    protected final Map<Integer, GUIComponent> components = new HashMap<>();

    protected String parentGUIId;
    protected Player currentViewer;

    public BaseGUI(Main plugin, String guiId, int size, String title) {
        this.plugin = plugin;
        this.guiId = guiId;
        this.size = size;
        this.title = MessageUtils.colorize(title);
        this.inventory = Bukkit.createInventory(this, size, this.title);

        validateSize();
    }

    private void validateSize() {
        if (size <= 0 || size % 9 != 0 || size > 54) {
            throw new IllegalArgumentException("Invalid inventory size: " + size);
        }
    }

    /**
     * 设置组件到指定槽位
     */
    public void setComponent(int slot, GUIComponent component) {
        if (!isValidSlot(slot)) {
            MessageUtils.logWarning("Invalid slot " + slot + " for GUI " + guiId);
            return;
        }

        if (component != null) {
            components.put(slot, component);
            updateSlot(slot);
        } else {
            removeComponent(slot);
        }
    }

    /**
     * 移除指定槽位的组件
     */
    public void removeComponent(int slot) {
        if (isValidSlot(slot)) {
            components.remove(slot);
            inventory.clear(slot);
        }
    }

    /**
     * 清空所有组件
     */
    public void clearComponents() {
        components.clear();
        inventory.clear();
    }

    /**
     * 更新指定槽位的显示
     */
    protected void updateSlot(int slot) {
        GUIComponent component = components.get(slot);
        if (component != null && currentViewer != null) {
            if (component.isVisible(currentViewer)) {
                inventory.setItem(slot, component.getDisplayItem());
            } else {
                inventory.clear(slot);
            }
        }
    }

    /**
     * 刷新整个GUI
     */
    public void refresh() {
        if (currentViewer != null) {
            buildGUI(currentViewer);
            updateAllSlots();
        }
    }

    /**
     * 更新所有槽位
     */
    protected void updateAllSlots() {
        for (int slot : components.keySet()) {
            updateSlot(slot);
        }
    }

    /**
     * 打开GUI给指定玩家
     */
    public void open(Player player) {
        if (!ValidationUtils.isValidPlayer(player)) {
            MessageUtils.logWarning("Attempted to open GUI for invalid player");
            return;
        }

        try {
            this.currentViewer = player;
            buildGUI(player);
            updateAllSlots();
            player.openInventory(inventory);

            onOpen(player);

        } catch (Exception e) {
            MessageUtils.logError("Failed to open GUI " + guiId + " for player " + player.getName() + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 处理点击事件
     */
    public void handleClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) {
            return;
        }

        // 取消事件，防止物品被拿走
        event.setCancelled(true);

        int slot = event.getRawSlot();
        if (!isValidSlot(slot)) {
            return;
        }

        GUIComponent component = components.get(slot);
        if (component != null && component.isClickable(player)) {
            try {
                component.onClick(player, event);
                onClick(player, event, component);
            } catch (Exception e) {
                MessageUtils.logError("Error handling click in GUI " + guiId + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    /**
     * 检查槽位是否有效
     */
    protected boolean isValidSlot(int slot) {
        return slot >= 0 && slot < size;
    }

    /**
     * 设置父GUI
     */
    public void setParentGUI(String parentGUIId) {
        this.parentGUIId = parentGUIId;
    }

    /**
     * 获取父GUI ID
     */
    public String getParentGUIId() {
        return parentGUIId;
    }

    /**
     * 公开的关闭方法，供管理器调用
     */
    public void handleClose(Player player) {
        onClose(player);
    }

    // 抽象方法 - 子类必须实现

    /**
     * 构建GUI内容
     */
    protected abstract void buildGUI(Player player);

    // 可选的钩子方法

    /**
     * GUI打开时调用
     */
    protected void onOpen(Player player) {
        // 默认空实现
    }

    /**
     * GUI关闭时调用
     */
    protected void onClose(Player player) {
        // 默认空实现
    }

    /**
     * 组件被点击时调用
     */
    protected void onClick(Player player, InventoryClickEvent event, GUIComponent component) {
        // 默认空实现
    }

    // Getter方法

    public String getGuiId() {
        return guiId;
    }

    public String getTitle() {
        return title;
    }

    public int getSize() {
        return size;
    }

    public Player getCurrentViewer() {
        return currentViewer;
    }

    @Override
    public Inventory getInventory() {
        return inventory;
    }

    public Main getPlugin() {
        return plugin;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\base\PaginatedGUI.java
==================================================
package cn.fandmc.flametech.gui.base;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.NavigationComponent;
import cn.fandmc.flametech.gui.components.StaticComponent;
import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;

/**
 * 分页GUI基类 - 最终修复版本
 *
 * 核心修复：翻页时只更新显示，不重新构建整个GUI
 */
public abstract class PaginatedGUI extends BaseGUI {

    protected final List<GUIComponent> pageItems = new ArrayList<>();
    protected int currentPage = 0;
    protected final int[] contentSlots;
    protected final int itemsPerPage;

    // 控制按钮槽位
    protected final int previousPageSlot;
    protected final int pageInfoSlot;
    protected final int nextPageSlot;

    public PaginatedGUI(Main plugin, String guiId, String title) {
        this(plugin, guiId, 54, title, getDefaultContentSlots(), 48, 49, 50);
    }

    public PaginatedGUI(Main plugin, String guiId, int size, String title, int[] contentSlots,
                        int previousSlot, int infoSlot, int nextSlot) {
        super(plugin, guiId, size, title);
        this.contentSlots = contentSlots != null ? contentSlots : getDefaultContentSlots();
        this.itemsPerPage = this.contentSlots.length;
        this.previousPageSlot = previousSlot;
        this.pageInfoSlot = infoSlot;
        this.nextPageSlot = nextSlot;
    }

    private static int[] getDefaultContentSlots() {
        return new int[]{
                10, 11, 12, 13, 14, 15, 16,
                19, 20, 21, 22, 23, 24, 25,
                28, 29, 30, 31, 32, 33, 34
        };
    }

    @Override
    protected void buildGUI(Player player) {
        // 设置边框
        setupBorder();

        // 设置控制按钮
        setupControlButtons(player);

        // 显示当前页内容
        displayCurrentPage(player);

        // 子类可以添加额外的组件
        buildExtraComponents(player);
    }

    protected void setupBorder() {
        var borderItem = ItemBuilder.createBorderItem();
        var borderComponent = new StaticComponent(borderItem);

        // 顶部和底部边框
        for (int i = 0; i < 9; i++) {
            setComponent(i, borderComponent);
            if (size > 45) {
                setComponent(45 + i, borderComponent);
            }
        }

        // 侧边边框
        for (int row = 1; row < (size / 9) - 1; row++) {
            setComponent(row * 9, borderComponent);
            setComponent(row * 9 + 8, borderComponent);
        }
    }

    protected void setupControlButtons(Player player) {
        // 上一页按钮
        setComponent(previousPageSlot, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return currentPage > 0 ?
                        ItemBuilder.createPreviousPageButton() :
                        new ItemBuilder(org.bukkit.Material.GRAY_STAINED_GLASS_PANE)
                                .displayName(plugin.getConfigManager().getLang(Messages.GUI_COMMON_NO_PREVIOUS_PAGE))
                                .build();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                if (currentPage > 0) {
                    previousPage(player);
                }
            }

            @Override
            public boolean isClickable(Player player) {
                return currentPage > 0;
            }
        });

        // 页面信息 - 动态更新
        setComponent(pageInfoSlot, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return ItemBuilder.createPageInfoItem(currentPage + 1, getTotalPages(), pageItems.size());
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                // 页面信息不可点击
            }

            @Override
            public boolean isClickable(Player player) {
                return false;
            }
        });

        // 下一页按钮 - 修复版本
        setComponent(nextPageSlot, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return hasNextPage() ?
                        ItemBuilder.createNextPageButton() :
                        new ItemBuilder(org.bukkit.Material.GRAY_STAINED_GLASS_PANE)
                                .displayName(plugin.getConfigManager().getLang(Messages.GUI_COMMON_NO_NEXT_PAGE))
                                .build();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                if (hasNextPage()) {
                    nextPage(player);
                }
            }

            @Override
            public boolean isClickable(Player player) {
                return hasNextPage();
            }
        });
    }

    /**
     * 检查是否有下一页 - 修复版本
     */
    private boolean hasNextPage() {
        if (pageItems.isEmpty()) {
            return false;
        }

        int totalPages = getTotalPages();
        return totalPages > 1 && currentPage < (totalPages - 1);
    }

    protected void displayCurrentPage(Player player) {
        // 清空内容槽位
        for (int slot : contentSlots) {
            removeComponent(slot);
        }

        if (pageItems.isEmpty()) {
            MessageUtils.logDebug("PaginatedGUI: 没有页面项目可显示");
            return;
        }

        int startIndex = currentPage * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, pageItems.size());

        MessageUtils.logDebug("PaginatedGUI: 显示项目 " + startIndex + " 到 " + (endIndex - 1) +
                " (当前页=" + currentPage + ", 每页=" + itemsPerPage + ")");

        for (int i = 0; i < itemsPerPage && (startIndex + i) < endIndex; i++) {
            int slot = contentSlots[i];
            GUIComponent item = pageItems.get(startIndex + i);

            // 对于UnlockableComponent，使用玩家特定的显示
            if (item instanceof UnlockableComponent unlockableItem) {
                setComponent(slot, new PlayerSpecificUnlockableWrapper(unlockableItem, player));
            } else {
                setComponent(slot, item);
            }
        }
    }

    /**
     * 包装器，用于为特定玩家显示UnlockableComponent的正确状态
     */
    private static class PlayerSpecificUnlockableWrapper implements GUIComponent {
        private final UnlockableComponent original;
        private final Player player;

        public PlayerSpecificUnlockableWrapper(UnlockableComponent original, Player player) {
            this.original = original;
            this.player = player;
        }

        @Override
        public ItemStack getDisplayItem() {
            return original.getDisplayItemForPlayer(player);
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            original.onClick(player, event);
        }

        @Override
        public boolean isVisible(Player player) {
            return original.isVisible(player);
        }

        @Override
        public boolean isClickable(Player player) {
            return original.isClickable(player);
        }
    }

    /**
     * 子类可以重写此方法添加额外组件
     */
    protected void buildExtraComponents(Player player) {
        // 默认空实现
    }

    /**
     * 下一页 - 修复版本：只更新显示，不重新构建GUI
     */
    public void nextPage(Player player) {
        if (hasNextPage()) {
            currentPage++;
            MessageUtils.logDebug("PaginatedGUI: 切换到下一页 " + currentPage);

            // 只更新页面显示，不重新构建整个GUI
            updatePageDisplay(player);
        } else {
            MessageUtils.logDebug("PaginatedGUI: 已经是最后一页，无法前进");
        }
    }

    /**
     * 上一页 - 修复版本：只更新显示，不重新构建GUI
     */
    public void previousPage(Player player) {
        if (currentPage > 0) {
            currentPage--;
            MessageUtils.logDebug("PaginatedGUI: 切换到上一页 " + currentPage);

            // 只更新页面显示，不重新构建整个GUI
            updatePageDisplay(player);
        } else {
            MessageUtils.logDebug("PaginatedGUI: 已经是第一页，无法后退");
        }
    }

    /**
     * 更新页面显示 - 新方法：只更新必要的部分
     */
    private void updatePageDisplay(Player player) {
        // 1. 更新内容显示
        displayCurrentPage(player);

        // 2. 更新控制按钮的显示状态
        updateControlButtons(player);
    }

    /**
     * 更新控制按钮的显示状态
     */
    private void updateControlButtons(Player player) {
        try {
            // 更新上一页按钮
            GUIComponent prevButton = components.get(previousPageSlot);
            if (prevButton != null) {
                updateSlot(previousPageSlot);
            }

            // 更新页面信息
            GUIComponent pageInfo = components.get(pageInfoSlot);
            if (pageInfo != null) {
                updateSlot(pageInfoSlot);
            }

            // 更新下一页按钮
            GUIComponent nextButton = components.get(nextPageSlot);
            if (nextButton != null) {
                updateSlot(nextPageSlot);
            }

        } catch (Exception e) {
            MessageUtils.logError("更新控制按钮时发生错误: " + e.getMessage());
        }
    }

    /**
     * 跳转到指定页 - 修复版本
     */
    public void goToPage(int page, Player player) {
        int totalPages = getTotalPages();
        if (page >= 0 && page < totalPages) {
            currentPage = page;
            MessageUtils.logDebug("PaginatedGUI: 跳转到页面 " + currentPage);

            // 只更新页面显示，不重新构建整个GUI
            updatePageDisplay(player);
        } else {
            MessageUtils.logDebug("PaginatedGUI: 页面 " + page + " 超出范围 (0-" + (totalPages - 1) + ")");
        }
    }

    /**
     * 添加页面项目
     */
    public void addPageItem(GUIComponent item) {
        if (item != null) {
            pageItems.add(item);
            MessageUtils.logDebug("PaginatedGUI: 添加页面项目，现在总数: " + pageItems.size());
        }
    }

    /**
     * 移除页面项目
     */
    public void removePageItem(int index) {
        if (index >= 0 && index < pageItems.size()) {
            pageItems.remove(index);

            // 调整当前页 - 修复版本
            int totalPages = getTotalPages();
            if (totalPages == 0) {
                currentPage = 0;
            } else if (currentPage >= totalPages) {
                currentPage = Math.max(0, totalPages - 1);
            }

            MessageUtils.logDebug("PaginatedGUI: 移除项目后，当前页=" + currentPage + ", 总页数=" + totalPages);
        }
    }

    /**
     * 清空页面项目
     */
    public void clearPageItems() {
        pageItems.clear();
        currentPage = 0;
        MessageUtils.logDebug("PaginatedGUI: 清空所有页面项目");
    }

    /**
     * 获取总页数 - 修复版本
     */
    public int getTotalPages() {
        if (pageItems.isEmpty() || itemsPerPage <= 0) {
            return 1;
        }
        return (int) Math.ceil((double) pageItems.size() / itemsPerPage);
    }

    /**
     * 获取当前页
     */
    public int getCurrentPage() {
        return currentPage;
    }

    /**
     * 获取页面项目列表
     */
    public List<GUIComponent> getPageItems() {
        return new ArrayList<>(pageItems);
    }

    /**
     * 检查当前页是否有效
     */
    public boolean isCurrentPageValid() {
        int totalPages = getTotalPages();
        return currentPage >= 0 && currentPage < totalPages;
    }

    /**
     * 修正当前页到有效范围
     */
    public void fixCurrentPage() {
        int totalPages = getTotalPages();
        if (totalPages == 0) {
            currentPage = 0;
        } else if (currentPage >= totalPages) {
            currentPage = totalPages - 1;
        } else if (currentPage < 0) {
            currentPage = 0;
        }

        MessageUtils.logDebug("PaginatedGUI: 修正当前页为 " + currentPage);
    }

    /**
     * 刷新GUI - 修复版本：只在必要时重新构建
     */
    @Override
    public void refresh() {
        // 先修正当前页
        fixCurrentPage();

        // 如果当前有观察者，只更新显示
        if (currentViewer != null) {
            updatePageDisplay(currentViewer);
        }
    }

    /**
     * 完全重新构建GUI（用于强制刷新）
     */
    public void forceRefresh() {
        // 先修正当前页
        fixCurrentPage();

        // 然后完全重新构建
        super.refresh();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\machines\EnhancedCraftingTableButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.machines;

import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.RecipeViewerGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 增强工作台按钮
 */
public class EnhancedCraftingTableButton extends UnlockableComponent {

    public EnhancedCraftingTableButton() {
        super(ItemKeys.MULTIBLOCK_ENHANCED_CRAFTING_TABLE, "gui.basic_machines.enhanced_crafting.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.CRAFTING_TABLE)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.basic_machines.enhanced_crafting.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        try {
            // 已解锁时打开配方查看界面
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    RecipeViewerGUI viewerGUI = RecipeViewerGUI.getInstance(plugin, ItemKeys.ID_ENHANCED_CRAFTING_TABLE);
                    viewerGUI.open(player);
                } catch (Exception e) {
                    MessageUtils.logError("Failed to open recipe viewer: " + e.getMessage());
                    MessageUtils.sendMessage(player, "&c打开配方查看器时发生错误");
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error in EnhancedCraftingTableButton: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c操作失败，请稍后重试");
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\machines\OreSifterButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.machines;

import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.RecipeViewerGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 筛矿机按钮
 */
public class OreSifterButton extends UnlockableComponent {

    public OreSifterButton() {
        super("multiblock.ore_sifter", "gui.basic_machines.ore_sifter.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.OAK_FENCE)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.basic_machines.ore_sifter.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        try {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    RecipeViewerGUI viewerGUI = RecipeViewerGUI.getInstance(plugin, "ore_sifter");
                    viewerGUI.open(player);
                } catch (Exception e) {
                    MessageUtils.logError("Failed to open ore sifter viewer: " + e.getMessage());
                    MessageUtils.sendMessage(player, "&c打开筛矿机查看器时发生错误");
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error in OreSifterButton: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c操作失败，请稍后重试");
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\machines\OreWasherButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.machines;

import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.RecipeViewerGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 洗矿机按钮
 */
public class OreWasherButton extends UnlockableComponent {

    public OreWasherButton() {
        super("multiblock.ore_washer", "gui.basic_machines.ore_washer.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.OAK_TRAPDOOR)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.basic_machines.ore_washer.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        try {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    RecipeViewerGUI viewerGUI = RecipeViewerGUI.getInstance(plugin, "ore_washer");
                    viewerGUI.open(player);
                } catch (Exception e) {
                    MessageUtils.logError("Failed to open ore washer viewer: " + e.getMessage());
                    MessageUtils.sendMessage(player, "&c打开洗矿机查看器时发生错误");
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error in OreWasherButton: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c操作失败，请稍后重试");
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\machines\PressureMachineButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.machines;

import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.RecipeViewerGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 压力机按钮
 */
public class PressureMachineButton extends UnlockableComponent {

    public PressureMachineButton() {
        super("multiblock.pressure_machine", "gui.basic_machines.pressure_machine.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.GLASS)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.basic_machines.pressure_machine.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        try {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    RecipeViewerGUI viewerGUI = RecipeViewerGUI.getInstance(plugin, "pressure_machine");
                    viewerGUI.open(player);
                } catch (Exception e) {
                    MessageUtils.logError("Failed to open pressure machine viewer: " + e.getMessage());
                    MessageUtils.sendMessage(player, "&c打开压力机查看器时发生错误");
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error in PressureMachineButton: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c操作失败，请稍后重试");
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\machines\SmeltingFurnaceButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.machines;

import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.RecipeViewerGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 治炼炉按钮
 */
public class SmeltingFurnaceButton extends UnlockableComponent {

    public SmeltingFurnaceButton() {
        super("multiblock.smelting_furnace", "gui.basic_machines.smelting_furnace.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.NETHER_BRICK_FENCE)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.basic_machines.smelting_furnace.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        try {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    RecipeViewerGUI viewerGUI = RecipeViewerGUI.getInstance(plugin, "smelting_furnace");
                    viewerGUI.open(player);
                } catch (Exception e) {
                    MessageUtils.logError("Failed to open smelting furnace viewer: " + e.getMessage());
                    MessageUtils.sendMessage(player, "&c打开治炼炉查看器时发生错误");
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error in SmeltingFurnaceButton: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c操作失败，请稍后重试");
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\main\BasicMachinesButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 基础机器按钮
 */
public class BasicMachinesButton implements GUIComponent {

    @Override
    public ItemStack getDisplayItem() {
        Main plugin = Main.getInstance();

        return new ItemBuilder(Material.FURNACE)
                .displayName(plugin.getConfigManager().getLang(Messages.GUI_BUTTONS_BASIC_MACHINES_NAME))
                .lore(plugin.getConfigManager().getStringList(Messages.GUI_BUTTONS_BASIC_MACHINES_LORE))
                .build();
    }

    @Override
    public void onClick(Player player, InventoryClickEvent event) {
        Main.getInstance().getGuiManager().openGUI(player, "basic_machines");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\main\MaterialsButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;

/**
 * 矿物按钮 - 主界面上的矿物/材料入口
 */
public class MaterialsButton implements GUIComponent {

    @Override
    public ItemStack getDisplayItem() {
        Main plugin = Main.getInstance();
        int totalMaterials = plugin.getMaterialManager().getRegisteredMaterialCount();

        List<String> lore = new ArrayList<>();
        lore.add("&7查看和获取各种工业材料");
        lore.add("&7包含：粉末、锭、合金、宝石等");
        lore.add("");
        lore.add("&e材料统计:");
        lore.add("&7总材料数: &e" + totalMaterials + " &7种");
        lore.add("");
        lore.add("&e点击进入材料大全");

        return new ItemBuilder(Material.RAW_COPPER)
                .displayName("&6&l矿物材料")
                .lore(lore)
                .glow()
                .build();
    }

    @Override
    public void onClick(Player player, InventoryClickEvent event) {
        Main.getInstance().getGuiManager().openGUI(player, "materials");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\main\ToolsButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 工具按钮
 */
public class ToolsButton implements GUIComponent {

    @Override
    public ItemStack getDisplayItem() {
        Main plugin = Main.getInstance();

        return new ItemBuilder(Material.DIAMOND_PICKAXE)
                .displayName(plugin.getConfigManager().getLang(Messages.GUI_BUTTONS_TOOLS_NAME))
                .lore(plugin.getConfigManager().getStringList(Messages.GUI_BUTTONS_TOOLS_LORE))
                .build();
    }

    @Override
    public void onClick(Player player, InventoryClickEvent event) {
        Main.getInstance().getGuiManager().openGUI(player, "tools");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\tools\ExplosivePickaxeButton.java
==================================================
// ExplosivePickaxeButton.java
package cn.fandmc.flametech.gui.buttons.tools;

import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.ItemRecipeGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.recipes.base.Recipe;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Optional;

/**
 * 爆炸镐按钮
 */
public class ExplosivePickaxeButton extends UnlockableComponent {

    public ExplosivePickaxeButton() {
        super(ItemKeys.RECIPE_EXPLOSIVE_PICKAXE, "gui.tools.explosive_pickaxe.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.IRON_PICKAXE)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.tools.explosive_pickaxe.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        Optional<Recipe> recipeOpt = plugin.getRecipeManager().getRecipe(ItemKeys.ID_EXPLOSIVE_PICKAXE);
        ItemRecipeGUI recipeGUI = new ItemRecipeGUI(plugin, recipeOpt.get(), ItemKeys.ID_ENHANCED_CRAFTING_TABLE);
        recipeGUI.open(player);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\tools\MagnetButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.tools;

import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.ItemRecipeGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.recipes.base.Recipe;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Optional;

/**
 * 吸铁石按钮
 */
public class MagnetButton extends UnlockableComponent {

    public MagnetButton() {
        super(ItemKeys.RECIPE_MAGNET, "gui.tools.magnet.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.COMPASS)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.tools.magnet.lore"))
                .glow()
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        Optional<Recipe> recipeOpt = plugin.getRecipeManager().getRecipe(ItemKeys.ID_MAGNET);
        ItemRecipeGUI recipeGUI = new ItemRecipeGUI(plugin, recipeOpt.get(), ItemKeys.ID_ENHANCED_CRAFTING_TABLE);
        recipeGUI.open(player);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\buttons\tools\SmeltingPickaxeButton.java
==================================================
package cn.fandmc.flametech.gui.buttons.tools;

import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.gui.components.UnlockableComponent;
import cn.fandmc.flametech.gui.impl.utils.ItemRecipeGUI;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.recipes.base.Recipe;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Optional;

/**
 * 熔炼镐按钮
 */
public class SmeltingPickaxeButton extends UnlockableComponent {

    public SmeltingPickaxeButton() {
        super(ItemKeys.RECIPE_SMELTING_PICKAXE, "gui.tools.smelting_pickaxe.name");
    }

    @Override
    protected ItemStack createUnlockedDisplay(Player player) {
        return new ItemBuilder(Material.IRON_PICKAXE)
                .displayName(plugin.getConfigManager().getLang(getDisplayNameKey()))
                .lore(plugin.getConfigManager().getStringList("gui.tools.smelting_pickaxe.lore"))
                .build();
    }

    @Override
    protected void onAlreadyUnlocked(Player player, InventoryClickEvent event) {
        Optional<Recipe> recipeOpt = plugin.getRecipeManager().getRecipe(ItemKeys.ID_SMELTING_PICKAXE);
        ItemRecipeGUI recipeGUI = new ItemRecipeGUI(plugin, recipeOpt.get(), ItemKeys.ID_ENHANCED_CRAFTING_TABLE);
        recipeGUI.open(player);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\components\GUIComponent.java
==================================================
package cn.fandmc.flametech.gui.components;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 代表GUI中的一个组件
 */
public interface GUIComponent {

    /**
     * 获取显示的物品
     */
    ItemStack getDisplayItem();

    /**
     * 处理点击事件
     */
    void onClick(Player player, InventoryClickEvent event);

    /**
     * 检查组件是否可见
     */
    default boolean isVisible(Player player) {
        return true;
    }

    /**
     * 检查组件是否可点击
     */
    default boolean isClickable(Player player) {
        return true;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\components\NavigationComponent.java
==================================================
package cn.fandmc.flametech.gui.components;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 导航组件 - 用于GUI间导航
 */
public class NavigationComponent implements GUIComponent {

    public enum NavigationType {
        BACK, NEXT_PAGE, PREVIOUS_PAGE, CLOSE, OPEN_GUI
    }

    private final NavigationType type;
    private final String targetGUI;
    private final ItemStack displayItem;

    public NavigationComponent(NavigationType type) {
        this(type, null);
    }

    public NavigationComponent(NavigationType type, String targetGUI) {
        this.type = type;
        this.targetGUI = targetGUI;
        this.displayItem = createDisplayItem();
    }

    private ItemStack createDisplayItem() {
        return switch (type) {
            case BACK -> ItemBuilder.createBackButton();
            case NEXT_PAGE -> ItemBuilder.createNextPageButton();
            case PREVIOUS_PAGE -> ItemBuilder.createPreviousPageButton();
            case CLOSE -> new ItemBuilder(Material.BARRIER)
                    .displayName("&c关闭")
                    .build();
            case OPEN_GUI -> new ItemBuilder(Material.COMPASS)
                    .displayName("&e打开界面")
                    .build();
        };
    }

    @Override
    public ItemStack getDisplayItem() {
        return displayItem.clone();
    }

    @Override
    public void onClick(Player player, InventoryClickEvent event) {
        switch (type) {
            case BACK:
                handleBackButton(player);
                break;
            case CLOSE:
                player.closeInventory();
                break;
            case OPEN_GUI:
                if (targetGUI != null) {
                    Main.getInstance().getGuiManager().openGUI(player, targetGUI);
                }
                break;
            default:
                break;
        }
    }

    /**
     * 处理返回按钮逻辑
     */
    private void handleBackButton(Player player) {
        try {
            // 获取当前打开的GUI
            var currentGUI = Main.getInstance().getGuiManager().getOpenGUI(player);

            if (currentGUI.isPresent()) {
                String parentGUIId = currentGUI.get().getParentGUIId();

                if (parentGUIId != null && !parentGUIId.isEmpty()) {
                    // 打开父GUI
                    Main.getInstance().getGuiManager().openGUI(player, parentGUIId);
                } else {
                    // 没有父GUI，直接关闭
                    player.closeInventory();
                }
            } else {
                // 找不到当前GUI，直接关闭
                player.closeInventory();
            }
        } catch (Exception e) {
            // 出现错误时直接关闭
            player.closeInventory();
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\components\StaticComponent.java
==================================================
package cn.fandmc.flametech.gui.components;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 静态组件 - 不可点击，只用于显示
 */
public class StaticComponent implements GUIComponent {

    private final ItemStack displayItem;

    public StaticComponent(ItemStack displayItem) {
        this.displayItem = displayItem != null ? displayItem.clone() : null;
    }

    @Override
    public ItemStack getDisplayItem() {
        return displayItem != null ? displayItem.clone() : null;
    }

    @Override
    public void onClick(Player player, InventoryClickEvent event) {
    }

    @Override
    public boolean isClickable(Player player) {
        return false;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\components\UnlockableComponent.java
==================================================
package cn.fandmc.flametech.gui.components;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.unlock.data.UnlockResult;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;

/**
 * 可解锁组件基类
 */
public abstract class UnlockableComponent implements GUIComponent {

    protected final String unlockId;
    protected final String displayNameKey;
    protected final Main plugin;

    public UnlockableComponent(String unlockId, String displayNameKey) {
        this.unlockId = unlockId;
        this.displayNameKey = displayNameKey;
        this.plugin = Main.getInstance();
    }

    @Override
    public ItemStack getDisplayItem() {
        return createLockedDisplay();
    }

    /**
     * 为特定玩家获取正确的显示状态
     */
    public ItemStack getDisplayItemForPlayer(Player player) {
        if (plugin.getUnlockManager().isUnlocked(player, unlockId)) {
            return createUnlockedDisplay(player);
        } else {
            return createLockedDisplay();
        }
    }

    @Override
    public final void onClick(Player player, InventoryClickEvent event) {
        try {
            handleUnlockLogic(player, event);
        } catch (Exception e) {
            MessageUtils.logError("Error in UnlockableComponent onClick: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理解锁时发生错误");
        }
    }

    private void handleUnlockLogic(Player player, InventoryClickEvent event) {
        // 检查当前解锁状态
        boolean wasUnlocked = plugin.getUnlockManager().isUnlocked(player, unlockId);

        if (!wasUnlocked) {
            // 尝试解锁
            UnlockResult result = plugin.getUnlockManager().unlock(player, unlockId);

            if (result.isSuccess()) {
                // 解锁成功
                String itemName = plugin.getConfigManager().getLang(displayNameKey);
                MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_SUCCESS,
                        "%item%", itemName);

                // 安全地更新显示为已解锁状态
                updateDisplaySafely(event, createUnlockedDisplay(player));

                // 注意：解锁成功后不自动执行已解锁行为，让玩家再次点击
            } else {
                // 解锁失败，处理错误消息
                handleUnlockFailure(player, result);

                // 确保显示状态正确
                updateDisplaySafely(event, createLockedDisplay());
            }
        } else {
            onAlreadyUnlocked(player, event);
        }
    }

    /**
     * 安全地更新显示物品
     */
    private void updateDisplaySafely(InventoryClickEvent event, ItemStack newItem) {
        try {
            if (event.getInventory() != null && newItem != null) {
                int slot = event.getSlot();
                if (slot >= 0 && slot < event.getInventory().getSize()) {
                    event.getInventory().setItem(slot, newItem);
                }
            }
        } catch (Exception e) {
            MessageUtils.logError("Failed to update display item: " + e.getMessage());
        }
    }

    private void handleUnlockFailure(Player player, UnlockResult result) {
        switch (result.getStatus()) {
            case INSUFFICIENT_EXP:
                MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_INSUFFICIENT_EXP,
                        "%required%", String.valueOf(result.getRequiredExp()));
                break;
            case ALREADY_UNLOCKED:
                MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_ALREADY_UNLOCKED);
                break;
            default:
                MessageUtils.sendMessage(player, "&c解锁失败: " + result.getMessage());
                break;
        }
    }

    /**
     * 创建锁定状态的显示物品
     */
    protected ItemStack createLockedDisplay() {
        String displayName = plugin.getConfigManager().getLang(displayNameKey);
        int requiredExp = plugin.getUnlockManager().getRequiredExp(unlockId);

        List<String> lore = new ArrayList<>();
        lore.add("&7需要经验等级: &e" + requiredExp);
        lore.add("");
        lore.add("&e点击解锁");

        // 允许子类添加额外的lore
        List<String> extraLore = getExtraLockedLore();
        if (extraLore != null) {
            lore.addAll(extraLore);
        }

        return new ItemBuilder(Material.BARRIER)
                .displayName("&c" + displayName + " &7(未解锁)")
                .lore(lore)
                .build();
    }

    /**
     * 子类需要实现：创建解锁状态的显示物品
     */
    protected abstract ItemStack createUnlockedDisplay(Player player);

    /**
     * 子类需要实现：已解锁时的点击行为
     */
    protected abstract void onAlreadyUnlocked(Player player, InventoryClickEvent event);

    /**
     * 子类可以重写：为锁定状态添加额外的lore
     */
    protected List<String> getExtraLockedLore() {
        return null;
    }

    /**
     * 获取解锁ID
     */
    public String getUnlockId() {
        return unlockId;
    }

    /**
     * 获取显示名称键
     */
    public String getDisplayNameKey() {
        return displayNameKey;
    }

    @Override
    public boolean isVisible(Player player) {
        return true;
    }

    @Override
    public boolean isClickable(Player player) {
        return true;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\MainGUI.java
==================================================
package cn.fandmc.flametech.gui.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.buttons.main.*;
import org.bukkit.entity.Player;

/**
 * 主界面GUI
 */
public class MainGUI extends PaginatedGUI {

    public MainGUI(Main plugin) {
        super(plugin, "main", plugin.getConfigManager().getLang("guide_book.display_name"));
    }

    @Override
    protected void buildGUI(Player player) {
        // 清空并重新构建页面项目
        clearPageItems();

        // 添加主要功能按钮
        addPageItem(new BasicMachinesButton());
        addPageItem(new ToolsButton());
        addPageItem(new MaterialsButton());

        // 调用父类方法构建GUI
        super.buildGUI(player);
    }

    @Override
    protected void buildExtraComponents(Player player) {
        // 主界面不需要返回按钮
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\main\BasicMachinesGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.buttons.machines.*;
import cn.fandmc.flametech.gui.components.NavigationComponent;
import org.bukkit.entity.Player;

/**
 * 基础机器GUI
 */
public class BasicMachinesGUI extends PaginatedGUI {

    public BasicMachinesGUI(Main plugin) {
        super(plugin, "basic_machines",
                plugin.getConfigManager().getLang("gui.basic_machines.title"));
        setParentGUI("main");
    }

    @Override
    protected void buildGUI(Player player) {
        // 清空并重新构建页面项目
        clearPageItems();

        // 添加基础机器按钮
        addPageItem(new EnhancedCraftingTableButton());
        addPageItem(new SmeltingFurnaceButton());
        addPageItem(new OreWasherButton());
        addPageItem(new OreSifterButton());
        addPageItem(new PressureMachineButton());

        // 调用父类方法构建GUI
        super.buildGUI(player);
    }

    @Override
    protected void buildExtraComponents(Player player) {
        // 添加返回按钮
        setComponent(45, new NavigationComponent(NavigationComponent.NavigationType.BACK, getParentGUIId()));
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\main\MaterialsGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.NavigationComponent;
import cn.fandmc.flametech.gui.impl.utils.MaterialRelatedRecipesGUI;
import cn.fandmc.flametech.gui.impl.utils.MaterialViewerGUI;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.*;

/**
 * 矿物/材料GUI
 */
public class MaterialsGUI extends PaginatedGUI {

    private boolean materialsLoaded = false; // 标记材料是否已加载

    public MaterialsGUI(Main plugin) {
        super(plugin, "materials", plugin.getConfigManager().getLang("gui.materials.title"));
        setParentGUI("main");
    }

    @Override
    protected void buildGUI(Player player) {
        try {
            MessageUtils.logDebug("MaterialsGUI: 开始构建GUI for player " + player.getName() +
                    ", materialsLoaded=" + materialsLoaded +
                    ", currentPage=" + getCurrentPage());

            // 只在第一次打开或强制刷新时加载材料
            if (!materialsLoaded || pageItems.isEmpty()) {
                MessageUtils.logDebug("MaterialsGUI: 重新加载材料数据");
                loadMaterialsWithErrorHandling();
                materialsLoaded = true;
            } else {
                MessageUtils.logDebug("MaterialsGUI: 使用已缓存的材料数据，项目数=" + pageItems.size());
            }

            // 构建GUI
            super.buildGUI(player);

            // 记录构建结果
            MessageUtils.logDebug("MaterialsGUI: GUI构建完成 - 当前页=" + getCurrentPage() +
                    ", 总页数=" + getTotalPages() +
                    ", 材料数=" + pageItems.size());

        } catch (Exception e) {
            MessageUtils.logError("MaterialsGUI构建失败: " + e.getMessage());
            e.printStackTrace();

            // 出错时重置并显示错误
            resetAndShowError("GUI构建失败: " + e.getMessage());
            super.buildGUI(player);
        }
    }

    /**
     * 强制重新加载材料（用于刷新）
     */
    public void forceReload() {
        MessageUtils.logDebug("MaterialsGUI: 强制重新加载材料");
        materialsLoaded = false;
        clearPageItems();
        currentPage = 0;
    }

    /**
     * 带错误处理的材料加载
     */
    private void loadMaterialsWithErrorHandling() {
        try {
            // 清空现有数据
            clearPageItems();

            Collection<Material> allMaterials = plugin.getMaterialManager().getAllMaterials();
            MessageUtils.logDebug("MaterialsGUI: 从管理器获取到 " + allMaterials.size() + " 个材料");

            if (allMaterials.isEmpty()) {
                MessageUtils.logDebug("MaterialsGUI: 没有注册的材料，显示空提示");
                addPageItem(new EmptyMaterialsComponent());
                return;
            }

            // 转换为列表并保持注册顺序（MaterialManager使用LinkedHashMap保持顺序）
            List<Material> materialsList = new ArrayList<>(allMaterials);

            MessageUtils.logDebug("MaterialsGUI: 保持注册顺序的材料 (前5个): " +
                    materialsList.stream()
                            .limit(5)
                            .map(Material::getMaterialId)
                            .reduce((a, b) -> a + ", " + b)
                            .orElse("none"));

            // 添加材料组件（保持注册顺序）
            int successCount = 0;
            int errorCount = 0;

            for (Material material : materialsList) {
                try {
                    MaterialDisplayComponent component = new MaterialDisplayComponent(material);
                    addPageItem(component);
                    successCount++;
                } catch (Exception e) {
                    MessageUtils.logError("创建材料组件失败 (" + material.getMaterialId() + "): " + e.getMessage());
                    errorCount++;
                }
            }

            MessageUtils.logDebug("MaterialsGUI: 材料加载完成 - 成功:" + successCount + ", 失败:" + errorCount);

            // 如果所有材料都失败了，显示错误
            if (successCount == 0 && errorCount > 0) {
                addPageItem(new ErrorComponent("所有材料加载失败"));
            }

        } catch (Exception e) {
            MessageUtils.logError("加载材料列表时发生错误: " + e.getMessage());
            resetAndShowError("材料系统错误: " + e.getMessage());
        }
    }

    /**
     * 重置并显示错误
     */
    private void resetAndShowError(String errorMessage) {
        clearPageItems();
        addPageItem(new ErrorComponent(errorMessage));
        materialsLoaded = true; // 标记为已加载，避免重复尝试
        currentPage = 0;
    }

    @Override
    protected void buildExtraComponents(Player player) {
        try {
            // 返回主界面按钮
            setComponent(45, new NavigationComponent(NavigationComponent.NavigationType.BACK, getParentGUIId()));

            // 添加刷新按钮
            setComponent(46, new RefreshComponent());

            // 添加调试信息按钮（仅在调试模式下）
            if (plugin.isDebugMode()) {
                setComponent(53, new DebugInfoComponent());
            }

        } catch (Exception e) {
            MessageUtils.logError("构建额外组件时发生错误: " + e.getMessage());
        }
    }

    /**
     * 刷新组件
     */
    private class RefreshComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            return new cn.fandmc.flametech.items.builders.ItemBuilder(org.bukkit.Material.EMERALD)
                    .displayName("§a刷新材料列表")
                    .lore(
                            "§7重新加载所有材料",
                            "§7用于更新材料显示",
                            "",
                            "§e点击刷新"
                    )
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            try {
                MessageUtils.sendMessage(player, "§a正在刷新材料列表...");
                forceReload();

                // 重新打开GUI
                plugin.getServer().getScheduler().runTask(plugin, () -> {
                    try {
                        plugin.getGuiManager().openGUI(player, "materials");
                        MessageUtils.sendMessage(player, "§a材料列表已刷新！");
                    } catch (Exception e) {
                        MessageUtils.logError("刷新后重新打开GUI失败: " + e.getMessage());
                        MessageUtils.sendMessage(player, "§c刷新失败: " + e.getMessage());
                    }
                });

            } catch (Exception e) {
                MessageUtils.logError("刷新材料时发生错误: " + e.getMessage());
                MessageUtils.sendMessage(player, "§c刷新失败: " + e.getMessage());
            }
        }

        @Override
        public boolean isClickable(Player player) {
            return true;
        }
    }

    /**
     * 材料显示组件 - 增强版本
     */
    private class MaterialDisplayComponent implements GUIComponent {
        private final Material material;
        private final String materialId;
        private final String displayName;

        public MaterialDisplayComponent(Material material) {
            this.material = material;
            this.materialId = material.getMaterialId();
            this.displayName = material.getDisplayName();
        }

        @Override
        public ItemStack getDisplayItem() {
            try {
                ItemStack materialItem = material.createItem();

                if (materialItem == null) {
                    MessageUtils.logWarning("材料 " + materialId + " 创建的物品为null");
                    return createErrorItem("创建失败");
                }

                // 处理物品元数据
                if (materialItem.hasItemMeta()) {
                    ItemMeta meta = materialItem.getItemMeta();
                    List<String> lore = meta.getLore();
                    if (lore == null) {
                        lore = new ArrayList<>();
                    }

                    // 添加查看器提示
                    lore.add("");
                    lore.add("§7点击查看详细信息");

                    // 调试模式下显示ID
                    if (plugin.isDebugMode()) {
                        lore.add("§8[Debug] ID: " + materialId);
                    }

                    // 处理颜色代码
                    List<String> processedLore = new ArrayList<>();
                    for (String line : lore) {
                        processedLore.add(MessageUtils.colorize(line));
                    }

                    meta.setLore(processedLore);
                    materialItem.setItemMeta(meta);
                }

                return materialItem;

            } catch (Exception e) {
                MessageUtils.logError("创建材料 " + materialId + " 的显示物品时发生错误: " + e.getMessage());
                return createErrorItem("显示错误");
            }
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            try {
                if (event.isLeftClick()) {
                    openMaterialViewer(player);
                }

            } catch (Exception e) {
                MessageUtils.logError("处理材料点击时发生错误: " + e.getMessage());
                MessageUtils.sendMessage(player, "§c操作失败: " + e.getMessage());
            }
        }

        @Override
        public boolean isVisible(Player player) {
            return true;
        }

        @Override
        public boolean isClickable(Player player) {
            return true;
        }

        /**
         * 创建错误显示物品
         */
        private ItemStack createErrorItem(String error) {
            return new cn.fandmc.flametech.items.builders.ItemBuilder(org.bukkit.Material.BARRIER)
                    .displayName("§c" + displayName + " (错误)")
                    .lore("§7" + error, "§8ID: " + materialId)
                    .build();
        }

        /**
         * 打开材料查看器
         */
        private void openMaterialViewer(Player player) {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    MaterialViewerGUI materialViewer = new MaterialViewerGUI(plugin, material, "materials");
                    materialViewer.open(player);
                    MessageUtils.sendMessage(player, "§a正在打开材料查看器...");
                } catch (Exception e) {
                    MessageUtils.logError("打开材料查看器失败: " + e.getMessage());
                    MessageUtils.sendMessage(player, "§c打开材料查看器时发生错误");
                }
            });
        }

        /**
         * 直接打开相关配方列表
         */
        private void openRelatedRecipes(Player player) {
            plugin.getServer().getScheduler().runTask(plugin, () -> {
                try {
                    // 查找使用此材料的配方
                    List<Recipe> relatedRecipes = findRecipesUsingMaterial(material);

                    if (relatedRecipes.isEmpty()) {
                        MessageUtils.sendMessage(player, "§e该材料暂无相关配方");
                        return;
                    }

                    MaterialRelatedRecipesGUI recipesGUI = new MaterialRelatedRecipesGUI(
                            plugin, material, relatedRecipes, "materials");
                    recipesGUI.open(player);
                    MessageUtils.sendMessage(player, "§a找到 " + relatedRecipes.size() + " 个相关配方");
                } catch (Exception e) {
                    MessageUtils.logError("打开相关配方列表失败: " + e.getMessage());
                    MessageUtils.sendMessage(player, "§c打开相关配方时发生错误");
                }
            });
        }

        /**
         * 给予玩家材料
         */
        private void giveMaterialToPlayer(Player player, int amount) {
            try {
                ItemStack materialItem = material.createItem(amount);
                if (materialItem != null) {
                    Map<Integer, ItemStack> leftover = player.getInventory().addItem(materialItem);

                    if (leftover.isEmpty()) {
                        MessageUtils.sendMessage(player, "§a获得了 " + amount + " 个 " + displayName);
                    } else {
                        // 部分物品掉落
                        for (ItemStack overflow : leftover.values()) {
                            player.getWorld().dropItemNaturally(player.getLocation(), overflow);
                        }
                        int received = amount - leftover.values().stream().mapToInt(ItemStack::getAmount).sum();
                        MessageUtils.sendMessage(player, "§e获得了 " + received + " 个 " + displayName + "，剩余掉落在地上");
                    }
                } else {
                    MessageUtils.sendMessage(player, "§c无法创建材料物品");
                }
            } catch (Exception e) {
                MessageUtils.logError("给予材料失败: " + e.getMessage());
                MessageUtils.sendMessage(player, "§c给予材料时发生错误");
            }
        }

        /**
         * 查找使用指定材料的配方
         */
        private List<Recipe> findRecipesUsingMaterial(Material targetMaterial) {
            List<Recipe> usedInRecipes = new ArrayList<>();
            ItemStack materialItem = targetMaterial.createItem();

            for (Recipe recipe : plugin.getRecipeManager().getAllRecipes()) {
                Map<Integer, ItemStack> ingredients = recipe.getIngredients();
                for (ItemStack ingredient : ingredients.values()) {
                    if (ingredient != null && isSameMaterial(ingredient, materialItem)) {
                        usedInRecipes.add(recipe);
                        break; // 避免重复添加同一配方
                    }
                }
            }

            return usedInRecipes;
        }

        /**
         * 检查两个物品是否为同一材料
         */
        private boolean isSameMaterial(ItemStack item1, ItemStack item2) {
            if (item1 == null || item2 == null) return false;

            if (item1.getType() != item2.getType()) return false;

            boolean isItem1FTMaterial = plugin.getMaterialManager().isMaterial(item1);
            boolean isItem2FTMaterial = plugin.getMaterialManager().isMaterial(item2);

            if (isItem1FTMaterial && isItem2FTMaterial) {
                var material1 = plugin.getMaterialManager().getMaterialFromStack(item1);
                var material2 = plugin.getMaterialManager().getMaterialFromStack(item2);

                if (material1.isPresent() && material2.isPresent()) {
                    return material1.get().getMaterialId().equals(material2.get().getMaterialId());
                }
            } else if (!isItem1FTMaterial && !isItem2FTMaterial) {
                return item1.isSimilar(item2);
            }

            return false;
        }
    }
    /**
     * 空材料提示组件
     */
    private class EmptyMaterialsComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            return new cn.fandmc.flametech.items.builders.ItemBuilder(org.bukkit.Material.STRUCTURE_VOID)
                    .displayName("§c暂无材料")
                    .lore(
                            "§7还没有注册任何材料",
                            "§7可能原因：",
                            "§7• 材料系统未初始化",
                            "§7• 所有材料注册失败",
                            "",
                            "§7尝试点击刷新按钮重新加载",
                            "§7敬请期待后续更新！"
                    )
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            MessageUtils.sendMessage(player, "§7当前还没有可用的材料，尝试点击刷新按钮");
        }

        @Override
        public boolean isClickable(Player player) {
            return false;
        }
    }

    /**
     * 错误提示组件
     */
    private class ErrorComponent implements GUIComponent {
        private final String errorMessage;

        public ErrorComponent(String errorMessage) {
            this.errorMessage = errorMessage;
        }

        @Override
        public ItemStack getDisplayItem() {
            return new cn.fandmc.flametech.items.builders.ItemBuilder(org.bukkit.Material.BARRIER)
                    .displayName("§c系统错误")
                    .lore(
                            "§7材料系统发生错误:",
                            "§c" + errorMessage,
                            "",
                            "§7建议操作:",
                            "§7• 点击刷新按钮重试",
                            "§7• 使用 /flametech reload 重载插件",
                            "§7• 检查控制台错误日志",
                            "§7• 联系管理员检查配置"
                    )
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            MessageUtils.sendMessage(player, "§c系统错误: " + errorMessage);
            MessageUtils.sendMessage(player, "§7请尝试点击刷新按钮或重载插件");
        }

        @Override
        public boolean isClickable(Player player) {
            return false;
        }
    }

    /**
     * 调试信息组件
     */
    private class DebugInfoComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            return new cn.fandmc.flametech.items.builders.ItemBuilder(org.bukkit.Material.REDSTONE_TORCH)
                    .displayName("§c[Debug] 分页信息")
                    .lore(
                            "§7当前页: §e" + (getCurrentPage() + 1),
                            "§7总页数: §e" + getTotalPages(),
                            "§7项目数: §e" + pageItems.size(),
                            "§7每页显示: §e" + contentSlots.length,
                            "§7已加载: §e" + materialsLoaded,
                            "",
                            "§e点击输出详细调试信息"
                    )
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            MessageUtils.sendMessage(player, "§c=== MaterialsGUI 调试信息 ===");
            MessageUtils.sendMessage(player, "§7当前页: §e" + (getCurrentPage() + 1) + "§7/§e" + getTotalPages());
            MessageUtils.sendMessage(player, "§7页面项目总数: §e" + pageItems.size());
            MessageUtils.sendMessage(player, "§7每页可显示: §e" + contentSlots.length);
            MessageUtils.sendMessage(player, "§7材料已加载: §e" + materialsLoaded);

            int currentPage = getCurrentPage();
            int itemsPerPage = contentSlots.length;
            int startIndex = currentPage * itemsPerPage;
            int endIndex = Math.min(startIndex + itemsPerPage, pageItems.size());

            MessageUtils.sendMessage(player, "§7当前页显示范围: §e" + startIndex + " - " + (endIndex - 1));

            boolean hasNext = currentPage < (getTotalPages() - 1);
            boolean hasPrev = currentPage > 0;

            MessageUtils.sendMessage(player, "§7可以下一页: §e" + hasNext);
            MessageUtils.sendMessage(player, "§7可以上一页: §e" + hasPrev);
        }

        @Override
        public boolean isClickable(Player player) {
            return true;
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\main\ToolsGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.main;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.buttons.tools.*;
import cn.fandmc.flametech.gui.components.NavigationComponent;
import org.bukkit.entity.Player;

/**
 * 工具GUI
 */
public class ToolsGUI extends PaginatedGUI {

    public ToolsGUI(Main plugin) {
        super(plugin, "tools",
                plugin.getConfigManager().getLang("gui.tools.title"));
        setParentGUI("main");
    }

    @Override
    protected void buildGUI(Player player) {
        // 清空并重新构建页面项目
        clearPageItems();

        // 添加工具按钮
        addPageItem(new ExplosivePickaxeButton());
        addPageItem(new SmeltingPickaxeButton());
        addPageItem(new MagnetButton());

        // 调用父类方法构建GUI
        super.buildGUI(player);
    }

    @Override
    protected void buildExtraComponents(Player player) {
        // 添加返回按钮
        setComponent(45, new NavigationComponent(NavigationComponent.NavigationType.BACK, getParentGUIId()));
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\ItemRecipeGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.StaticComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.recipes.base.ShapedRecipe;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * 物品配方GUI
 */
public class ItemRecipeGUI extends BaseGUI {

    private final Recipe recipe;
    private final String fromMultiblock;

    private static final int[] RECIPE_SLOTS = {5, 6, 7, 14, 15, 16, 23, 24, 25};
    private static final int TYPE_SLOT = 11;
    private static final int RESULT_SLOT = 8;
    private static final int BACK_SLOT = 18;

    public ItemRecipeGUI(Main plugin, Recipe recipe, String fromMultiblock) {
        super(plugin, "item_recipe_" + recipe.getRecipeId(), 27,
                plugin.getConfigManager().getLang("gui.item_recipe.title")
                        .replace("%item%", recipe.getDisplayName()));
        this.recipe = recipe;
        this.fromMultiblock = fromMultiblock;
    }

    @Override
    protected void buildGUI(Player player) {
        clearComponents();

        // 不设置边框，让配方显示更清晰

        // 显示配方
        displayRecipe();

        // 配方类型指示器
        setComponent(TYPE_SLOT, new StaticComponent(createTypeIndicator()));

        // 结果物品
        setComponent(RESULT_SLOT, new StaticComponent(createResultItem()));

        // 返回按钮
        setComponent(BACK_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return ItemBuilder.createBackButton();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                try {
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        player.closeInventory();
                    });
                } catch (Exception e) {
                    MessageUtils.logError("Error in back button: " + e.getMessage());
                    player.closeInventory();
                }
            }
        });
    }

    private void displayRecipe() {
        if (recipe instanceof ShapedRecipe shapedRecipe) {
            displayShapedRecipe(shapedRecipe);
        } else {
            displayGenericRecipe();
        }
    }

    private void displayShapedRecipe(ShapedRecipe shaped) {
        String[] pattern = shaped.getPattern();
        Map<Character, ItemStack> ingredients = shaped.getIngredientMap();

        // 清空配方槽位
        for (int slot : RECIPE_SLOTS) {
            removeComponent(slot);
        }

        // 显示有序配方
        for (int row = 0; row < Math.min(3, pattern.length); row++) {
            for (int col = 0; col < Math.min(3, pattern[row].length()); col++) {
                char c = pattern[row].charAt(col);
                if (c != ' ' && ingredients.containsKey(c)) {
                    ItemStack ingredient = ingredients.get(c).clone();
                    addIngredientLore(ingredient);

                    int slotIndex = row * 3 + col;
                    setComponent(RECIPE_SLOTS[slotIndex], new StaticComponent(ingredient));
                }
            }
        }
    }

    private void displayGenericRecipe() {
        Map<Integer, ItemStack> ingredients = recipe.getIngredients();

        for (Map.Entry<Integer, ItemStack> entry : ingredients.entrySet()) {
            int slot = entry.getKey();
            ItemStack ingredient = entry.getValue().clone();

            if (slot < RECIPE_SLOTS.length) {
                addIngredientLore(ingredient);
                setComponent(RECIPE_SLOTS[slot], new StaticComponent(ingredient));
            }
        }
    }

    private void addIngredientLore(ItemStack ingredient) {
        if (ingredient != null && ingredient.hasItemMeta()) {
            ItemMeta meta = ingredient.getItemMeta();
            List<String> lore = meta.getLore();
            if (lore == null) lore = new ArrayList<>();

            lore.add("");
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_INGREDIENT_AMOUNT,
                    "%amount%", String.valueOf(ingredient.getAmount())));

            meta.setLore(lore);
            ingredient.setItemMeta(meta);
        }
    }

    private ItemStack createTypeIndicator() {
        // 获取多方块结构的显示名称
        String multiblockDisplayName = getMultiblockDisplayName(fromMultiblock);

        return new ItemBuilder(Material.CRAFTING_TABLE)
                .displayName(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_TYPE_INDICATOR_NAME))
                .lore(
                        plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_TYPE_INDICATOR_TYPE,
                                "%type%", recipe.getType().getDisplayName()),
                        plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_TYPE_INDICATOR_SOURCE,
                                "%source%", multiblockDisplayName),
                        "",
                        plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_TYPE_INDICATOR_USAGE_LINE1),
                        plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_TYPE_INDICATOR_USAGE_LINE2)
                )
                .build();
    }

    /**
     * 获取多方块结构的显示名称
     */
    private String getMultiblockDisplayName(String multiblockId) {
        try {
            // 首先尝试从语言配置获取
            String langKey = "multiblock." + multiblockId + ".name";
            String displayName = plugin.getConfigManager().getLang(langKey);

            // 如果配置中没有，尝试从结构管理器获取
            if (displayName.contains("未找到语言键")) {
                Optional<MultiblockStructure> structureOpt = plugin.getMultiblockManager().getStructure(multiblockId);
                if (structureOpt.isPresent()) {
                    return structureOpt.get().getDisplayName();
                }

                // 如果都没有，返回格式化的ID
                return formatMultiblockId(multiblockId);
            }

            return displayName;
        } catch (Exception e) {
            MessageUtils.logError("Error getting multiblock display name: " + e.getMessage());
            return formatMultiblockId(multiblockId);
        }
    }

    /**
     * 格式化多方块ID为可读名称
     */
    private String formatMultiblockId(String multiblockId) {
        if (multiblockId == null || multiblockId.isEmpty()) {
            return plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_UNKNOWN_STRUCTURE);
        }

        // 移除前缀并格式化
        String formatted = multiblockId.replace("enhanced_crafting_table",
                        plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_ENHANCED_CRAFTING_TABLE))
                .replace("_", " ");

        // 首字母大写
        if (!formatted.isEmpty()) {
            formatted = formatted.substring(0, 1).toUpperCase() + formatted.substring(1);
        }

        return formatted;
    }

    private ItemStack createResultItem() {
        ItemStack resultItem = recipe.getResult().clone();
        if (resultItem.hasItemMeta()) {
            ItemMeta meta = resultItem.getItemMeta();
            List<String> lore = meta.getLore();
            if (lore == null) lore = new ArrayList<>();

            lore.add("");
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_RESULT_TITLE));
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_RESULT_AMOUNT,
                    "%amount%", String.valueOf(resultItem.getAmount())));
            lore.add("");
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_RESULT_INSTRUCTION_LINE1));
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_ITEM_RECIPE_RESULT_INSTRUCTION_LINE2,
                    "%machine%", getMultiblockDisplayName(fromMultiblock)));

            meta.setLore(lore);
            resultItem.setItemMeta(meta);
        }
        return resultItem;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\MaterialRelatedRecipesGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.unlock.data.UnlockResult;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;

/**
 * 材料相关配方列表GUI - 显示使用指定材料的所有配方
 */
public class MaterialRelatedRecipesGUI extends PaginatedGUI {

    private final Material material;
    private final List<Recipe> relatedRecipes;

    public MaterialRelatedRecipesGUI(Main plugin, Material material, List<Recipe> relatedRecipes, String parentGUIId) {
        super(plugin, "material_related_recipes_" + material.getMaterialId(),
                plugin.getConfigManager().getLang("gui.material_related_recipes.title")
                        .replace("%material%", material.getDisplayName())
                        .replace("%count%", String.valueOf(relatedRecipes.size())));

        this.material = material;
        this.relatedRecipes = new ArrayList<>(relatedRecipes);
        setParentGUI(parentGUIId);
    }

    @Override
    protected void buildGUI(Player player) {
        // 清空并重新构建页面项目
        clearPageItems();

        // 添加所有相关配方
        for (Recipe recipe : relatedRecipes) {
            addPageItem(new RelatedRecipeComponent(recipe, player));
        }

        // 调用父类方法构建GUI
        super.buildGUI(player);
    }

    @Override
    protected void buildExtraComponents(Player player) {
        // 返回按钮
        if (getParentGUIId() != null) {
            setComponent(45, new GUIComponent() {
                @Override
                public ItemStack getDisplayItem() {
                    return ItemBuilder.createBackButton();
                }

                @Override
                public void onClick(Player player, InventoryClickEvent event) {
                    try {
                        plugin.getServer().getScheduler().runTask(plugin, () -> {
                            plugin.getGuiManager().openGUI(player, getParentGUIId());
                        });
                    } catch (Exception e) {
                        MessageUtils.logError("Error in back button: " + e.getMessage());
                        player.closeInventory();
                    }
                }
            });
        }

        // 材料信息按钮
        setComponent(46, new MaterialInfoComponent());
    }

    /**
     * 相关配方组件
     */
    private class RelatedRecipeComponent implements GUIComponent {
        private final Recipe recipe;
        private final Player player;

        public RelatedRecipeComponent(Recipe recipe, Player player) {
            this.recipe = recipe;
            this.player = player;
        }

        @Override
        public ItemStack getDisplayItem() {
            String recipeUnlockId = "recipe." + recipe.getRecipeId();
            boolean isUnlocked = plugin.getUnlockManager().isUnlocked(player, recipeUnlockId);

            if (!isUnlocked) {
                // 未解锁状态
                int requiredExp = plugin.getUnlockManager().getRequiredExp(recipeUnlockId);

                String displayName = plugin.getConfigManager().getLang("gui.material_related_recipes.recipe_locked_name")
                        .replace("%recipe%", recipe.getDisplayName());

                List<String> lore = new ArrayList<>();
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.recipe_locked_lore_exp")
                        .replace("%required%", String.valueOf(requiredExp)));
                lore.add("");

                // 显示材料在配方中的用途
                addMaterialUsageInfo(lore);

                lore.add("");
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.recipe_locked_lore_click"));

                return new ItemBuilder(org.bukkit.Material.BARRIER)
                        .displayName(displayName)
                        .lore(lore)
                        .build();
            } else {
                // 已解锁状态
                ItemStack display = recipe.getResult().clone();
                if (display.hasItemMeta()) {
                    var meta = display.getItemMeta();
                    var lore = meta.getLore();
                    if (lore == null) lore = new ArrayList<>();

                    lore.add("");
                    lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.recipe_type",
                            "%type%", recipe.getType().getDisplayName()));

                    // 显示材料在配方中的用途
                    addMaterialUsageInfo(lore);

                    lore.add("");
                    lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.click_view_recipe"));

                    meta.setLore(lore);
                    display.setItemMeta(meta);
                }
                return display;
            }
        }

        /**
         * 添加材料在配方中的用途信息
         */
        private void addMaterialUsageInfo(List<String> lore) {
            ItemStack materialItem = material.createItem();
            int totalUsed = 0;

            // 计算配方中使用的材料总数
            for (ItemStack ingredient : recipe.getIngredients().values()) {
                if (ingredient != null && isSameMaterial(ingredient, materialItem)) {
                    totalUsed += ingredient.getAmount();
                }
            }

            if (totalUsed > 0) {
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.material_usage",
                        "%material%", material.getDisplayName(),
                        "%amount%", String.valueOf(totalUsed)));
            }
        }

        /**
         * 检查两个物品是否为同一材料
         */
        private boolean isSameMaterial(ItemStack item1, ItemStack item2) {
            if (item1 == null || item2 == null) return false;

            if (item1.getType() != item2.getType()) return false;

            boolean isItem1FTMaterial = plugin.getMaterialManager().isMaterial(item1);
            boolean isItem2FTMaterial = plugin.getMaterialManager().isMaterial(item2);

            if (isItem1FTMaterial && isItem2FTMaterial) {
                var material1 = plugin.getMaterialManager().getMaterialFromStack(item1);
                var material2 = plugin.getMaterialManager().getMaterialFromStack(item2);

                if (material1.isPresent() && material2.isPresent()) {
                    return material1.get().getMaterialId().equals(material2.get().getMaterialId());
                }
            } else if (!isItem1FTMaterial && !isItem2FTMaterial) {
                return item1.isSimilar(item2);
            }

            return false;
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            try {
                String recipeUnlockId = "recipe." + recipe.getRecipeId();

                if (!plugin.getUnlockManager().isUnlocked(player, recipeUnlockId)) {
                    // 尝试解锁配方
                    UnlockResult result = plugin.getUnlockManager().unlock(player, recipeUnlockId);

                    if (result.isSuccess()) {
                        MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_SUCCESS,
                                "%item%", recipe.getDisplayName());

                        // 刷新界面
                        plugin.getServer().getScheduler().runTask(plugin, () -> {
                            MaterialRelatedRecipesGUI.this.open(player);
                        });
                    } else {
                        handleUnlockFailure(player, result);
                    }
                } else {
                    // 已解锁，打开配方详情
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        try {
                            ItemRecipeGUI recipeGUI = new ItemRecipeGUI(plugin, recipe, recipe.getMultiblockId());
                            recipeGUI.open(player);
                        } catch (Exception e) {
                            MessageUtils.logError("Failed to open recipe GUI: " + e.getMessage());
                            MessageUtils.sendMessage(player,
                                    plugin.getConfigManager().getLang("gui.material_related_recipes.error_open_recipe"));
                        }
                    });
                }
            } catch (Exception e) {
                MessageUtils.logError("Error in RelatedRecipeComponent onClick: " + e.getMessage());
                MessageUtils.sendMessage(player,
                        plugin.getConfigManager().getLang("gui.material_related_recipes.error_click_event"));
            }
        }

        /**
         * 处理解锁失败的情况
         */
        private void handleUnlockFailure(Player player, UnlockResult result) {
            switch (result.getStatus()) {
                case INSUFFICIENT_EXP:
                    MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_INSUFFICIENT_EXP,
                            "%required%", String.valueOf(result.getRequiredExp()));
                    break;
                case ALREADY_UNLOCKED:
                    MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_ALREADY_UNLOCKED);
                    break;
                default:
                    MessageUtils.sendMessage(player,
                            plugin.getConfigManager().getLang("gui.material_related_recipes.unlock_failed_default")
                                    .replace("%message%", result.getMessage()));
                    break;
            }
        }
    }

    /**
     * 材料信息组件
     */
    private class MaterialInfoComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            ItemStack materialItem = material.createItem();

            if (materialItem.hasItemMeta()) {
                var meta = materialItem.getItemMeta();
                List<String> lore = meta.getLore();
                if (lore == null) lore = new ArrayList<>();

                lore.add("");
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.material_info.title"));
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.material_info.id",
                        "%id%", material.getMaterialId()));
                lore.add(plugin.getConfigManager().getLang("gui.material_related_recipes.material_info.usage_count",
                        "%count%", String.valueOf(relatedRecipes.size())));

                meta.setLore(lore);
                materialItem.setItemMeta(meta);
            }

            return materialItem;
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            // 材料信息不可点击，或者可以实现切换回材料查看器
            try {
                plugin.getServer().getScheduler().runTask(plugin, () -> {
                    MaterialViewerGUI materialViewer = new MaterialViewerGUI(plugin, material, "materials");
                    materialViewer.open(player);
                });
            } catch (Exception e) {
                MessageUtils.logError("Error switching back to material viewer: " + e.getMessage());
            }
        }

        @Override
        public boolean isClickable(Player player) {
            return true;
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\MaterialViewerGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.StaticComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * 材料查看器GUI - 显示材料信息和相关配方
 */
public class MaterialViewerGUI extends BaseGUI {

    private final Material material;
    private final String fromGUI;

    // 界面布局槽位
    private static final int MATERIAL_INFO_SLOT = 11;
    private static final int MATERIAL_DISPLAY_SLOT = 13;
    private static final int RELATED_RECIPES_SLOT = 15;
    private static final int BACK_SLOT = 45;

    public MaterialViewerGUI(Main plugin, Material material, String fromGUI) {
        super(plugin, "material_viewer_" + material.getMaterialId(), 54,
                plugin.getConfigManager().getLang("gui.material_viewer.title")
                        .replace("%material%", material.getDisplayName()));
        this.material = material;
        this.fromGUI = fromGUI != null ? fromGUI : "materials";
        setParentGUI(fromGUI);
    }

    @Override
    protected void buildGUI(Player player) {
        clearComponents();

        // 设置边框
        setupBorder();

        // 材料信息面板
        setComponent(MATERIAL_INFO_SLOT, new StaticComponent(createMaterialInfoPanel()));

        // 材料展示
        setComponent(MATERIAL_DISPLAY_SLOT, new StaticComponent(createMaterialDisplay()));

        // 相关配方按钮
        setComponent(RELATED_RECIPES_SLOT, new RelatedRecipesComponent());

        // 返回按钮
        setComponent(BACK_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return ItemBuilder.createBackButton();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                try {
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        if (getParentGUIId() != null) {
                            plugin.getGuiManager().openGUI(player, getParentGUIId());
                        } else {
                            player.closeInventory();
                        }
                    });
                } catch (Exception e) {
                    MessageUtils.logError("Error in back button: " + e.getMessage());
                    player.closeInventory();
                }
            }
        });
    }

    /**
     * 设置边框
     */
    private void setupBorder() {
        ItemStack borderItem = ItemBuilder.createBorderItem();
        StaticComponent borderComponent = new StaticComponent(borderItem);

        // 顶部和底部边框
        for (int i = 0; i < 9; i++) {
            setComponent(i, borderComponent);
            setComponent(45 + i, borderComponent);
        }

        // 侧边边框
        setComponent(9, borderComponent);
        setComponent(17, borderComponent);
        setComponent(18, borderComponent);
        setComponent(26, borderComponent);
        setComponent(27, borderComponent);
        setComponent(35, borderComponent);
        setComponent(36, borderComponent);
        setComponent(44, borderComponent);
    }

    /**
     * 创建材料信息面板
     */
    private ItemStack createMaterialInfoPanel() {
        List<String> lore = new ArrayList<>();

        // 基础信息
        lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.category") + getFormattedCategory());
        lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.id") + material.getMaterialId());
        lore.add("");

        // 获取制作方式
        List<Recipe> sourceRecipes = findSourceRecipes();
        if (!sourceRecipes.isEmpty()) {
            lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.created_by"));
            for (Recipe recipe : sourceRecipes) {
                lore.add("  §7• §e" + recipe.getDisplayName());
            }
        } else {
            lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.no_source_recipes"));
        }

        lore.add("");

        // 用途统计
        List<Recipe> usedInRecipes = findRecipesUsingMaterial();
        lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.used_in_count",
                "%count%", String.valueOf(usedInRecipes.size())));

        lore.add("");
        lore.add(plugin.getConfigManager().getLang("gui.material_viewer.info.view_recipes_hint"));

        return new ItemBuilder(org.bukkit.Material.BOOK)
                .displayName(plugin.getConfigManager().getLang("gui.material_viewer.info.title"))
                .lore(lore)
                .build();
    }

    /**
     * 创建材料展示物品
     */
    private ItemStack createMaterialDisplay() {
        ItemStack materialItem = material.createItem();

        if (materialItem.hasItemMeta()) {
            var meta = materialItem.getItemMeta();
            List<String> lore = meta.getLore();
            if (lore == null) lore = new ArrayList<>();

            // 添加查看器特有的信息
            lore.add("");
            lore.add(plugin.getConfigManager().getLang("gui.material_viewer.display.material_info"));
            lore.add(plugin.getConfigManager().getLang("gui.material_viewer.display.category",
                    "%category%", getFormattedCategory()));

            meta.setLore(lore);
            materialItem.setItemMeta(meta);
        }

        return materialItem;
    }

    /**
     * 获取格式化的材料类别
     */
    private String getFormattedCategory() {
        String materialId = material.getMaterialId();
        String category = determineMaterialCategory(materialId);

        return switch (category) {
            case "dusts" -> "§7粉末";
            case "ingots" -> "§f锭类";
            case "alloys" -> "§6合金";
            case "gems" -> "§b宝石";
            case "processed" -> "§e加工品";
            case "raw_materials" -> "§8原材料";
            default -> "§7其他";
        };
    }

    /**
     * 确定材料类别
     */
    private String determineMaterialCategory(String materialId) {
        if (materialId.contains("dust")) return "dusts";
        if (materialId.contains("ingot")) return "ingots";
        if (materialId.contains("artificial")) return "gems";
        if (materialId.equals("ore_dust")) return "raw_materials";
        if (materialId.contains("silicon")) return "processed";
        if (materialId.contains("bronze")) return "alloys";
        return "other";
    }

    /**
     * 查找制作此材料的配方
     */
    private List<Recipe> findSourceRecipes() {
        List<Recipe> sourceRecipes = new ArrayList<>();
        ItemStack materialItem = material.createItem();

        for (Recipe recipe : plugin.getRecipeManager().getAllRecipes()) {
            ItemStack result = recipe.getResult();
            if (result != null && isSameMaterial(result, materialItem)) {
                sourceRecipes.add(recipe);
            }
        }

        return sourceRecipes;
    }

    /**
     * 查找使用此材料的配方
     */
    private List<Recipe> findRecipesUsingMaterial() {
        List<Recipe> usedInRecipes = new ArrayList<>();
        ItemStack materialItem = material.createItem();

        for (Recipe recipe : plugin.getRecipeManager().getAllRecipes()) {
            Map<Integer, ItemStack> ingredients = recipe.getIngredients();
            for (ItemStack ingredient : ingredients.values()) {
                if (ingredient != null && isSameMaterial(ingredient, materialItem)) {
                    usedInRecipes.add(recipe);
                    break; // 避免重复添加同一配方
                }
            }
        }

        return usedInRecipes;
    }

    /**
     * 检查两个物品是否为同一材料（忽略数量）
     */
    private boolean isSameMaterial(ItemStack item1, ItemStack item2) {
        if (item1 == null || item2 == null) return false;

        // 基础类型检查
        if (item1.getType() != item2.getType()) return false;

        // 检查是否都是FlameTech材料
        boolean isItem1FTMaterial = plugin.getMaterialManager().isMaterial(item1);
        boolean isItem2FTMaterial = plugin.getMaterialManager().isMaterial(item2);

        if (isItem1FTMaterial && isItem2FTMaterial) {
            // 都是FT材料，通过材料ID比较
            var material1 = plugin.getMaterialManager().getMaterialFromStack(item1);
            var material2 = plugin.getMaterialManager().getMaterialFromStack(item2);

            if (material1.isPresent() && material2.isPresent()) {
                return material1.get().getMaterialId().equals(material2.get().getMaterialId());
            }
        } else if (!isItem1FTMaterial && !isItem2FTMaterial) {
            // 都是原版材料，通过类型和NBT比较
            return item1.isSimilar(item2);
        }

        return false;
    }

    /**
     * 相关配方组件
     */
    private class RelatedRecipesComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            List<Recipe> relatedRecipes = findRecipesUsingMaterial();

            List<String> lore = new ArrayList<>();
            lore.add(plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.description"));
            lore.add("");

            if (relatedRecipes.isEmpty()) {
                lore.add(plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.no_recipes"));
            } else {
                lore.add(plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.count",
                        "%count%", String.valueOf(relatedRecipes.size())));
                lore.add("");

                // 显示前几个配方名称
                int maxDisplay = Math.min(5, relatedRecipes.size());
                for (int i = 0; i < maxDisplay; i++) {
                    lore.add("§7• §e" + relatedRecipes.get(i).getDisplayName());
                }

                if (relatedRecipes.size() > maxDisplay) {
                    lore.add("§7• §6... 还有 " + (relatedRecipes.size() - maxDisplay) + " 个配方");
                }
            }

            lore.add("");
            if (!relatedRecipes.isEmpty()) {
                lore.add(plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.click_to_view"));
            }

            org.bukkit.Material iconMaterial = relatedRecipes.isEmpty() ?
                    org.bukkit.Material.BARRIER : org.bukkit.Material.CRAFTING_TABLE;

            return new ItemBuilder(iconMaterial)
                    .displayName(plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.title"))
                    .lore(lore)
                    .glow(!relatedRecipes.isEmpty())
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            List<Recipe> relatedRecipes = findRecipesUsingMaterial();

            if (relatedRecipes.isEmpty()) {
                MessageUtils.sendMessage(player,
                        plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.no_recipes_message"));
                return;
            }

            try {
                plugin.getServer().getScheduler().runTask(plugin, () -> {
                    try {
                        MaterialRelatedRecipesGUI recipesGUI = new MaterialRelatedRecipesGUI(
                                plugin, material, relatedRecipes, getGuiId());
                        recipesGUI.open(player);
                    } catch (Exception e) {
                        MessageUtils.logError("Failed to open material related recipes GUI: " + e.getMessage());
                        MessageUtils.sendMessage(player,
                                plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.open_error"));
                    }
                });
            } catch (Exception e) {
                MessageUtils.logError("Error in related recipes button: " + e.getMessage());
                MessageUtils.sendMessage(player,
                        plugin.getConfigManager().getLang("gui.material_viewer.related_recipes.open_error"));
            }
        }

        @Override
        public boolean isClickable(Player player) {
            return !findRecipesUsingMaterial().isEmpty();
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\RecipeViewerGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.StaticComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * 配方查看器GUI
 */
public class RecipeViewerGUI extends BaseGUI {

    private final String multiblockId;
    private static final Map<String, RecipeViewerGUI> instances = new HashMap<>();

    private static final int STRUCTURE_INFO_SLOT = 10;
    private static final int VIEW_RECIPES_SLOT = 16;
    private static final int BACK_SLOT = 22;

    private RecipeViewerGUI(Main plugin, String multiblockId) {
        super(plugin, "recipe_viewer_" + multiblockId, 27,
                plugin.getConfigManager().getLang("gui.recipe_viewer.title")
                        .replace("%machine%", getMultiblockDisplayName(plugin, multiblockId)));
        this.multiblockId = multiblockId;
        setParentGUI("basic_machines");
    }

    private static String getMultiblockDisplayName(Main plugin, String multiblockId) {
        // 尝试从配置获取显示名称
        String langKey = "multiblock." + multiblockId + ".name";
        String displayName = plugin.getConfigManager().getLang(langKey);

        // 如果没有找到配置，尝试从结构获取
        if (displayName.contains(plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_LANGUAGE_KEY_NOT_FOUND))) {
            Optional<MultiblockStructure> structureOpt = plugin.getMultiblockManager().getStructure(multiblockId);
            if (structureOpt.isPresent()) {
                return structureOpt.get().getDisplayName();
            }
        }

        return displayName;
    }

    public static RecipeViewerGUI getInstance(Main plugin, String multiblockId) {
        return instances.computeIfAbsent(multiblockId, k -> {
            RecipeViewerGUI gui = new RecipeViewerGUI(plugin, multiblockId);
            plugin.getGuiManager().registerGUI(gui);
            return gui;
        });
    }

    @Override
    protected void buildGUI(Player player) {
        clearComponents();

        // 设置边框
        setupBorder();

        // 结构信息（可点击）
        setComponent(STRUCTURE_INFO_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return createStructureInfo();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                try {
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        try {
                            Optional<MultiblockStructure> structureOpt = plugin.getMultiblockManager().getStructure(multiblockId);
                            if (structureOpt.isPresent()) {
                                StructureLayoutGUI layoutGUI = new StructureLayoutGUI(plugin, structureOpt.get(), multiblockId);
                                layoutGUI.open(player);
                            } else {
                                MessageUtils.sendMessage(player, plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_STRUCTURE_NOT_FOUND));
                            }
                        } catch (Exception e) {
                            MessageUtils.logError("Failed to open structure layout GUI: " + e.getMessage());
                            MessageUtils.sendMessage(player, plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_STRUCTURE_LAYOUT_ERROR));
                        }
                    });
                } catch (Exception e) {
                    MessageUtils.logError("Error in structure info button: " + e.getMessage());
                    MessageUtils.sendMessage(player, plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_OPERATION_FAILED));
                }
            }
        });

        // 查看配方按钮
        setComponent(VIEW_RECIPES_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return new ItemBuilder(Material.CRAFTING_TABLE)
                        .displayName(plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_VIEW_RECIPES_NAME))
                        .lore(plugin.getConfigManager().getStringList(Messages.GUI_RECIPE_VIEWER_VIEW_RECIPES_LORE))
                        .build();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                try {
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        try {
                            StructureRecipesGUI recipesGUI = StructureRecipesGUI.getInstance(plugin, multiblockId);
                            recipesGUI.setParentGUI("recipe_viewer_" + multiblockId);
                            recipesGUI.open(player);
                        } catch (Exception e) {
                            MessageUtils.logError("Failed to open structure recipes GUI: " + e.getMessage());
                            MessageUtils.sendMessage(player, plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_RECIPES_LIST_ERROR));
                        }
                    });
                } catch (Exception e) {
                    MessageUtils.logError("Error in view recipes button: " + e.getMessage());
                    MessageUtils.sendMessage(player, plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_OPERATION_FAILED));
                }
            }
        });

        // 返回按钮
        if (getParentGUIId() != null) {
            setComponent(BACK_SLOT, new GUIComponent() {
                @Override
                public ItemStack getDisplayItem() {
                    return ItemBuilder.createBackButton();
                }

                @Override
                public void onClick(Player player, InventoryClickEvent event) {
                    try {
                        plugin.getServer().getScheduler().runTask(plugin, () -> {
                            plugin.getGuiManager().openGUI(player, getParentGUIId());
                        });
                    } catch (Exception e) {
                        MessageUtils.logError("Error in back button: " + e.getMessage());
                        player.closeInventory();
                    }
                }
            });
        }
    }

    private void setupBorder() {
        ItemStack borderItem = ItemBuilder.createBorderItem();
        StaticComponent borderComponent = new StaticComponent(borderItem);

        // 顶部和底部边框
        for (int i = 0; i < 9; i++) {
            setComponent(i, borderComponent);
            setComponent(18 + i, borderComponent);
        }

        // 侧边边框
        setComponent(9, borderComponent);
        setComponent(17, borderComponent);
    }

    private ItemStack createStructureInfo() {
        Optional<MultiblockStructure> structureOpt = plugin.getMultiblockManager().getStructure(multiblockId);

        if (structureOpt.isEmpty()) {
            List<String> failedLore = plugin.getConfigManager().getStringList(Messages.GUI_RECIPE_VIEWER_STRUCTURE_LOAD_FAILED_LORE);
            // 替换参数
            for (int i = 0; i < failedLore.size(); i++) {
                failedLore.set(i, failedLore.get(i).replace("%id%", multiblockId));
            }

            return new ItemBuilder(Material.BARRIER)
                    .displayName(plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_STRUCTURE_LOAD_FAILED))
                    .lore(failedLore)
                    .build();
        }

        MultiblockStructure structure = structureOpt.get();
        String displayName = getMultiblockDisplayName(plugin, multiblockId);

        // 获取结构信息lore并替换参数
        List<String> structureLore = plugin.getConfigManager().getStringList(Messages.GUI_RECIPE_VIEWER_STRUCTURE_INFO_LORE);
        for (int i = 0; i < structureLore.size(); i++) {
            String line = structureLore.get(i);
            line = line.replace("%name%", displayName);
            line = line.replace("%blocks%", String.valueOf(structure.getBlockCount()));
            line = line.replace("%dimensions%",
                    structure.getBoundingBox().getWidth() + "x" +
                            structure.getBoundingBox().getHeight() + "x" +
                            structure.getBoundingBox().getDepth());
            structureLore.set(i, line);
        }

        return new ItemBuilder(Material.STRUCTURE_BLOCK)
                .displayName(plugin.getConfigManager().getLang(Messages.GUI_RECIPE_VIEWER_STRUCTURE_INFO_NAME))
                .lore(structureLore)
                .glow()
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\StructureLayoutGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.gui.components.StaticComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.*;

/**
 * 结构布局展示GUI
 */
public class StructureLayoutGUI extends BaseGUI {

    private final MultiblockStructure structure;
    private final String multiblockId;
    private int currentLayer = 0;
    private final Map<Integer, Map<BlockOffset, Material>> layerStructure;
    private final int minY, maxY;

    private static final int[] DISPLAY_SLOTS = {
            10, 11, 12, 13, 14, 15, 16,
            19, 20, 21, 22, 23, 24, 25,
            28, 29, 30, 31, 32, 33, 34
    };

    private static final int LAYER_UP_SLOT = 8;
    private static final int LAYER_INFO_SLOT = 17;
    private static final int LAYER_DOWN_SLOT = 26;
    private static final int BACK_SLOT = 45;
    private static final int INFO_SLOT = 53;

    public StructureLayoutGUI(Main plugin, MultiblockStructure structure, String multiblockId) {
        super(plugin, "structure_layout_" + multiblockId, 54,
                plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_TITLE,
                        "%name%", structure.getDisplayName()));
        this.structure = structure;
        this.multiblockId = multiblockId;

        // 按层级组织结构
        this.layerStructure = organizeByLayers();

        // 计算Y轴范围
        MultiblockStructure.BoundingBox bbox = structure.getBoundingBox();
        this.minY = bbox.getMinY();
        this.maxY = bbox.getMaxY();

        // 从最底层开始显示
        this.currentLayer = minY;

        setParentGUI("recipe_viewer_" + multiblockId);
    }

    private Map<Integer, Map<BlockOffset, Material>> organizeByLayers() {
        Map<Integer, Map<BlockOffset, Material>> layers = new TreeMap<>();
        Map<BlockOffset, Material> structureBlocks = structure.getStructure();

        if (structureBlocks.isEmpty()) {
            // 如果结构为空，创建一个默认层
            Map<BlockOffset, Material> defaultLayer = new HashMap<>();
            defaultLayer.put(new BlockOffset(0, 0, 0), Material.BEDROCK);
            layers.put(0, defaultLayer);
            return layers;
        }

        for (Map.Entry<BlockOffset, Material> entry : structureBlocks.entrySet()) {
            BlockOffset offset = entry.getKey();
            Material material = entry.getValue();
            int y = offset.getY();

            layers.computeIfAbsent(y, k -> new HashMap<>()).put(offset, material);
        }

        return layers;
    }

    @Override
    protected void buildGUI(Player player) {
        clearComponents();

        // 设置边框
        setupBorder();

        // 显示当前层级
        displayCurrentLayer();

        // 设置控制按钮
        setupControlButtons();

        // 显示信息
        setupInfoDisplay();
    }

    private void setupBorder() {
        ItemStack borderItem = ItemBuilder.createBorderItem();
        StaticComponent borderComponent = new StaticComponent(borderItem);

        // 顶部和底部边框
        for (int i = 0; i < 9; i++) {
            setComponent(i, borderComponent);
            setComponent(45 + i, borderComponent);
        }

        // 侧边边框（避开显示区域）
        setComponent(9, borderComponent);
        setComponent(18, borderComponent);
        setComponent(27, borderComponent);
        setComponent(36, borderComponent);
    }

    private void displayCurrentLayer() {
        // 清空显示区域
        for (int slot : DISPLAY_SLOTS) {
            removeComponent(slot);
        }

        Map<BlockOffset, Material> currentLayerBlocks = layerStructure.get(currentLayer);
        if (currentLayerBlocks == null || currentLayerBlocks.isEmpty()) {
            // 显示空层级提示
            List<String> emptyLore = new ArrayList<>(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_EMPTY_LAYER_LORE));
            for (int i = 0; i < emptyLore.size(); i++) {
                emptyLore.set(i, emptyLore.get(i).replace("%layer%", String.valueOf(currentLayer)));
            }

            setComponent(22, new StaticComponent(
                    new ItemBuilder(Material.LIGHT_GRAY_STAINED_GLASS)
                            .displayName(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_EMPTY_LAYER_NAME))
                            .lore(emptyLore)
                            .build()
            ));
            return;
        }

        // 计算显示区域的边界（7x3网格）
        int centerX = 3; // 显示区域中心X
        int centerZ = 1; // 显示区域中心Z

        // 找到当前层的方块范围
        int minX = currentLayerBlocks.keySet().stream().mapToInt(BlockOffset::getX).min().orElse(0);
        int maxX = currentLayerBlocks.keySet().stream().mapToInt(BlockOffset::getX).max().orElse(0);
        int minZ = currentLayerBlocks.keySet().stream().mapToInt(BlockOffset::getZ).min().orElse(0);
        int maxZ = currentLayerBlocks.keySet().stream().mapToInt(BlockOffset::getZ).max().orElse(0);

        // 如果结构太大，显示警告
        if ((maxX - minX) > 6 || (maxZ - minZ) > 2) {
            List<String> oversizedLore = new ArrayList<>(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_OVERSIZED_LORE));
            for (int i = 0; i < oversizedLore.size(); i++) {
                String line = oversizedLore.get(i);
                line = line.replace("%size%", (maxX - minX + 1) + "x" + (maxZ - minZ + 1));
                oversizedLore.set(i, line);
            }

            setComponent(13, new StaticComponent(
                    new ItemBuilder(Material.YELLOW_STAINED_GLASS)
                            .displayName(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_OVERSIZED_NAME))
                            .lore(oversizedLore)
                            .build()
            ));
        }

        // 显示方块
        for (Map.Entry<BlockOffset, Material> entry : currentLayerBlocks.entrySet()) {
            BlockOffset offset = entry.getKey();
            Material material = entry.getValue();

            // 计算在显示网格中的位置
            int displayX = offset.getX() - minX + centerX - (maxX - minX) / 2;
            int displayZ = offset.getZ() - minZ + centerZ - (maxZ - minZ) / 2;

            // 检查是否在显示范围内
            if (displayX >= 0 && displayX < 7 && displayZ >= 0 && displayZ < 3) {
                int slotIndex = displayZ * 7 + displayX;
                if (slotIndex < DISPLAY_SLOTS.length) {
                    int slot = DISPLAY_SLOTS[slotIndex];

                    ItemStack displayItem = createBlockDisplayItem(material, offset);
                    setComponent(slot, new StaticComponent(displayItem));
                }
            }
        }

        // 在空槽位显示占位符，帮助理解布局
        for (int i = 0; i < DISPLAY_SLOTS.length; i++) {
            int slot = DISPLAY_SLOTS[i];
            if (!components.containsKey(slot)) {
                // 显示透明占位符
                setComponent(slot, new StaticComponent(
                        new ItemBuilder(Material.LIGHT_GRAY_STAINED_GLASS_PANE)
                                .displayName(" ")
                                .build()
                ));
            }
        }
    }

    private ItemStack createBlockDisplayItem(Material material, BlockOffset offset) {
        String displayName;
        List<String> lore = new ArrayList<>();

        // 处理特殊方块（不能作为物品的方块）
        Material displayMaterial = getDisplayMaterial(material);

        // 根据材料类型设置显示名称和lore
        switch (material) {
            case FIRE:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.fire_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.fire_lore"));
                break;
            case CRAFTING_TABLE:
                displayName = plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_CRAFTING_TABLE_NAME);
                lore.addAll(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_CRAFTING_TABLE_LORE));
                break;
            case DISPENSER:
                displayName = plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_DISPENSER_NAME);
                lore.addAll(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_DISPENSER_LORE));
                break;
            case NETHER_BRICK_FENCE:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.nether_brick_fence_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.nether_brick_fence_lore"));
                break;
            case OAK_TRAPDOOR:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.oak_trapdoor_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.oak_trapdoor_lore"));
                break;
            case CAULDRON:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.cauldron_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.cauldron_lore"));
                break;
            case OAK_FENCE:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.oak_fence_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.oak_fence_lore"));
                break;
            case PISTON:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.piston_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.piston_lore"));
                break;
            case SMOOTH_STONE:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.smooth_stone_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.smooth_stone_lore"));
                break;
            case GLASS:
                displayName = plugin.getConfigManager().getLang("gui.structure_layout.block.glass_name");
                lore.addAll(plugin.getConfigManager().getStringList("gui.structure_layout.block.glass_lore"));
                break;
            default:
                displayName = plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_GENERIC_NAME,
                        "%material%", formatMaterialName(material));
                lore.addAll(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_GENERIC_LORE));
        }

        lore.add("");
        lore.add(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_COORDINATES,
                "%x%", String.valueOf(offset.getX()),
                "%y%", String.valueOf(offset.getY()),
                "%z%", String.valueOf(offset.getZ())));

        // 如果是主方块（原点），特别标记
        if (offset.getX() == 0 && offset.getY() == 0 && offset.getZ() == 0) {
            lore.add(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_BLOCK_MAIN_MARKER));
        }

        return new ItemBuilder(displayMaterial)
                .displayName(displayName)
                .lore(lore)
                .build();
    }

    private Material getDisplayMaterial(Material originalMaterial) {
        switch (originalMaterial) {
            case FIRE:
                return Material.FLINT_AND_STEEL; // 用打火石代表火
            default:
                if (originalMaterial.isItem()) {
                    return originalMaterial;
                } else {
                    return getAlternativeDisplayMaterial(originalMaterial);
                }
        }
    }

    /**
     * 为无法作为物品的方块提供替代显示材料
     */
    private Material getAlternativeDisplayMaterial(Material material) {
        return switch (material) {
            case FIRE -> Material.FLINT_AND_STEEL;
            case WATER -> Material.WATER_BUCKET;
            case LAVA -> Material.LAVA_BUCKET;
            default -> Material.BARRIER; // 默认使用屏障方块
        };
    }

    private String formatMaterialName(Material material) {
        return material.name().toLowerCase().replace('_', ' ');
    }

    private void setupControlButtons() {
        // 上一层按钮
        setComponent(LAYER_UP_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                boolean canGoUp = currentLayer < maxY;
                String displayName = plugin.getConfigManager().getLang(canGoUp ?
                        Messages.GUI_STRUCTURE_LAYOUT_LAYER_UP_ENABLED :
                        Messages.GUI_STRUCTURE_LAYOUT_LAYER_UP_DISABLED);

                List<String> lore;
                if (canGoUp) {
                    lore = new ArrayList<>(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_LAYER_UP_ENABLED_LORE));
                    for (int i = 0; i < lore.size(); i++) {
                        String line = lore.get(i);
                        line = line.replace("%current%", String.valueOf(currentLayer));
                        line = line.replace("%next%", String.valueOf(currentLayer + 1));
                        lore.set(i, line);
                    }
                } else {
                    lore = new ArrayList<>(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_LAYER_UP_DISABLED_LORE));
                }

                return new ItemBuilder(canGoUp ? Material.LIME_STAINED_GLASS : Material.GRAY_STAINED_GLASS)
                        .displayName(displayName)
                        .lore(lore)
                        .build();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                if (currentLayer < maxY) {
                    currentLayer++;
                    refresh();
                }
            }

            @Override
            public boolean isClickable(Player player) {
                return currentLayer < maxY;
            }
        });

        // 下一层按钮
        setComponent(LAYER_DOWN_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                boolean canGoDown = currentLayer > minY;
                String displayName = plugin.getConfigManager().getLang(canGoDown ?
                        Messages.GUI_STRUCTURE_LAYOUT_LAYER_DOWN_ENABLED :
                        Messages.GUI_STRUCTURE_LAYOUT_LAYER_DOWN_DISABLED);

                List<String> lore;
                if (canGoDown) {
                    lore = plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_LAYER_DOWN_ENABLED_LORE);
                    for (int i = 0; i < lore.size(); i++) {
                        String line = lore.get(i);
                        line = line.replace("%current%", String.valueOf(currentLayer));
                        line = line.replace("%next%", String.valueOf(currentLayer - 1));
                        lore.set(i, line);
                    }
                } else {
                    lore = plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_LAYER_DOWN_DISABLED_LORE);
                }

                return new ItemBuilder(canGoDown ? Material.RED_STAINED_GLASS : Material.GRAY_STAINED_GLASS)
                        .displayName(displayName)
                        .lore(lore)
                        .build();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                if (currentLayer > minY) {
                    currentLayer--;
                    refresh();
                }
            }

            @Override
            public boolean isClickable(Player player) {
                return currentLayer > minY;
            }
        });

        // 层级信息
        List<String> layerInfoLore = plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_LAYER_INFO_LORE);
        for (int i = 0; i < layerInfoLore.size(); i++) {
            String line = layerInfoLore.get(i);
            line = line.replace("%current%", String.valueOf(currentLayer));
            line = line.replace("%min%", String.valueOf(minY));
            line = line.replace("%max%", String.valueOf(maxY));
            line = line.replace("%total%", String.valueOf(maxY - minY + 1));
            layerInfoLore.set(i, line);
        }

        setComponent(LAYER_INFO_SLOT, new StaticComponent(
                new ItemBuilder(Material.PAPER)
                        .displayName(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_LAYER_INFO_NAME))
                        .lore(layerInfoLore)
                        .build()
        ));

        // 返回按钮
        setComponent(BACK_SLOT, new GUIComponent() {
            @Override
            public ItemStack getDisplayItem() {
                return ItemBuilder.createBackButton();
            }

            @Override
            public void onClick(Player player, InventoryClickEvent event) {
                try {
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        if (getParentGUIId() != null) {
                            plugin.getGuiManager().openGUI(player, getParentGUIId());
                        } else {
                            player.closeInventory();
                        }
                    });
                } catch (Exception e) {
                    MessageUtils.logError("Error in back button: " + e.getMessage());
                    player.closeInventory();
                }
            }
        });
    }

    private void setupInfoDisplay() {
        // 结构总体信息
        List<String> structureInfoLore = plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_LAYOUT_STRUCTURE_INFO_LORE);
        for (int i = 0; i < structureInfoLore.size(); i++) {
            String line = structureInfoLore.get(i);
            line = line.replace("%name%", structure.getDisplayName());
            line = line.replace("%blocks%", String.valueOf(structure.getBlockCount()));
            line = line.replace("%dimensions%",
                    structure.getBoundingBox().getWidth() + "x" +
                            structure.getBoundingBox().getHeight() + "x" +
                            structure.getBoundingBox().getDepth());
            structureInfoLore.set(i, line);
        }

        setComponent(INFO_SLOT, new StaticComponent(
                new ItemBuilder(Material.BOOK)
                        .displayName(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_LAYOUT_STRUCTURE_INFO_NAME))
                        .lore(structureInfoLore)
                        .build()
        ));
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\impl\utils\StructureRecipesGUI.java
==================================================
package cn.fandmc.flametech.gui.impl.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.gui.base.PaginatedGUI;
import cn.fandmc.flametech.gui.components.GUIComponent;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.unlock.data.UnlockResult;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 结构配方列表GUI
 */
public class StructureRecipesGUI extends PaginatedGUI {

    private final String multiblockId;
    private static final Map<String, StructureRecipesGUI> instances = new HashMap<>();

    private StructureRecipesGUI(Main plugin, String multiblockId) {
        super(plugin, "structure_recipes_" + multiblockId,
                plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_TITLE)
                        .replace("%machine%", getMultiblockDisplayName(plugin, multiblockId)));
        this.multiblockId = multiblockId;
    }

    /**
     * 获取多方块结构的显示名称
     */
    private static String getMultiblockDisplayName(Main plugin, String multiblockId) {
        String langKey = "multiblock." + multiblockId + ".name";
        return plugin.getConfigManager().getLang(langKey);
    }

    public static StructureRecipesGUI getInstance(Main plugin, String multiblockId) {
        return instances.computeIfAbsent(multiblockId, k -> {
            StructureRecipesGUI gui = new StructureRecipesGUI(plugin, multiblockId);
            plugin.getGuiManager().registerGUI(gui);
            return gui;
        });
    }

    @Override
    protected void buildGUI(Player player) {
        loadRecipesForPlayer(player);
        super.buildGUI(player);
    }

    @Override
    protected void buildExtraComponents(Player player) {
        // 添加返回按钮
        if (getParentGUIId() != null) {
            setComponent(45, new GUIComponent() {
                @Override
                public ItemStack getDisplayItem() {
                    return ItemBuilder.createBackButton();
                }

                @Override
                public void onClick(Player player, InventoryClickEvent event) {
                    try {
                        plugin.getServer().getScheduler().runTask(plugin, () -> {
                            plugin.getGuiManager().openGUI(player, getParentGUIId());
                        });
                    } catch (Exception e) {
                        MessageUtils.logError("Error in back button: " + e.getMessage());
                        player.closeInventory();
                    }
                }
            });
        }
    }

    private void loadRecipesForPlayer(Player player) {
        clearPageItems();
        List<Recipe> recipes = plugin.getRecipeManager().getRecipesForMultiblock(multiblockId);

        if (recipes.isEmpty()) {
            addPageItem(new NoRecipeComponent());
        } else {
            for (Recipe recipe : recipes) {
                addPageItem(new RecipeComponent(recipe, player));
            }
        }
    }

    /**
     * 无配方组件
     */
    private class NoRecipeComponent implements GUIComponent {
        @Override
        public ItemStack getDisplayItem() {
            return new ItemBuilder(Material.BARRIER)
                    .displayName(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_NO_RECIPES))
                    .lore(plugin.getConfigManager().getStringList(Messages.GUI_STRUCTURE_RECIPES_NO_RECIPES_LORE))
                    .build();
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            // 无操作
        }
    }

    /**
     * 配方组件
     */
    private class RecipeComponent implements GUIComponent {
        private final Recipe recipe;
        private final Player player;

        public RecipeComponent(Recipe recipe, Player player) {
            this.recipe = recipe;
            this.player = player;
        }

        @Override
        public ItemStack getDisplayItem() {
            String recipeUnlockId = "recipe." + recipe.getRecipeId();
            boolean isUnlocked = plugin.getUnlockManager().isUnlocked(player, recipeUnlockId);

            if (!isUnlocked) {
                // 未解锁状态
                int requiredExp = plugin.getUnlockManager().getRequiredExp(recipeUnlockId);

                String displayName = plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_NAME)
                        .replace("%recipe%", recipe.getDisplayName());

                List<String> lore = new ArrayList<>();
                lore.add(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_LORE_EXP)
                        .replace("%required%", String.valueOf(requiredExp)));
                lore.add("");
                lore.add(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_RECIPE_LOCKED_LORE_CLICK));

                return new ItemBuilder(Material.BARRIER)
                        .displayName(displayName)
                        .lore(lore)
                        .build();
            } else {
                // 已解锁状态
                ItemStack display = recipe.getResult().clone();
                if (display.hasItemMeta()) {
                    var meta = display.getItemMeta();
                    var lore = meta.getLore();
                    if (lore == null) lore = new ArrayList<>();

                    lore.add("");
                    lore.add(plugin.getConfigManager().getLang(Messages.GUI_STRUCTURE_RECIPES_CLICK_VIEW_RECIPE));

                    meta.setLore(lore);
                    display.setItemMeta(meta);
                }
                return display;
            }
        }

        @Override
        public void onClick(Player player, InventoryClickEvent event) {
            try {
                String recipeUnlockId = "recipe." + recipe.getRecipeId();

                if (!plugin.getUnlockManager().isUnlocked(player, recipeUnlockId)) {
                    // 尝试解锁配方
                    UnlockResult result = plugin.getUnlockManager().unlock(player, recipeUnlockId);

                    if (result.isSuccess()) {
                        MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_SUCCESS,
                                "%item%", recipe.getDisplayName());

                        // 刷新界面
                        plugin.getServer().getScheduler().runTask(plugin, () -> {
                            StructureRecipesGUI.this.open(player);
                        });
                    } else {
                        // 处理解锁失败
                        handleUnlockFailure(player, result);
                    }
                } else {
                    // 已解锁，打开配方详情
                    plugin.getServer().getScheduler().runTask(plugin, () -> {
                        try {
                            ItemRecipeGUI recipeGUI = new ItemRecipeGUI(plugin, recipe, multiblockId);
                            recipeGUI.open(player);
                        } catch (Exception e) {
                            MessageUtils.logError("Failed to open recipe GUI: " + e.getMessage());
                            MessageUtils.sendLocalizedMessage(player, Messages.GUI_STRUCTURE_RECIPES_ERROR_OPEN_RECIPE);
                        }
                    });
                }
            } catch (Exception e) {
                MessageUtils.logError("Error in RecipeComponent onClick: " + e.getMessage());
                MessageUtils.sendLocalizedMessage(player, Messages.GUI_STRUCTURE_RECIPES_ERROR_CLICK_EVENT);
            }
        }

        /**
         * 处理解锁失败的情况
         */
        private void handleUnlockFailure(Player player, UnlockResult result) {
            switch (result.getStatus()) {
                case INSUFFICIENT_EXP:
                    MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_INSUFFICIENT_EXP,
                            "%required%", String.valueOf(result.getRequiredExp()));
                    break;
                case ALREADY_UNLOCKED:
                    MessageUtils.sendLocalizedMessage(player, Messages.UNLOCK_ALREADY_UNLOCKED);
                    break;
                default:
                    MessageUtils.sendLocalizedMessage(player, Messages.GUI_STRUCTURE_RECIPES_UNLOCK_FAILED_DEFAULT,
                            "%message%", result.getMessage());
                    break;
            }
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\listeners\GUIListener.java
==================================================
package cn.fandmc.flametech.gui.listeners;

import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.manager.GUIManager;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryCloseEvent;
import org.bukkit.event.player.PlayerQuitEvent;

/**
 * GUI事件监听器
 */
public class GUIListener implements Listener {

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getInventory().getHolder() instanceof BaseGUI gui)) {
            return;
        }

        // 委托给GUI处理
        gui.handleClick(event);
    }

    @EventHandler
    public void onInventoryClose(InventoryCloseEvent event) {
        if (!(event.getPlayer() instanceof Player player)) {
            return;
        }

        if (!(event.getInventory().getHolder() instanceof BaseGUI gui)) {
            return;
        }

        // 通知GUI管理器
        GUIManager.getInstance().closeGUI(player);
    }

    @EventHandler
    public void onPlayerQuit(PlayerQuitEvent event) {
        // 清理玩家的GUI状态
        GUIManager.getInstance().handlePlayerDisconnect(event.getPlayer());
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\gui\manager\GUIManager.java
==================================================
package cn.fandmc.flametech.gui.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.base.BaseGUI;
import cn.fandmc.flametech.gui.impl.*;
import cn.fandmc.flametech.gui.impl.main.BasicMachinesGUI;
import cn.fandmc.flametech.gui.impl.main.MaterialsGUI;
import cn.fandmc.flametech.gui.impl.main.ToolsGUI;
import cn.fandmc.flametech.gui.listeners.GUIListener;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * GUI管理器 - 管理所有GUI界面
 */
public class GUIManager {

    private final Main plugin;
    private final Map<String, BaseGUI> registeredGUIs = new HashMap<>();
    private final Map<Player, BaseGUI> openGUIs = new HashMap<>();

    private final Set<Player> closingGUIs = ConcurrentHashMap.newKeySet();

    private static GUIManager instance;

    public GUIManager(Main plugin) {
        this.plugin = plugin;
        instance = this;

        // 注册GUI监听器
        plugin.getServer().getPluginManager().registerEvents(new GUIListener(), plugin);
    }

    /**
     * 注册默认GUI
     */
    public void registerDefaultGUIs() {
        try {
            registerGUI(new MainGUI(plugin));

            registerGUI(new BasicMachinesGUI(plugin));
            registerGUI(new ToolsGUI(plugin));
            registerGUI(new MaterialsGUI(plugin));

            MessageUtils.logInfo("成功注册了 " + registeredGUIs.size() + " 个GUI");

        } catch (Exception e) {
            MessageUtils.logError("注册默认GUI失败: " + e.getMessage());
            throw e;
        }
    }

    /**
     * 注册GUI
     */
    public void registerGUI(BaseGUI gui) {
        if (gui == null) {
            MessageUtils.logWarning("尝试注册空GUI");
            return;
        }

        String guiId = gui.getGuiId();
        if (registeredGUIs.containsKey(guiId)) {
            MessageUtils.logWarning("ID为 '" + guiId + "' 的GUI已存在");
            return;
        }

        registeredGUIs.put(guiId, gui);
        //MessageUtils.logInfo("注册GUI: " + guiId);
    }

    /**
     * 取消注册GUI
     */
    public void unregisterGUI(String guiId) {
        BaseGUI removed = registeredGUIs.remove(guiId);
        if (removed != null) {
            MessageUtils.logInfo("取消注册GUI: " + guiId);
        }
    }

    /**
     * 获取GUI
     */
    public Optional<BaseGUI> getGUI(String guiId) {
        return Optional.ofNullable(registeredGUIs.get(guiId));
    }

    /**
     * 打开GUI给玩家
     */
    public boolean openGUI(Player player, String guiId) {
        if (!ValidationUtils.isValidPlayer(player)) {
            MessageUtils.logWarning("Attempted to open GUI for invalid player");
            return false;
        }

        Optional<BaseGUI> guiOpt = getGUI(guiId);
        if (guiOpt.isEmpty()) {
            MessageUtils.sendMessage(player, "&c未找到GUI: " + guiId);
            MessageUtils.logWarning("Attempted to open non-existent GUI: " + guiId);
            return false;
        }

        try {
            BaseGUI gui = guiOpt.get();

            // 关闭当前打开的GUI（但不强制关闭库存）
            closeGUI(player, false);

            // 打开新GUI
            gui.open(player);
            openGUIs.put(player, gui);

            return true;

        } catch (Exception e) {
            MessageUtils.logError("Failed to open GUI " + guiId + " for player " + player.getName() + ": " + e.getMessage());
            MessageUtils.sendMessage(player, "&c打开界面时发生错误，请联系管理员");
            return false;
        }
    }

    /**
     * 关闭玩家的GUI（由事件监听器调用）
     */
    public void closeGUI(Player player) {
        closeGUI(player, false);
    }

    /**
     * 关闭玩家的GUI
     * @param player 玩家
     * @param forceCloseInventory 是否强制关闭库存（仅在必要时使用）
     */
    public void closeGUI(Player player, boolean forceCloseInventory) {
        if (!ValidationUtils.isValidPlayer(player)) {
            return;
        }

        // 防止递归调用
        if (closingGUIs.contains(player)) {
            return;
        }

        try {
            closingGUIs.add(player);

            BaseGUI currentGUI = openGUIs.remove(player);
            if (currentGUI != null) {
                try {
                    // 调用BaseGUI的关闭方法
                    currentGUI.handleClose(player);
                } catch (Exception e) {
                    MessageUtils.logError("Error during GUI close for player " + player.getName() + ": " + e.getMessage());
                }
            }

            // 只有在强制关闭时才主动关闭库存
            // 正常情况下，库存关闭事件会触发此方法，所以不需要再次关闭
            if (forceCloseInventory) {
                // 检查当前打开的库存是否是GUI
                if (player.getOpenInventory().getTopInventory().getHolder() instanceof BaseGUI) {
                    player.closeInventory();
                }
            }

        } finally {
            // 确保从关闭集合中移除
            closingGUIs.remove(player);
        }
    }

    /**
     * 获取玩家当前打开的GUI
     */
    public Optional<BaseGUI> getOpenGUI(Player player) {
        return Optional.ofNullable(openGUIs.get(player));
    }

    /**
     * 检查玩家是否有打开的GUI
     */
    public boolean hasOpenGUI(Player player) {
        return openGUIs.containsKey(player);
    }

    /**
     * 刷新玩家的GUI
     */
    public void refreshGUI(Player player) {
        getOpenGUI(player).ifPresent(BaseGUI::refresh);
    }

    /**
     * 静态方法 - 向后兼容（修改方法名避免冲突）
     */
    public static boolean openGUIStatic(Player player, String guiId) {
        return instance != null && instance.openGUI(player, guiId);
    }

    /**
     * 静态方法 - 获取实例
     */
    public static GUIManager getInstance() {
        return instance;
    }

    /**
     * 获取所有已注册的GUI
     */
    public Map<String, BaseGUI> getAllGUIs() {
        return new HashMap<>(registeredGUIs);
    }

    /**
     * 获取已注册GUI数量
     */
    public int getRegisteredGUICount() {
        return registeredGUIs.size();
    }

    /**
     * 获取当前打开GUI的玩家数量
     */
    public int getOpenGUICount() {
        return openGUIs.size();
    }

    /**
     * 清空所有注册的GUI
     */
    public void clearAllGUIs() {
        // 先关闭所有打开的GUI
        for (Player player : new HashMap<>(openGUIs).keySet()) {
            closeGUI(player, true); // 强制关闭
        }

        registeredGUIs.clear();
        MessageUtils.logDebug("Cleared all registered GUIs");
    }

    /**
     * 关闭所有打开的GUI
     */
    public void closeAllGUIs() {
        for (Player player : new HashMap<>(openGUIs).keySet()) {
            closeGUI(player, true); // 强制关闭
        }
        MessageUtils.logDebug("Closed all open GUIs");
    }

    /**
     * 重新加载GUI管理器
     */
    public void reload() {
        closeAllGUIs();
        clearAllGUIs();
        registerDefaultGUIs();
        MessageUtils.logDebug("Reloaded GUI manager");
    }

    /**
     * 处理玩家断开连接
     */
    public void handlePlayerDisconnect(Player player) {
        openGUIs.remove(player);
        closingGUIs.remove(player); // 清理关闭状态
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\base\CustomItem.java
==================================================
package cn.fandmc.flametech.items.base;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.utils.ItemUtils;
import org.bukkit.inventory.ItemStack;

/**
 * 自定义物品基类
 */
public abstract class CustomItem {

    protected final Main plugin;
    protected final String itemId;
    protected final String displayName;
    protected final String nbtKey;

    public CustomItem(Main plugin, String itemId, String displayName) {
        this.plugin = plugin;
        this.itemId = itemId;
        this.displayName = displayName;
        this.nbtKey = itemId;
    }

    /**
     * 创建物品实例
     */
    public abstract ItemStack createItem();

    /**
     * 检查ItemStack是否为此自定义物品
     */
    public boolean isCustomItem(ItemStack item) {
        return ItemUtils.hasCustomNBT(item, nbtKey);
    }

    /**
     * 获取物品ID
     */
    public String getItemId() {
        return itemId;
    }

    /**
     * 获取显示名称
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * 获取NBT键
     */
    public String getNbtKey() {
        return nbtKey;
    }

    /**
     * 检查是否启用
     */
    public boolean isEnabled() {
        return true;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\base\SpecialTool.java
==================================================
package cn.fandmc.flametech.items.base;

import cn.fandmc.flametech.Main;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 特殊工具基类
 */
public abstract class SpecialTool extends CustomItem {

    public SpecialTool(Main plugin, String itemId, String displayName) {
        super(plugin, itemId, displayName);
    }

    /**
     * 处理方块破坏事件
     */
    public abstract void handleBlockBreak(BlockBreakEvent event, Player player, Block block, ItemStack tool);

    /**
     * 检查工具是否可以使用
     */
    public boolean canUse(Player player, Block block, ItemStack tool) {
        return isEnabled() && player != null && block != null && tool != null;
    }

    /**
     * 获取工具的冷却时间（毫秒）
     */
    public long getCooldownTime() {
        return 0;
    }

    /**
     * 检查玩家是否在冷却中
     */
    public boolean isOnCooldown(Player player) {
        // 可以实现冷却系统
        return false;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\builders\ItemBuilder.java
==================================================
package cn.fandmc.flametech.items.builders;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemFlag;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * Builder pattern for creating ItemStacks with various properties
 */
public class ItemBuilder {

    private final ItemStack itemStack;
    private final ItemMeta itemMeta;

    public ItemBuilder(Material material) {
        this(material, 1);
    }

    public ItemBuilder(Material material, int amount) {
        this.itemStack = new ItemStack(material, amount);
        this.itemMeta = itemStack.getItemMeta();

        if (this.itemMeta == null) {
            throw new IllegalArgumentException("Material " + material + " does not support ItemMeta");
        }
    }

    public ItemBuilder(ItemStack baseItem) {
        this.itemStack = baseItem.clone();
        this.itemMeta = itemStack.getItemMeta();

        if (this.itemMeta == null) {
            throw new IllegalArgumentException("ItemStack does not support ItemMeta");
        }
    }

    /**
     * 设置显示名称
     */
    public ItemBuilder displayName(String name) {
        if (name != null) {
            itemMeta.setDisplayName(MessageUtils.colorize(name));
        }
        return this;
    }

    /**
     * 设置Lore
     */
    public ItemBuilder lore(String... loreLines) {
        return lore(Arrays.asList(loreLines));
    }

    /**
     * 设置Lore
     */
    public ItemBuilder lore(List<String> lore) {
        if (lore != null) {
            itemMeta.setLore(MessageUtils.colorize(lore));
        }
        return this;
    }

    /**
     * 添加Lore行
     */
    public ItemBuilder addLore(String... lines) {
        List<String> currentLore = itemMeta.getLore();
        if (currentLore == null) {
            currentLore = new ArrayList<>();
        }

        currentLore.addAll(Arrays.asList(lines));
        return lore(currentLore);
    }

    /**
     * 设置数量
     */
    public ItemBuilder amount(int amount) {
        itemStack.setAmount(Math.max(1, Math.min(64, amount)));
        return this;
    }

    /**
     * 添加附魔
     */
    public ItemBuilder enchant(Enchantment enchantment, int level) {
        itemMeta.addEnchant(enchantment, level, true);
        return this;
    }

    /**
     * 添加多个附魔
     */
    public ItemBuilder enchants(Map<Enchantment, Integer> enchantments) {
        if (enchantments != null) {
            for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
                enchant(entry.getKey(), entry.getValue());
            }
        }
        return this;
    }

    /**
     * 设置物品标志
     */
    public ItemBuilder flags(ItemFlag... flags) {
        if (flags != null) {
            itemMeta.addItemFlags(flags);
        }
        return this;
    }

    /**
     * 隐藏所有标志
     */
    public ItemBuilder hideAllFlags() {
        return flags(ItemFlag.values());
    }

    /**
     * 设置自定义模型数据
     */
    public ItemBuilder customModelData(int data) {
        itemMeta.setCustomModelData(data);
        return this;
    }

    /**
     * 设置不可破坏
     */
    public ItemBuilder unbreakable(boolean unbreakable) {
        itemMeta.setUnbreakable(unbreakable);
        return this;
    }

    /**
     * 添加NBT数据（字符串）
     */
    public ItemBuilder nbt(String key, String value) {
        if (key != null && value != null) {
            NamespacedKey namespacedKey = new NamespacedKey(Main.getInstance(), key);
            itemMeta.getPersistentDataContainer().set(namespacedKey, PersistentDataType.STRING, value);
        }
        return this;
    }

    /**
     * 添加NBT数据（整数）
     */
    public ItemBuilder nbt(String key, int value) {
        if (key != null) {
            NamespacedKey namespacedKey = new NamespacedKey(Main.getInstance(), key);
            itemMeta.getPersistentDataContainer().set(namespacedKey, PersistentDataType.INTEGER, value);
        }
        return this;
    }

    /**
     * 添加NBT数据（布尔值）
     */
    public ItemBuilder nbt(String key, boolean value) {
        if (key != null) {
            NamespacedKey namespacedKey = new NamespacedKey(Main.getInstance(), key);
            itemMeta.getPersistentDataContainer().set(namespacedKey, PersistentDataType.BYTE, (byte) (value ? 1 : 0));
        }
        return this;
    }

    /**
     * 设置发光效果（添加附魔并隐藏）
     */
    public ItemBuilder glow() {
        return glow(true);
    }

    /**
     * 设置发光效果
     */
    public ItemBuilder glow(boolean glow) {
        if (glow) {
            enchant(Enchantment.UNBREAKING, 1);
            flags(ItemFlag.HIDE_ENCHANTS);
        }
        return this;
    }

    /**
     * 构建最终的ItemStack
     */
    public ItemStack build() {
        itemStack.setItemMeta(itemMeta);
        return itemStack;
    }

    /**
     * 快速创建简单物品的静态方法
     */
    public static ItemStack createSimpleItem(Material material, String name) {
        return new ItemBuilder(material).displayName(name).build();
    }

    /**
     * 快速创建带Lore的物品的静态方法
     */
    public static ItemStack createSimpleItem(Material material, String name, String... lore) {
        return new ItemBuilder(material).displayName(name).lore(lore).build();
    }

    /**
     * 创建边框物品
     */
    public static ItemStack createBorderItem() {
        try {
            String displayName = Main.getInstance().getConfigManager().getLang(Messages.ITEM_BUILDER_BORDER_ITEM_NAME);
            return new ItemBuilder(Material.GRAY_STAINED_GLASS_PANE)
                    .displayName(displayName)
                    .build();
        } catch (Exception e) {
            // 如果配置加载失败，使用默认值
            return new ItemBuilder(Material.GRAY_STAINED_GLASS_PANE)
                    .displayName(" ")
                    .build();
        }
    }

    /**
     * 创建返回按钮
     */
    public static ItemStack createBackButton() {
        try {
            String displayName = Main.getInstance().getConfigManager().getLang(Messages.ITEM_BUILDER_BACK_BUTTON_NAME);
            return new ItemBuilder(Material.ARROW)
                    .displayName(displayName)
                    .build();
        } catch (Exception e) {
            // 如果配置加载失败，使用默认值
            return new ItemBuilder(Material.ARROW)
                    .displayName("&a← 返回")
                    .build();
        }
    }

    /**
     * 创建下一页按钮
     */
    public static ItemStack createNextPageButton() {
        try {
            String displayName = Main.getInstance().getConfigManager().getLang(Messages.ITEM_BUILDER_NEXT_PAGE_BUTTON_NAME);
            return new ItemBuilder(Material.ARROW)
                    .displayName(displayName)
                    .build();
        } catch (Exception e) {
            // 如果配置加载失败，使用默认值
            return new ItemBuilder(Material.ARROW)
                    .displayName("&a下一页 →")
                    .build();
        }
    }

    /**
     * 创建上一页按钮
     */
    public static ItemStack createPreviousPageButton() {
        try {
            String displayName = Main.getInstance().getConfigManager().getLang(Messages.ITEM_BUILDER_PREVIOUS_PAGE_BUTTON_NAME);
            return new ItemBuilder(Material.ARROW)
                    .displayName(displayName)
                    .build();
        } catch (Exception e) {
            // 如果配置加载失败，使用默认值
            return new ItemBuilder(Material.ARROW)
                    .displayName("&a← 上一页")
                    .build();
        }
    }

    /**
     * 创建页面信息物品
     */
    public static ItemStack createPageInfoItem(int currentPage, int totalPages, int totalItems) {
        try {
            String displayName = Main.getInstance().getConfigManager().getLang(Messages.ITEM_BUILDER_PAGE_INFO_NAME);

            // 获取lore列表并替换参数
            List<String> lore = Main.getInstance().getConfigManager().getStringList("items.buttons.page_info.lore");
            List<String> processedLore = new ArrayList<>();

            for (String line : lore) {
                String processedLine = line
                        .replace("%current%", String.valueOf(currentPage))
                        .replace("%total%", String.valueOf(totalPages))
                        .replace("%items%", String.valueOf(totalItems));
                processedLore.add(processedLine);
            }

            return new ItemBuilder(Material.BOOK)
                    .displayName(displayName)
                    .lore(processedLore)
                    .build();
        } catch (Exception e) {
            // 如果配置加载失败，使用默认值
            return new ItemBuilder(Material.BOOK)
                    .displayName("&e页面信息")
                    .lore(
                            "&7当前页: &e" + currentPage + "&7/&e" + totalPages,
                            "&7物品总数: &e" + totalItems
                    )
                    .build();
        }
    }

    /**
     * 安全获取配置管理器的工具方法
     */
    private static String getSafeConfig(String key, String defaultValue) {
        try {
            return Main.getInstance().getConfigManager().getLang(key);
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to load config for key: " + key + ", using default value");
            return defaultValue;
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\manager\ItemManager.java
==================================================
package cn.fandmc.flametech.items.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.items.base.CustomItem;
import cn.fandmc.flametech.items.tools.*;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * 物品管理器 - 管理所有自定义物品
 */
public class ItemManager {

    private final Main plugin;
    private final Map<String, CustomItem> customItems = new HashMap<>();

    public ItemManager(Main plugin) {
        this.plugin = plugin;
    }

    /**
     * 注册默认物品
     */
    public void registerDefaultItems() {
        try {
            // 注册工具
            registerItem(new ExplosivePickaxe(plugin));
            registerItem(new SmeltingPickaxe(plugin));
            registerItem(new MagnetTool(plugin));

            MessageUtils.logInfo("注册了 " + customItems.size() + " 个自定义物品");

        } catch (Exception e) {
            MessageUtils.logError("注册默认物品失败: " + e.getMessage());
            throw e;
        }
    }

    /**
     * 注册自定义物品
     */
    public void registerItem(CustomItem item) {
        if (item == null) {
            MessageUtils.logWarning("尝试注册空物品");
            return;
        }

        String itemId = item.getItemId();
        if (customItems.containsKey(itemId)) {
            MessageUtils.logWarning("ID为'" + itemId + "'的物品已存在");
            return;
        }

        customItems.put(itemId, item);
    }

    /**
     * 取消注册自定义物品
     */
    public void unregisterItem(String itemId) {
        CustomItem removed = customItems.remove(itemId);
        if (removed != null) {
            MessageUtils.logInfo("已取消注册自定义物品：" + itemId);
        }
    }

    /**
     * 获取自定义物品
     */
    public Optional<CustomItem> getCustomItem(String itemId) {
        return Optional.ofNullable(customItems.get(itemId));
    }

    /**
     * 检查物品是否为自定义物品
     */
    public boolean isCustomItem(ItemStack item) {
        return getCustomItemFromStack(item).isPresent();
    }

    /**
     * 从ItemStack获取自定义物品
     */
    public Optional<CustomItem> getCustomItemFromStack(ItemStack item) {
        if (ItemUtils.isAirOrNull(item)) {
            return Optional.empty();
        }

        // 检查每个注册的自定义物品
        for (CustomItem customItem : customItems.values()) {
            if (customItem.isCustomItem(item)) {
                return Optional.of(customItem);
            }
        }

        return Optional.empty();
    }

    /**
     * 创建指定ID的物品
     */
    public Optional<ItemStack> createItem(String itemId) {
        return getCustomItem(itemId).map(CustomItem::createItem);
    }

    /**
     * 创建爆炸镐
     */
    public ItemStack createExplosivePickaxe() {
        return createItem(ItemKeys.ID_EXPLOSIVE_PICKAXE)
                .orElseThrow(() -> new IllegalStateException("Explosive pickaxe not registered"));
    }

    /**
     * 创建熔炼镐
     */
    public ItemStack createSmeltingPickaxe() {
        return createItem(ItemKeys.ID_SMELTING_PICKAXE)
                .orElseThrow(() -> new IllegalStateException("Smelting pickaxe not registered"));
    }

    /**
     * 创建吸铁石
     */
    public ItemStack createMagnet() {
        return createItem(ItemKeys.ID_MAGNET)
                .orElseThrow(() -> new IllegalStateException("Magnet not registered"));
    }

    /**
     * 检查是否为爆炸镐
     */
    public boolean isExplosivePickaxe(ItemStack item) {
        return getCustomItem(ItemKeys.ID_EXPLOSIVE_PICKAXE)
                .map(customItem -> customItem.isCustomItem(item))
                .orElse(false);
    }

    /**
     * 检查是否为熔炼镐
     */
    public boolean isSmeltingPickaxe(ItemStack item) {
        return getCustomItem(ItemKeys.ID_SMELTING_PICKAXE)
                .map(customItem -> customItem.isCustomItem(item))
                .orElse(false);
    }

    /**
     * 检查是否为吸铁石
     */
    public boolean isMagnet(ItemStack item) {
        return getCustomItem(ItemKeys.ID_MAGNET)
                .map(customItem -> customItem.isCustomItem(item))
                .orElse(false);
    }

    /**
     * 获取所有已注册的物品ID
     */
    public Map<String, CustomItem> getAllCustomItems() {
        return new HashMap<>(customItems);
    }

    /**
     * 获取已注册物品数量
     */
    public int getRegisteredItemCount() {
        return customItems.size();
    }

    /**
     * 清空所有注册的物品
     */
    public void clearAllItems() {
        customItems.clear();
        MessageUtils.logDebug("Cleared all registered custom items");
    }

    /**
     * 重新加载物品
     */
    public void reload() {
        clearAllItems();
        registerDefaultItems();
        MessageUtils.logDebug("Reloaded item manager");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\tools\ExplosivePickaxe.java
==================================================
package cn.fandmc.flametech.items.tools;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ConfigKeys;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.items.base.SpecialTool;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.FoliaUtils;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class ExplosivePickaxe extends SpecialTool {

    private final AtomicBoolean isProcessing = new AtomicBoolean(false);

    public ExplosivePickaxe(Main plugin) {
        super(plugin, ItemKeys.ID_EXPLOSIVE_PICKAXE,
                plugin.getConfigManager().getSafeLang(Messages.ITEMS_EXPLOSIVE_PICKAXE_NAME, "爆炸镐"));
    }

    @Override
    public ItemStack createItem() {
        String displayName = plugin.getConfigManager().getLang(Messages.ITEMS_EXPLOSIVE_PICKAXE_NAME);

        List<String> lore = plugin.getConfigManager().getStringList(Messages.ITEMS_EXPLOSIVE_PICKAXE_LORE);
        List<String> processedLore = new ArrayList<>();

        int radius = getExplosionRadius();

        for (String line : lore) {
            String processedLine = line.replace("%radius%", String.valueOf(radius));
            processedLore.add(processedLine);
        }

        return new ItemBuilder(Material.IRON_PICKAXE)
                .displayName(displayName)
                .lore(processedLore)
                .nbt(nbtKey, "true")
                .build();
    }

    @Override
    public void handleBlockBreak(BlockBreakEvent event, Player player, Block block, ItemStack tool) {
        if (!canUse(player, block, tool) || isProcessing.get()) {
            return;
        }

        isProcessing.set(true);

        try {
            int radius = getExplosionRadius();
            int maxBlocks = getMaxBlocksPerExplosion();
            Location center = block.getLocation();

            List<Block> blocksToBreak = findBlocksToBreak(center, radius, maxBlocks);

            if (!blocksToBreak.isEmpty()) {
                FoliaUtils.runTaskLater(center, () -> {
                    try {
                        performExplosion(player, center, blocksToBreak, tool);
                    } finally {
                        isProcessing.set(false);
                    }
                }, 1L);
            } else {
                isProcessing.set(false);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in explosive pickaxe: " + e.getMessage());
            isProcessing.set(false);
        }
    }

    private List<Block> findBlocksToBreak(Location center, int radius, int maxBlocks) {
        List<Block> blocks = new ArrayList<>();

        for (int x = -radius; x <= radius; x++) {
            for (int y = -radius; y <= radius; y++) {
                for (int z = -radius; z <= radius; z++) {
                    // 跳过中心方块（已被原始事件处理）
                    if (x == 0 && y == 0 && z == 0) {
                        continue;
                    }

                    // 检查是否在球形范围内
                    if (x * x + y * y + z * z <= radius * radius) {
                        Location blockLoc = center.clone().add(x, y, z);
                        Block candidateBlock = blockLoc.getBlock();

                        if (canBreakBlock(candidateBlock)) {
                            blocks.add(candidateBlock);

                            if (blocks.size() >= maxBlocks) {
                                return blocks;
                            }
                        }
                    }
                }
            }
        }

        return blocks;
    }

    private boolean canBreakBlock(Block block) {
        if (block == null) return false;

        Material type = block.getType();

        // 排除空气和液体
        if (type.isAir() || isLiquid(type)) {
            return false;
        }

        // 排除绝对不能破坏的方块
        if (isUnbreakableBlock(type)) {
            return false;
        }

        // 检查材料是否是有效的物品类型
        if (!type.isItem()) {
            return false;
        }

        // 额外检查：确保可以用镐子破坏
        return canBreakWithPickaxe(type);
    }

    private boolean isLiquid(Material type) {
        switch (type) {
            case WATER:
            case LAVA:
            case BUBBLE_COLUMN:
                return true;
            default:
                return false;
        }
    }

    private boolean canBreakWithPickaxe(Material type) {
        switch (type) {
            default:
                return true;
        }
    }

    private boolean isUnbreakableBlock(Material type) {
        switch (type) {
            // 绝对保护的方块
            case BEDROCK:
            case BARRIER:
            case COMMAND_BLOCK:
            case CHAIN_COMMAND_BLOCK:
            case REPEATING_COMMAND_BLOCK:
            case STRUCTURE_BLOCK:
            case JIGSAW:
            case STRUCTURE_VOID:
            case END_PORTAL:
            case END_PORTAL_FRAME:
            case NETHER_PORTAL:
                return true;
            default:
                return false;
        }
    }

    private void performExplosion(Player player, Location center, List<Block> blocksToBreak, ItemStack tool) {
        // 播放爆炸效果
        playExplosionEffects(center);

        int brokenCount = 0;

        for (Block block : blocksToBreak) {
            if (canPlayerBreakBlock(player, block)) {
                try {
                    // 安全地获取掉落物
                    Collection<ItemStack> drops = getBlockDropsSafely(block, tool);
                    Location dropLocation = block.getLocation().add(0.5, 0.5, 0.5);

                    // 掉落物品
                    for (ItemStack drop : drops) {
                        if (!ItemUtils.isAirOrNull(drop) && dropLocation.getWorld() != null) {
                            dropLocation.getWorld().dropItemNaturally(dropLocation, drop);
                        }
                    }

                    // 破坏方块
                    block.setType(Material.AIR);
                    brokenCount++;

                } catch (Exception e) {
                    MessageUtils.logWarning("Failed to break block at " + block.getLocation() + ": " + e.getMessage());
                    try {
                        block.setType(Material.AIR);
                        brokenCount++;
                    } catch (Exception ignored) {
                    }
                }
            }
        }

        // 损坏工具
        int damageAmount = Math.min(brokenCount + 1, getMaxDurabilityDamage());
        ItemUtils.damageItem(tool, damageAmount);
    }

    private void playExplosionEffects(Location center) {
        if (center.getWorld() != null) {
            try {
                center.getWorld().playSound(center, Sound.ENTITY_GENERIC_EXPLODE, 1.0f, 1.0f);
                center.getWorld().spawnParticle(Particle.EXPLOSION_EMITTER,
                        center.clone().add(0.5, 0.5, 0.5), 3);
            } catch (Exception e) {
                MessageUtils.logWarning("Failed to play explosion effects: " + e.getMessage());
            }
        }
    }

    private boolean canPlayerBreakBlock(Player player, Block block) {
        if (player.getGameMode() == GameMode.CREATIVE) {
            return true;
        }

        if (isUnbreakableBlock(block.getType())) {
            return false;
        }

        // 检查距离限制
        double distance = player.getLocation().distance(block.getLocation());
        if (distance > 10.0) {
            return false;
        }

        return ValidationUtils.canPlayerBreakAtDistance(player, block.getLocation(), 10.0);
    }

    private Collection<ItemStack> getBlockDropsSafely(Block block, ItemStack tool) {
        try {
            // 在正确的线程上下文中获取掉落物
            return block.getDrops(tool);
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to get block drops for " + block.getType() + ": " + e.getMessage());
            return getDefaultDrops(block.getType());
        }
    }

    private Collection<ItemStack> getDefaultDrops(Material blockType) {
        List<ItemStack> drops = new ArrayList<>();

        // 检查材料是否是有效的物品类型
        if (!blockType.isItem()) {
            return drops; // 返回空列表
        }

        // 根据方块类型提供默认掉落物
        switch (blockType) {
            case STONE:
            case DEEPSLATE:
                drops.add(new ItemStack(Material.COBBLESTONE, 1));
                break;
            case COBBLED_DEEPSLATE:
                drops.add(new ItemStack(Material.COBBLED_DEEPSLATE, 1));
                break;
            case IRON_ORE:
            case DEEPSLATE_IRON_ORE:
                drops.add(new ItemStack(Material.RAW_IRON, 1));
                break;
            case GOLD_ORE:
            case DEEPSLATE_GOLD_ORE:
            case NETHER_GOLD_ORE:
                drops.add(new ItemStack(Material.RAW_GOLD, 1));
                break;
            case COPPER_ORE:
            case DEEPSLATE_COPPER_ORE:
                drops.add(new ItemStack(Material.RAW_COPPER, 1));
                break;
            case COAL_ORE:
            case DEEPSLATE_COAL_ORE:
                drops.add(new ItemStack(Material.COAL, 1));
                break;
            case DIAMOND_ORE:
            case DEEPSLATE_DIAMOND_ORE:
                drops.add(new ItemStack(Material.DIAMOND, 1));
                break;
            case EMERALD_ORE:
            case DEEPSLATE_EMERALD_ORE:
                drops.add(new ItemStack(Material.EMERALD, 1));
                break;
            case LAPIS_ORE:
            case DEEPSLATE_LAPIS_ORE:
                drops.add(new ItemStack(Material.LAPIS_LAZULI, 1));
                break;
            case REDSTONE_ORE:
            case DEEPSLATE_REDSTONE_ORE:
                drops.add(new ItemStack(Material.REDSTONE, 4));
                break;
            case NETHER_QUARTZ_ORE:
                drops.add(new ItemStack(Material.QUARTZ, 1));
                break;
            // 木头类
            case OAK_LOG:
            case BIRCH_LOG:
            case SPRUCE_LOG:
            case JUNGLE_LOG:
            case ACACIA_LOG:
            case DARK_OAK_LOG:
            case MANGROVE_LOG:
            case CHERRY_LOG:
            case WARPED_STEM:
            case CRIMSON_STEM:
            case STRIPPED_OAK_LOG:
            case STRIPPED_BIRCH_LOG:
            case STRIPPED_SPRUCE_LOG:
            case STRIPPED_JUNGLE_LOG:
            case STRIPPED_ACACIA_LOG:
            case STRIPPED_DARK_OAK_LOG:
            case STRIPPED_MANGROVE_LOG:
            case STRIPPED_CHERRY_LOG:
            case STRIPPED_WARPED_STEM:
            case STRIPPED_CRIMSON_STEM:
                drops.add(new ItemStack(blockType, 1));
                break;
            // 叶子类（有概率掉落）
            case OAK_LEAVES:
            case BIRCH_LEAVES:
            case SPRUCE_LEAVES:
            case JUNGLE_LEAVES:
            case ACACIA_LEAVES:
            case DARK_OAK_LEAVES:
            case MANGROVE_LEAVES:
            case CHERRY_LEAVES:
            case WARPED_WART_BLOCK:
            case NETHER_WART_BLOCK:
                // 叶子有概率掉落自身或幼苗
                if (Math.random() < 0.05) { // 5%概率掉落叶子
                    drops.add(new ItemStack(blockType, 1));
                }
                if (Math.random() < 0.05) { // 5%概率掉落幼苗
                    Material sapling = getSaplingFromLeaves(blockType);
                    if (sapling != null) {
                        drops.add(new ItemStack(sapling, 1));
                    }
                }
                break;
            // 泥土类
            case DIRT:
            case COARSE_DIRT:
            case ROOTED_DIRT:
                drops.add(new ItemStack(Material.DIRT, 1));
                break;
            case GRASS_BLOCK:
                drops.add(new ItemStack(Material.DIRT, 1));
                break;
            case SAND:
                drops.add(new ItemStack(Material.SAND, 1));
                break;
            case GRAVEL:
                // 砂砾有概率掉落燧石
                if (Math.random() < 0.1) {
                    drops.add(new ItemStack(Material.FLINT, 1));
                } else {
                    drops.add(new ItemStack(Material.GRAVEL, 1));
                }
                break;
            default:
                // 对于其他方块，如果是物品，就掉落自身
                if (blockType.isItem()) {
                    drops.add(new ItemStack(blockType, 1));
                }
                break;
        }

        return drops;
    }

    private Material getSaplingFromLeaves(Material leaves) {
        switch (leaves) {
            case OAK_LEAVES: return Material.OAK_SAPLING;
            case BIRCH_LEAVES: return Material.BIRCH_SAPLING;
            case SPRUCE_LEAVES: return Material.SPRUCE_SAPLING;
            case JUNGLE_LEAVES: return Material.JUNGLE_SAPLING;
            case ACACIA_LEAVES: return Material.ACACIA_SAPLING;
            case DARK_OAK_LEAVES: return Material.DARK_OAK_SAPLING;
            case MANGROVE_LEAVES: return Material.MANGROVE_PROPAGULE;
            case CHERRY_LEAVES: return Material.CHERRY_SAPLING;
            default: return null;
        }
    }

    @Override
    public boolean isEnabled() {
        return ValidationUtils.getConfigBoolean(ConfigKeys.TOOLS_EXPLOSIVE_ENABLED, true);
    }

    private int getExplosionRadius() {
        return ValidationUtils.getConfigInt(ConfigKeys.TOOLS_EXPLOSIVE_RADIUS, 2, 1, 3);
    }

    private int getMaxBlocksPerExplosion() {
        return ValidationUtils.getConfigInt(ConfigKeys.TOOLS_EXPLOSIVE_MAX_BLOCKS, 50, 5, 100);
    }

    private int getMaxDurabilityDamage() {
        return ValidationUtils.getConfigInt(ConfigKeys.TOOLS_EXPLOSIVE_MAX_DURABILITY_DAMAGE, 10, 1, 20);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\tools\MagnetTool.java
==================================================
package cn.fandmc.flametech.items.tools;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.items.base.SpecialTool;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.FoliaUtils;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.ExperienceOrb;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * 吸铁石工具
 */
public class MagnetTool extends SpecialTool {

    private static final double ATTRACT_RANGE = 8.0;
    private static final long COOLDOWN_MS = 3000;
    private static final int MAX_ITEMS_PER_USE = 30;
    private static final boolean ATTRACT_EXPERIENCE = true;
    private static final int ATTRACT_DELAY_TICKS = 10;

    // 冷却记录
    private static final Map<UUID, Long> playerCooldowns = new HashMap<>();

    public MagnetTool(Main plugin) {
        super(plugin, ItemKeys.ID_MAGNET,
                plugin.getConfigManager().getSafeLang(Messages.ITEMS_MAGNET_NAME, "吸铁石"));
    }

    @Override
    public ItemStack createItem() {
        String displayName = plugin.getConfigManager().getLang(Messages.ITEMS_MAGNET_NAME);
        List<String> lore = plugin.getConfigManager().getStringList(Messages.ITEMS_MAGNET_LORE);

        return new ItemBuilder(Material.COMPASS)
                .displayName(displayName)
                .lore(lore)
                .nbt(nbtKey, "true")
                .glow()
                .build();
    }

    @Override
    public void handleBlockBreak(BlockBreakEvent event, Player player, Block block, ItemStack tool) {
        // 吸铁石不处理方块破坏事件
    }

    /**
     * 处理右键点击事件
     */
    public void handleRightClick(PlayerInteractEvent event, Player player, ItemStack tool) {
        // 调试信息
        MessageUtils.logDebug("MagnetTool.handleRightClick called for player: " + player.getName());


        // 基础验证
        if (!ValidationUtils.isValidPlayer(player)) {
            MessageUtils.logError("Invalid player in magnet handleRightClick");
            return;
        }

        if (!ValidationUtils.isValidItem(tool)) {
            MessageUtils.logError("Invalid tool in magnet handleRightClick");
            return;
        }

        // 检查冷却
        if (isOnCooldown(player)) {
            sendCooldownMessage(player);
            return;
        }

        MessageUtils.logDebug("Magnet not on cooldown, attempting to attract items...");


        // 执行吸引
        attractNearbyItemsAsync(player, tool);
    }

    /**
     * 异步吸引附近的物品和经验球
     */
    private void attractNearbyItemsAsync(Player player, ItemStack tool) {
        Location playerLoc = player.getLocation();

        if (playerLoc.getWorld() == null) {
            MessageUtils.logError("Player world is null in attractNearbyItemsAsync");
            return;
        }

        try {
            // 获取附近的实体
            List<Entity> nearbyEntities = playerLoc.getWorld().getNearbyEntities(
                            playerLoc, ATTRACT_RANGE, ATTRACT_RANGE, ATTRACT_RANGE)
                    .stream()
                    .filter(this::canAttractEntity)
                    .limit(MAX_ITEMS_PER_USE)
                    .collect(Collectors.toList());

            if (nearbyEntities.isEmpty()) {
                // 没有找到物品
                MessageUtils.sendLocalizedMessage(player, Messages.TOOLS_MAGNET_NO_ITEMS);

                MessageUtils.logDebug("No attractable entities found in range");

                return;
            }

            MessageUtils.logDebug("Found " + nearbyEntities.size() + " attractable entities");


            // 播放音效
            player.playSound(playerLoc, Sound.BLOCK_NOTE_BLOCK_CHIME, 1.0f, 1.5f);

            // 设置冷却和消耗耐久（在开始吸引时就处理）
            setCooldown(player);
            ItemUtils.damageItem(tool, 1);

            // 发送成功消息
            MessageUtils.sendLocalizedMessage(player, Messages.TOOLS_MAGNET_SUCCESS,
                    "%count%", String.valueOf(nearbyEntities.size()));

            // 异步吸引每个实体
            for (Entity entity : nearbyEntities) {
                attractEntityAsync(entity, player);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in attractNearbyItemsAsync: " + e.getMessage());
        }
    }

    /**
     * 检查实体是否可以被吸引
     */
    private boolean canAttractEntity(Entity entity) {
        if (entity instanceof Item) {
            Item item = (Item) entity;
            return item.isValid() &&
                    !ItemUtils.isAirOrNull(item.getItemStack()) &&
                    item.getPickupDelay() <= 0;
        }

        if (ATTRACT_EXPERIENCE && entity instanceof ExperienceOrb) {
            return entity.isValid();
        }

        return false;
    }

    /**
     * 异步吸引单个实体到玩家位置
     */
    private void attractEntityAsync(Entity entity, Player player) {
        Location entityLoc = entity.getLocation();
        Location targetLoc = player.getLocation().add(0, 0.5, 0);

        // 创建粒子轨迹
        createAttractParticles(entityLoc, targetLoc);

        FoliaUtils.runTaskLater(entityLoc, () -> {
            if (entity.isValid() && player.isOnline()) {
                CompletableFuture<Boolean> teleportFuture = FoliaUtils.teleportAsync(entity, targetLoc, PlayerTeleportEvent.TeleportCause.PLUGIN);

                teleportFuture.thenAccept(success -> {
                    if (success && entityLoc.getWorld() != null) {
                        // 传送成功后播放粒子效果
                        FoliaUtils.runTask(targetLoc, () -> {
                            if (targetLoc.getWorld() != null) {
                                targetLoc.getWorld().spawnParticle(
                                        Particle.ELECTRIC_SPARK,
                                        targetLoc, 5, 0.2, 0.2, 0.2, 0.1);
                            }
                        });
                    }
                }).exceptionally(throwable -> {
                    MessageUtils.logDebug("Failed to teleport entity: " + throwable.getMessage());
                    return null;
                });
            }
        }, ATTRACT_DELAY_TICKS);
    }

    /**
     * 创建吸引粒子效果
     */
    private void createAttractParticles(Location from, Location to) {
        if (from.getWorld() == null) return;

        try {
            // 创建从物品到玩家的粒子轨迹
            double distance = from.distance(to);
            int particleCount = (int) Math.min(distance * 2, 20);

            FoliaUtils.runTask(from, () -> {
                for (int i = 0; i <= particleCount; i++) {
                    double ratio = (double) i / particleCount;
                    Location particleLoc = from.clone().add(
                            (to.getX() - from.getX()) * ratio,
                            (to.getY() - from.getY()) * ratio,
                            (to.getZ() - from.getZ()) * ratio
                    );

                    if (from.getWorld() != null) {
                        from.getWorld().spawnParticle(
                                Particle.HAPPY_VILLAGER,
                                particleLoc, 1, 0, 0, 0, 0);
                    }
                }
            });
        } catch (Exception e) {
            MessageUtils.logError("Error creating attract particles: " + e.getMessage());
        }
    }

    @Override
    public boolean isOnCooldown(Player player) {
        UUID playerId = player.getUniqueId();
        Long lastUse = playerCooldowns.get(playerId);

        if (lastUse == null) {
            return false;
        }

        return System.currentTimeMillis() - lastUse < COOLDOWN_MS;
    }

    private void setCooldown(Player player) {
        playerCooldowns.put(player.getUniqueId(), System.currentTimeMillis());
    }

    private void sendCooldownMessage(Player player) {
        UUID playerId = player.getUniqueId();
        Long lastUse = playerCooldowns.get(playerId);

        if (lastUse != null) {
            long remainingMs = COOLDOWN_MS - (System.currentTimeMillis() - lastUse);
            double remainingSeconds = remainingMs / 1000.0;

            MessageUtils.sendLocalizedMessage(player, Messages.TOOLS_MAGNET_COOLDOWN,
                    "%time%", String.format("%.1f", remainingSeconds));
        }
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public long getCooldownTime() {
        return COOLDOWN_MS;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\items\tools\SmeltingPickaxe.java
==================================================
package cn.fandmc.flametech.items.tools;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ConfigKeys;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.items.base.SpecialTool;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 熔炼镐工具
 */
public class SmeltingPickaxe extends SpecialTool {

    private static final Map<Material, Material> SMELTING_MAP = new HashMap<>();

    static {
        SMELTING_MAP.put(Material.IRON_ORE, Material.IRON_INGOT);
        SMELTING_MAP.put(Material.DEEPSLATE_IRON_ORE, Material.IRON_INGOT);
        SMELTING_MAP.put(Material.GOLD_ORE, Material.GOLD_INGOT);
        SMELTING_MAP.put(Material.DEEPSLATE_GOLD_ORE, Material.GOLD_INGOT);
        SMELTING_MAP.put(Material.NETHER_GOLD_ORE, Material.GOLD_INGOT);
        SMELTING_MAP.put(Material.COPPER_ORE, Material.COPPER_INGOT);
        SMELTING_MAP.put(Material.DEEPSLATE_COPPER_ORE, Material.COPPER_INGOT);
        SMELTING_MAP.put(Material.RAW_IRON, Material.IRON_INGOT);
        SMELTING_MAP.put(Material.RAW_GOLD, Material.GOLD_INGOT);
        SMELTING_MAP.put(Material.RAW_COPPER, Material.COPPER_INGOT);
    }

    public SmeltingPickaxe(Main plugin) {
        super(plugin, ItemKeys.ID_SMELTING_PICKAXE,
                plugin.getConfigManager().getSafeLang(Messages.ITEMS_SMELTING_PICKAXE_NAME, "熔炼镐"));
    }

    @Override
    public ItemStack createItem() {
        String displayName = plugin.getConfigManager().getLang(Messages.ITEMS_SMELTING_PICKAXE_NAME);

        List<String> lore = plugin.getConfigManager().getStringList(Messages.ITEMS_SMELTING_PICKAXE_LORE);

        return new ItemBuilder(Material.IRON_PICKAXE)
                .displayName(displayName)
                .lore(lore)
                .nbt(nbtKey, "true")
                .build();
    }

    @Override
    public void handleBlockBreak(BlockBreakEvent event, Player player, Block block, ItemStack tool) {
        if (!canUse(player, block, tool)) {
            return;
        }

        try {
            Material blockType = block.getType();
            Material smeltedMaterial = SMELTING_MAP.get(blockType);

            if (smeltedMaterial != null) {
                processSmeltedDrop(event, player, block, tool, smeltedMaterial);
            }

            ItemUtils.damageItem(tool, 1);

        } catch (Exception e) {
            MessageUtils.logError("Error in smelting pickaxe: " + e.getMessage());
        }
    }

    private void processSmeltedDrop(BlockBreakEvent event, Player player, Block block, ItemStack tool, Material smeltedMaterial) {
        event.setDropItems(false);

        Collection<ItemStack> originalDrops = getBlockDrops(block, tool);
        Location dropLocation = block.getLocation().add(0.5, 0.5, 0.5);

        for (ItemStack originalDrop : originalDrops) {
            ItemStack finalDrop = shouldSmeltDrop(originalDrop) ?
                    new ItemStack(smeltedMaterial, originalDrop.getAmount()) :
                    originalDrop;

            if (dropLocation.getWorld() != null) {
                dropLocation.getWorld().dropItemNaturally(dropLocation, finalDrop);
            }
        }

        playSmeltingEffects(player, block.getLocation());
    }

    private boolean shouldSmeltDrop(ItemStack drop) {
        if (ItemUtils.isAirOrNull(drop)) {
            return false;
        }

        Material type = drop.getType();
        return SMELTING_MAP.containsKey(type) || isRawMaterial(type);
    }

    private boolean isRawMaterial(Material material) {
        return material == Material.RAW_IRON ||
                material == Material.RAW_GOLD ||
                material == Material.RAW_COPPER;
    }

    private Collection<ItemStack> getBlockDrops(Block block, ItemStack tool) {
        try {
            return block.getDrops(tool);
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to get block drops for smelting: " + e.getMessage());
            return java.util.Collections.emptyList();
        }
    }

    private void playSmeltingEffects(Player player, Location location) {
        if (!shouldPlayEffects()) {
            return;
        }

        try {
            if (shouldPlaySounds()) {
                player.playSound(location, Sound.BLOCK_FURNACE_FIRE_CRACKLE, 0.5f, 1.0f);
            }

            if (shouldPlayParticles() && location.getWorld() != null) {
                location.getWorld().spawnParticle(Particle.FLAME,
                        location.clone().add(0.5, 0.5, 0.5), 5, 0.2, 0.2, 0.2, 0.01);
            }
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to play smelting effects: " + e.getMessage());
        }
    }

    @Override
    public boolean isEnabled() {
        return ValidationUtils.getConfigBoolean(ConfigKeys.TOOLS_SMELTING_ENABLED, true);
    }

    private boolean shouldPlayEffects() {
        return ValidationUtils.getConfigBoolean(ConfigKeys.TOOLS_SMELTING_PARTICLE_EFFECTS, true);
    }

    private boolean shouldPlaySounds() {
        return ValidationUtils.getConfigBoolean(ConfigKeys.TOOLS_SMELTING_SOUND_EFFECTS, true);
    }

    private boolean shouldPlayParticles() {
        return ValidationUtils.getConfigBoolean(ConfigKeys.TOOLS_SMELTING_PARTICLE_EFFECTS, true);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\listeners\BlockBreakListener.java
==================================================
package cn.fandmc.flametech.listeners;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.base.SpecialTool;
import cn.fandmc.flametech.items.manager.ItemManager;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.inventory.ItemStack;

import java.util.Optional;

/**
 * 方块破坏事件监听器
 */
public class BlockBreakListener implements Listener {

    private final Main plugin;
    private final ItemManager itemManager;

    public BlockBreakListener(Main plugin) {
        this.plugin = plugin;
        this.itemManager = plugin.getItemManager();
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    public void onBlockBreak(BlockBreakEvent event) {
        // 如果事件已被取消，不处理
        if (event.isCancelled()) {
            return;
        }

        Player player = event.getPlayer();
        ItemStack tool = player.getInventory().getItemInMainHand();
        Block block = event.getBlock();

        // 基础验证
        if (!ValidationUtils.isValidPlayer(player) ||
                !ValidationUtils.isValidItem(tool) ||
                block == null) {
            return;
        }

        try {
            // 检查是否为特殊工具
            Optional<cn.fandmc.flametech.items.base.CustomItem> customItemOpt =
                    itemManager.getCustomItemFromStack(tool);

            if (customItemOpt.isPresent() && customItemOpt.get() instanceof SpecialTool specialTool) {
                handleSpecialToolBreak(event, player, block, tool, specialTool);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error handling block break event: " + e.getMessage());
            if (plugin.isDebugMode()) {
                e.printStackTrace();
            }
        }
    }

    private void handleSpecialToolBreak(BlockBreakEvent event, Player player, Block block,
                                        ItemStack tool, SpecialTool specialTool) {
        if (!specialTool.canUse(player, block, tool)) {
            return;
        }

        if (specialTool.isOnCooldown(player)) {
            MessageUtils.sendMessage(player, "&c工具冷却中，请稍后再试！");
            return;
        }

        specialTool.handleBlockBreak(event, player, block, tool);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\listeners\PlayerInteractListener.java
==================================================
package cn.fandmc.flametech.listeners;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.gui.manager.GUIManager;
import cn.fandmc.flametech.items.base.CustomItem;
import cn.fandmc.flametech.items.tools.MagnetTool;
import cn.fandmc.flametech.multiblock.manager.MultiblockManager;
import cn.fandmc.flametech.utils.BookUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;
import org.bukkit.inventory.ItemStack;

import java.util.Optional;

public class PlayerInteractListener implements Listener {

    private final Main plugin;
    private final MultiblockManager multiblockManager;
    private final GUIManager guiManager;

    public PlayerInteractListener(Main plugin) {
        this.plugin = plugin;
        this.multiblockManager = plugin.getMultiblockManager();
        this.guiManager = plugin.getGuiManager();
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerInteract(PlayerInteractEvent event) {

        Player player = event.getPlayer();
        ItemStack item = player.getInventory().getItemInMainHand();

        try {
            MessageUtils.logDebug("PlayerInteract: " + event.getAction() +
                    ", Item: " + (item != null ? item.getType() : "null") +
                    ", Player: " + player.getName());


            // 处理指南书点击
            if (handleGuideBookClick(event, player, item)) {
                return;
            }

            // 处理吸铁石右键点击
            if (handleMagnetClick(event, player, item)) {
                return;
            }

            // 处理多方块结构交互
            if (handleMultiblockInteraction(event, player)) {
                return;
            }

            if (handleSmeltingFurnaceRelight(event, player)) {
                return;
            }
        } catch (Exception e) {
            MessageUtils.logError("Error handling player interact event: " + e.getMessage());
            if (plugin.isDebugMode()) {
                e.printStackTrace();
            }
        }
    }

    private boolean handleGuideBookClick(PlayerInteractEvent event, Player player, ItemStack item) {
        if (event.getAction() != Action.RIGHT_CLICK_AIR &&
                event.getAction() != Action.RIGHT_CLICK_BLOCK) {
            return false;
        }

        if (!BookUtils.isGuideBook(item)) {
            return false;
        }

        event.setCancelled(true);
        guiManager.openGUI(player, "main");
        return true;
    }

    /**
     * 处理吸铁石点击
     */
    private boolean handleMagnetClick(PlayerInteractEvent event, Player player, ItemStack item) {

        MessageUtils.logDebug("Checking magnet click for item: " +
                (item != null ? item.getType() : "null"));


        if (!plugin.getItemManager().isMagnet(item)) {
            return false;
        }

        MessageUtils.logDebug("Magnet detected! Processing click...");

        event.setCancelled(true);

        try {
            // 获取吸铁石工具实例并处理点击
            Optional<CustomItem> magnetOpt = plugin.getItemManager().getCustomItem(ItemKeys.ID_MAGNET);
            if (magnetOpt.isPresent() && magnetOpt.get() instanceof MagnetTool magnetTool) {
                // 调试信息
                if (plugin.isDebugMode()) {
                    MessageUtils.logInfo("Calling magnet handleRightClick...");
                }

                magnetTool.handleRightClick(event, player, item);
                return true;
            } else {
                MessageUtils.logError("Magnet tool not found or wrong type!");
                MessageUtils.sendMessage(player, "&c吸铁石工具未正确注册！");
                return false;
            }
        } catch (Exception e) {
            MessageUtils.logError("Error handling magnet click: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c使用吸铁石时发生错误: " + e.getMessage());
            return false;
        }
    }

    private boolean handleMultiblockInteraction(PlayerInteractEvent event, Player player) {
        if (event.getAction() != Action.RIGHT_CLICK_BLOCK || event.getClickedBlock() == null) {
            return false;
        }

        Location location = event.getClickedBlock().getLocation();
        return multiblockManager.handleInteraction(player, location, event);
    }

    private boolean handleSmeltingFurnaceRelight(PlayerInteractEvent event, Player player) {
        if (event.getAction() != Action.RIGHT_CLICK_BLOCK) {
            return false;
        }

        Block clickedBlock = event.getClickedBlock();
        ItemStack handItem = player.getInventory().getItemInMainHand();

        // 检查是否手持打火石右键空气方块（准备点火的位置）
        if (clickedBlock == null ||
                handItem == null ||
                handItem.getType() != Material.FLINT_AND_STEEL) {
            return false;
        }

        // 检查点击的是否是空气方块（火应该在这里）
        if (clickedBlock.getType() != Material.AIR) {
            return false;
        }

        Location fireLocation = clickedBlock.getLocation();

        Location furnaceMainBlock = fireLocation.clone().add(0, 2, 0);
        Location dispenserLocation = fireLocation.clone().add(0, 1, 0);

        if (furnaceMainBlock.getBlock().getType() == Material.NETHER_BRICK_FENCE) {
            dispenserLocation.getBlock().getType();
        }

        return false;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\listeners\multiblock\OreWasherListener.java
==================================================
package cn.fandmc.flametech.listeners.multiblock;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.multiblock.impl.OreWasher;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;

/**
 * 洗矿机特殊交互监听器
 * 处理手持沙砾右键活版门的特殊逻辑
 */
public class OreWasherListener implements Listener {

    private final Main plugin;

    public OreWasherListener(Main plugin) {
        this.plugin = plugin;
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerInteract(PlayerInteractEvent event) {
        // 只处理右键点击方块的情况
        if (event.getAction() != Action.RIGHT_CLICK_BLOCK) {
            return;
        }

        Player player = event.getPlayer();
        Block clickedBlock = event.getClickedBlock();
        ItemStack handItem = player.getInventory().getItemInMainHand();

        // 检查基础条件
        if (!ValidationUtils.isValidPlayer(player) ||
                clickedBlock == null ||
                clickedBlock.getType() != Material.OAK_TRAPDOOR ||
                handItem == null ||
                handItem.getType() != Material.GRAVEL) {
            return;
        }

        try {
            Location trapdoorLocation = clickedBlock.getLocation();

            // 检查是否是洗矿机结构
            if (isOreWasherStructure(trapdoorLocation)) {
                // 检查是否正在洗矿
                if (OreWasher.isWashing(trapdoorLocation)) {
                    event.setCancelled(true);
                    return;
                }

                // 检查炼药锅是否有水
                if (!hasCauldronWithWater(trapdoorLocation)) {
                    MessageUtils.sendLocalizedMessage(player, "multiblock.ore_washer.need_water");
                    event.setCancelled(true);
                    return;
                }

                // 让多方块管理器处理洗矿逻辑
                boolean handled = plugin.getMultiblockManager().handleInteraction(player, trapdoorLocation, event);
                if (handled) {
                    // 如果成功处理，确保事件被取消，防止活版门被打开
                    event.setCancelled(true);
                }
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in OreWasherListener: " + e.getMessage());
        }
    }

    /**
     * 检查是否为洗矿机结构
     */
    private boolean isOreWasherStructure(Location trapdoorLocation) {
        // 检查下方是否有炼药锅
        Block belowBlock = trapdoorLocation.clone().add(0, -1, 0).getBlock();
        return belowBlock.getType() == Material.CAULDRON;
    }

    /**
     * 检查炼药锅是否有水
     */
    private boolean hasCauldronWithWater(Location trapdoorLocation) {
        Block cauldronBlock = trapdoorLocation.clone().add(0, -1, 0).getBlock();

        if (cauldronBlock.getType() != Material.CAULDRON) {
            return false;
        }

        // 检查炼药锅的水位
        // 在实际实现中，可以通过检查方块数据来确定水位
        org.bukkit.block.data.Levelled cauldronData = (org.bukkit.block.data.Levelled) cauldronBlock.getBlockData();
        return cauldronData.getLevel() > 0;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\base\Material.java
==================================================
package cn.fandmc.flametech.materials.base;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.List;
import java.util.ArrayList;

public abstract class Material {
    protected final Main plugin;
    protected final String materialId;
    protected final String displayName;
    protected final String nbtKey;

    public Material(Main plugin, String materialId, String displayName) {
        this.plugin = plugin;
        this.materialId = materialId;
        this.displayName = displayName;
        this.nbtKey = "flametech_material_" + materialId;
    }

    public abstract ItemStack createItem();

    public ItemStack createItem(int amount) {
        ItemStack item = createItem();
        item.setAmount(Math.max(1, Math.min(64, amount)));
        return item;
    }

    /**
     * 安全地处理物品描述，确保颜色代码被正确处理
     */
    protected ItemStack processItemDisplay(ItemStack item) {
        if (item == null || !item.hasItemMeta()) {
            return item;
        }

        ItemMeta meta = item.getItemMeta();

        // 处理显示名称
        if (meta.hasDisplayName()) {
            String displayName = meta.getDisplayName();
            meta.setDisplayName(MessageUtils.colorize(displayName));
        }

        // 处理lore
        if (meta.hasLore()) {
            List<String> lore = meta.getLore();
            if (lore != null) {
                List<String> processedLore = new ArrayList<>();
                for (String line : lore) {
                    processedLore.add(MessageUtils.colorize(line));
                }
                meta.setLore(processedLore);
            }
        }

        item.setItemMeta(meta);
        return item;
    }

    public boolean isMaterial(ItemStack item) {
        if (item == null || item.getItemMeta() == null) {
            return false;
        }
        return item.getItemMeta().getPersistentDataContainer()
                .has(new org.bukkit.NamespacedKey(plugin, nbtKey),
                        org.bukkit.persistence.PersistentDataType.STRING);
    }

    public String getMaterialId() { return materialId; }
    public String getDisplayName() { return displayName; }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\AluminumDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 铝粉 - 使用白糖
public class AluminumDust extends Material {
    public AluminumDust(Main plugin) {
        super(plugin, "aluminum_dust", "铝粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§f铝粉")
                .lore("§7金属粉末", "§7可用于合成铝锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\ArtificialDiamond.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;

// 人造钻石 - 使用头颅
public class ArtificialDiamond extends Material {
    public ArtificialDiamond(Main plugin) {
        super(plugin, "artificial_diamond", "人造钻石");
    }

    @Override
    public ItemStack createItem() {
        ItemStack skull = SkullUtils.createDefaultSkull(
                "§b人造钻石",
                Arrays.asList("§7人造宝石", "§7工业合成钻石")
        );

        skull = new cn.fandmc.flametech.items.builders.ItemBuilder(skull)
                .nbt(nbtKey, "true")
                .build();

        return processItemDisplay(skull);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\ArtificialEmerald.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;

// 人造绿宝石 - 使用头颅
public class ArtificialEmerald extends Material {
    public ArtificialEmerald(Main plugin) {
        super(plugin, "artificial_emerald", "人造绿宝石");
    }

    @Override
    public ItemStack createItem() {
        ItemStack skull = SkullUtils.createDefaultSkull(
                "§a人造绿宝石",
                Arrays.asList("§7人造宝石", "§7工业合成绿宝石")
        );

        skull = new cn.fandmc.flametech.items.builders.ItemBuilder(skull)
                .nbt(nbtKey, "true")
                .build();

        return processItemDisplay(skull);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\ArtificialSapphire.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;

public class ArtificialSapphire extends Material {
    public ArtificialSapphire(Main plugin) {
        super(plugin, "artificial_sapphire", "人造蓝宝石");
    }

    @Override
    public ItemStack createItem() {
        ItemStack skull = SkullUtils.createDefaultSkull(
                "§9人造蓝宝石",
                Arrays.asList("§7人造宝石", "§7工业合成蓝宝石")
        );

        skull = new cn.fandmc.flametech.items.builders.ItemBuilder(skull)
                .nbt(nbtKey, "true")
                .build();

        return processItemDisplay(skull);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\BronzeIngot.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 青铜锭
public class BronzeIngot extends Material {
    public BronzeIngot(Main plugin) {
        super(plugin, "bronze_ingot", "青铜锭");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.COPPER_INGOT)
                .displayName("§6青铜锭")
                .lore("§7合金锭", "§7由铜和锡合成")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\CarbonDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

public class CarbonDust extends Material {
    public CarbonDust(Main plugin) {
        super(plugin, "carbon_dust", "碳粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GUNPOWDER)
                .displayName("§8碳粉")
                .lore("§7碳的粉末", "§7高纯度碳材料")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\ChromeDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 铬粉 - 使用白糖
public class ChromeDust extends Material {
    public ChromeDust(Main plugin) {
        super(plugin, "chrome_dust", "铬粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§8铬粉")
                .lore("§7金属粉末", "§7可用于合成铬锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\CobaltIngot.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

public class CobaltIngot extends Material {
    public CobaltIngot(Main plugin) {
        super(plugin, "cobalt_ingot", "钴锭");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GOLD_INGOT)
                .displayName("§9钴锭")
                .lore("§7稀有金属锭", "§7用于制造合金")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\CopperDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 铜粉 - 使用萤石粉
public class CopperDust extends Material {
    public CopperDust(Main plugin) {
        super(plugin, "copper_dust", "铜粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GLOWSTONE_DUST)
                .displayName("§6铜粉")
                .lore("§7金属粉末", "§7可用于合成铜锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 金粉 - 使用萤石粉
public class GoldDust extends Material {
    public GoldDust(Main plugin) {
        super(plugin, "gold_dust", "金粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GLOWSTONE_DUST)
                .displayName("§e金粉")
                .lore("§7贵金属粉末", "§7可用于合成金锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot10.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot10 extends GoldIngotPurity {
    public GoldIngot10(Main plugin) {
        super(plugin, "gold_ingot_10", "金锭 (10%)", 10);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot100.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot100 extends GoldIngotPurity {
    public GoldIngot100(Main plugin) {
        super(plugin, "gold_ingot_100", "金锭 (100%)", 100);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot20.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot20 extends GoldIngotPurity {
    public GoldIngot20(Main plugin) {
        super(plugin, "gold_ingot_20", "金锭 (20%)", 20);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot30.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot30 extends GoldIngotPurity {
    public GoldIngot30(Main plugin) {
        super(plugin, "gold_ingot_30", "金锭 (30%)", 30);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot40.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot40 extends GoldIngotPurity {
    public GoldIngot40(Main plugin) {
        super(plugin, "gold_ingot_40", "金锭 (40%)", 40);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot50.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot50 extends GoldIngotPurity {
    public GoldIngot50(Main plugin) {
        super(plugin, "gold_ingot_50", "金锭 (50%)", 50);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot60.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot60 extends GoldIngotPurity {
    public GoldIngot60(Main plugin) {
        super(plugin, "gold_ingot_60", "金锭 (60%)", 60);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot70.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot70 extends GoldIngotPurity {
    public GoldIngot70(Main plugin) {
        super(plugin, "gold_ingot_70", "金锭 (70%)", 70);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot80.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot80 extends GoldIngotPurity {
    public GoldIngot80(Main plugin) {
        super(plugin, "gold_ingot_80", "金锭 (80%)", 80);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngot90.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;

public class GoldIngot90 extends GoldIngotPurity {
    public GoldIngot90(Main plugin) {
        super(plugin, "gold_ingot_90", "金锭 (90%)", 90);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\GoldIngotPurity.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 金锭纯度基类
public abstract class GoldIngotPurity extends Material {
    protected final int purity;

    public GoldIngotPurity(Main plugin, String materialId, String displayName, int purity) {
        super(plugin, materialId, displayName);
        this.purity = purity;
    }

    @Override
    public ItemStack createItem() {
        String purityColor = getPurityColor(purity);
        return new ItemBuilder(org.bukkit.Material.GOLD_INGOT)
                .displayName(purityColor + getDisplayName())
                .lore(
                        "§7纯度锭",
                        "§7纯度: " + purityColor + purity + "%",
                        ""
                )
                .nbt(nbtKey, "true")
                .nbt("flametech_purity", purity)
                .build();
    }

    private String getPurityColor(int purity) {
        if (purity >= 90) return "§a";
        if (purity >= 70) return "§e";
        if (purity >= 50) return "§6";
        if (purity >= 30) return "§c";
        return "§4";
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\IronDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

// 铁粉 - 使用火药
public class IronDust extends Material {
    public IronDust(Main plugin) {
        super(plugin, "iron_dust", "铁粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GUNPOWDER)
                .displayName("§7铁粉")
                .lore("§7金属粉末", "§7可用于合成铁锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\MagnesiumDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

public class MagnesiumDust extends Material {
    public MagnesiumDust(Main plugin) {
        super(plugin, "magnesium_dust", "镁粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§f镁粉")
                .lore("§7轻金属粉末", "§7易燃，小心处理", "§c⚠ 遇水剧烈反应")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\OreDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 矿粉 - 一切的起源
public class OreDust extends Material {
    public OreDust(Main plugin) {
        super(plugin, "ore_dust", "矿粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.GRAVEL)
                .displayName("§8矿粉")
                .lore("§7原始矿粉", "§7一切的起源", "§7可加工成各种金属粉末")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\RawSilicon.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;

public class RawSilicon extends Material {
    public RawSilicon(Main plugin) {
        super(plugin, "raw_silicon", "原硅");
    }

    @Override
    public ItemStack createItem() {
        ItemStack skull = SkullUtils.createDefaultSkull(
                "§8原硅",
                Arrays.asList("§7原始硅材料", "§7需要精炼处理")
        );

        skull = new cn.fandmc.flametech.items.builders.ItemBuilder(skull)
                .nbt(nbtKey, "true")
                .build();

        return processItemDisplay(skull);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\Silicon.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.utils.SkullUtils;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;

public class Silicon extends Material {
    public Silicon(Main plugin) {
        super(plugin, "silicon", "硅");
    }

    @Override
    public ItemStack createItem() {
        ItemStack skull = SkullUtils.createDefaultSkull(
                "§7硅",
                Arrays.asList("§7半导体材料", "§7高纯度硅")
        );

        skull = new cn.fandmc.flametech.items.builders.ItemBuilder(skull)
                .nbt(nbtKey, "true")
                .build();

        return processItemDisplay(skull);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\SilverDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 银粉 - 使用白糖
public class SilverDust extends Material {
    public SilverDust(Main plugin) {
        super(plugin, "silver_dust", "银粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§f银粉")
                .lore("§7贵金属粉末", "§7可用于合成银锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\TinDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 锡粉 - 使用白糖
public class TinDust extends Material {
    public TinDust(Main plugin) {
        super(plugin, "tin_dust", "锡粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§7锡粉")
                .lore("§7金属粉末", "§7可用于合成锡锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\TitaniumIngot.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 钛锭 - 使用铁锭
public class TitaniumIngot extends Material {
    public TitaniumIngot(Main plugin) {
        super(plugin, "titanium_ingot", "钛锭");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.IRON_INGOT)
                .displayName("§f钛锭")
                .lore("§7高强度金属锭", "§7轻质高强度材料")
                .nbt(nbtKey, "true")
                .glow()
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\impl\ZincDust.java
==================================================
package cn.fandmc.flametech.materials.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import cn.fandmc.flametech.materials.base.Material;
import org.bukkit.inventory.ItemStack;

// 锌粉 - 使用白糖
public class ZincDust extends Material {
    public ZincDust(Main plugin) {
        super(plugin, "zinc_dust", "锌粉");
    }

    @Override
    public ItemStack createItem() {
        return new ItemBuilder(org.bukkit.Material.SUGAR)
                .displayName("§f锌粉")
                .lore("§7金属粉末", "§7可用于合成锌锭")
                .nbt(nbtKey, "true")
                .build();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\materials\manager\MaterialManager.java
==================================================
package cn.fandmc.flametech.materials.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.materials.base.Material;
import cn.fandmc.flametech.materials.impl.*;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.inventory.ItemStack;

import java.util.*;

public class MaterialManager {

    private final Main plugin;
    // 使用LinkedHashMap保持注册顺序
    private final Map<String, Material> materials = new LinkedHashMap<>();

    public MaterialManager(Main plugin) {
        this.plugin = plugin;
    }

    public void registerDefaultMaterials() {
        try {
            // 清空现有材料
            materials.clear();

            // 按逻辑顺序注册材料 - 确保顺序稳定

            // 1. 基础原料
            registerMaterial(new OreDust(plugin));

            // 2. 金属粉末类 (按字母顺序)
            registerMaterial(new AluminumDust(plugin));
            registerMaterial(new ChromeDust(plugin));
            registerMaterial(new CarbonDust(plugin));
            registerMaterial(new CobaltIngot(plugin));
            registerMaterial(new CopperDust(plugin));
            registerMaterial(new GoldDust(plugin));
            registerMaterial(new IronDust(plugin));
            registerMaterial(new MagnesiumDust(plugin));
            registerMaterial(new SilverDust(plugin));
            registerMaterial(new TinDust(plugin));
            registerMaterial(new ZincDust(plugin));

            // 3. 金锭纯度系列（按纯度从低到高）
            registerMaterial(new GoldIngot10(plugin));
            registerMaterial(new GoldIngot20(plugin));
            registerMaterial(new GoldIngot30(plugin));
            registerMaterial(new GoldIngot40(plugin));
            registerMaterial(new GoldIngot50(plugin));
            registerMaterial(new GoldIngot60(plugin));
            registerMaterial(new GoldIngot70(plugin));
            registerMaterial(new GoldIngot80(plugin));
            registerMaterial(new GoldIngot90(plugin));
            registerMaterial(new GoldIngot100(plugin));

            // 4. 合金
            registerMaterial(new BronzeIngot(plugin));
            registerMaterial(new TitaniumIngot(plugin));

            // 5. 硅材料系列
            registerMaterial(new RawSilicon(plugin));
            registerMaterial(new Silicon(plugin));

            // 6. 人造宝石系列（按字母顺序）
            registerMaterial(new ArtificialDiamond(plugin));
            registerMaterial(new ArtificialEmerald(plugin));
            registerMaterial(new ArtificialSapphire(plugin));

            MessageUtils.logInfo("成功注册了 " + materials.size() + " 种材料");

            // 记录注册顺序用于调试
            MessageUtils.logDebug("材料注册顺序: " + String.join(", ", materials.keySet()));

        } catch (Exception e) {
            MessageUtils.logError("注册默认材料失败: " + e.getMessage());
            throw e;
        }
    }

    public boolean registerMaterial(Material material) {
        if (material == null) {
            MessageUtils.logWarning("尝试注册空材料");
            return false;
        }

        String materialId = material.getMaterialId();
        if (materials.containsKey(materialId)) {
            MessageUtils.logWarning("材料ID已存在: " + materialId);
            return false;
        }

        materials.put(materialId, material);
        MessageUtils.logDebug("注册材料: " + materialId + " (" + material.getDisplayName() + ")");
        return true;
    }

    public Optional<Material> getMaterial(String materialId) {
        return Optional.ofNullable(materials.get(materialId));
    }

    public boolean isMaterial(ItemStack item) {
        return getMaterialFromStack(item).isPresent();
    }

    public Optional<Material> getMaterialFromStack(ItemStack item) {
        if (item == null || item.getItemMeta() == null) {
            return Optional.empty();
        }

        for (Material material : materials.values()) {
            try {
                if (material.isMaterial(item)) {
                    return Optional.of(material);
                }
            } catch (Exception e) {
                MessageUtils.logWarning("检查材料时发生错误 (" + material.getMaterialId() + "): " + e.getMessage());
            }
        }
        return Optional.empty();
    }

    public Optional<ItemStack> createMaterial(String materialId) {
        return getMaterial(materialId).map(material -> {
            try {
                return material.createItem();
            } catch (Exception e) {
                MessageUtils.logError("创建材料 " + materialId + " 时发生错误: " + e.getMessage());
                return null;
            }
        });
    }

    public Optional<ItemStack> createMaterial(String materialId, int amount) {
        return getMaterial(materialId).map(material -> {
            try {
                return material.createItem(amount);
            } catch (Exception e) {
                MessageUtils.logError("创建材料 " + materialId + " (数量: " + amount + ") 时发生错误: " + e.getMessage());
                return null;
            }
        });
    }

    /**
     * 获取所有材料，保持注册顺序 - 修复版本
     */
    public Collection<Material> getAllMaterials() {
        // 返回LinkedHashMap的values()保持顺序
        // 创建副本以避免并发修改，但保持顺序
        List<Material> orderedMaterials = new ArrayList<>();

        // 按照LinkedHashMap的插入顺序遍历
        for (Material material : materials.values()) {
            orderedMaterials.add(material);
        }

        MessageUtils.logDebug("MaterialManager.getAllMaterials: 返回顺序 (前5个): " +
                orderedMaterials.stream()
                        .limit(5)
                        .map(Material::getMaterialId)
                        .reduce((a, b) -> a + ", " + b)
                        .orElse("none"));

        return orderedMaterials;
    }

    /**
     * 获取所有材料的有序列表
     */
    public List<Material> getAllMaterialsList() {
        return new ArrayList<>(materials.values());
    }

    /**
     * 获取按类别分组的材料
     */
    public Map<String, List<Material>> getMaterialsByCategory() {
        Map<String, List<Material>> categorized = new LinkedHashMap<>();

        for (Material material : materials.values()) {
            String category = determineMaterialCategory(material);
            categorized.computeIfAbsent(category, k -> new ArrayList<>()).add(material);
        }

        return categorized;
    }

    /**
     * 根据材料ID确定类别
     */
    private String determineMaterialCategory(Material material) {
        String id = material.getMaterialId();

        if (id.contains("dust")) {
            return "dusts";
        } else if (id.contains("ingot")) {
            return "ingots";
        } else if (id.contains("artificial")) {
            return "gems";
        } else if (id.equals("ore_dust")) {
            return "raw_materials";
        } else if (id.contains("silicon")) {
            return "processed";
        } else if (id.contains("bronze")) {
            return "alloys";
        } else {
            return "other";
        }
    }

    public int getRegisteredMaterialCount() {
        return materials.size();
    }

    public void clearAllMaterials() {
        materials.clear();
        MessageUtils.logDebug("清空所有材料");
    }

    public void reload() {
        MessageUtils.logInfo("重载材料管理器...");
        clearAllMaterials();
        registerDefaultMaterials();
        MessageUtils.logInfo("材料管理器重载完成");
    }

    /**
     * 获取材料统计信息
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new LinkedHashMap<>();
        stats.put("total_materials", materials.size());

        // 按类别统计
        Map<String, List<Material>> byCategory = getMaterialsByCategory();
        Map<String, Integer> categoryStats = new LinkedHashMap<>();
        for (Map.Entry<String, List<Material>> entry : byCategory.entrySet()) {
            categoryStats.put(entry.getKey(), entry.getValue().size());
        }
        stats.put("by_category", categoryStats);

        // 注册顺序
        stats.put("registration_order", new ArrayList<>(materials.keySet()));

        return stats;
    }

    /**
     * 验证所有材料
     */
    public List<String> validateAllMaterials() {
        List<String> errors = new ArrayList<>();

        for (Map.Entry<String, Material> entry : materials.entrySet()) {
            String id = entry.getKey();
            Material material = entry.getValue();

            try {
                // 验证材料ID一致性
                if (!id.equals(material.getMaterialId())) {
                    errors.add("材料ID不一致: 映射=" + id + ", 材料=" + material.getMaterialId());
                }

                // 尝试创建物品
                ItemStack item = material.createItem();
                if (item == null) {
                    errors.add("材料 " + id + " 创建物品失败");
                }

                // 验证材料检测
                if (item != null && !material.isMaterial(item)) {
                    errors.add("材料 " + id + " 无法识别自己创建的物品");
                }

            } catch (Exception e) {
                errors.add("验证材料 " + id + " 时发生错误: " + e.getMessage());
            }
        }

        return errors;
    }

    /**
     * 搜索材料
     */
    public List<Material> searchMaterials(String keyword) {
        if (keyword == null || keyword.trim().isEmpty()) {
            return getAllMaterialsList();
        }

        String lowerKeyword = keyword.toLowerCase();
        List<Material> results = new ArrayList<>();

        for (Material material : materials.values()) {
            if (material.getMaterialId().toLowerCase().contains(lowerKeyword) ||
                    material.getDisplayName().toLowerCase().contains(lowerKeyword)) {
                results.add(material);
            }
        }

        return results;
    }

    /**
     * 获取材料信息的调试字符串
     */
    public String getDebugInfo() {
        StringBuilder sb = new StringBuilder();
        sb.append("MaterialManager Debug Info:\n");
        sb.append("Total Materials: ").append(materials.size()).append("\n");
        sb.append("Registration Order:\n");

        int index = 0;
        for (Map.Entry<String, Material> entry : materials.entrySet()) {
            sb.append(String.format("  %d. %s (%s)\n",
                    ++index, entry.getKey(), entry.getValue().getDisplayName()));
        }

        return sb.toString();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\base\BlockOffset.java
==================================================
package cn.fandmc.flametech.multiblock.base;

/**
 * 方块偏移量
 */
public class BlockOffset {

    private final int x;
    private final int y;
    private final int z;

    public BlockOffset(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public int getX() { return x; }
    public int getY() { return y; }
    public int getZ() { return z; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        BlockOffset that = (BlockOffset) obj;
        return x == that.x && y == that.y && z == that.z;
    }

    @Override
    public int hashCode() {
        return x * 31 * 31 + y * 31 + z;
    }

    @Override
    public String toString() {
        return String.format("BlockOffset{x=%d, y=%d, z=%d}", x, y, z);
    }

    /**
     * 创建零偏移量
     */
    public static BlockOffset zero() {
        return new BlockOffset(0, 0, 0);
    }

    /**
     * 添加偏移量
     */
    public BlockOffset add(int x, int y, int z) {
        return new BlockOffset(this.x + x, this.y + y, this.z + z);
    }

    /**
     * 添加另一个偏移量
     */
    public BlockOffset add(BlockOffset other) {
        return add(other.x, other.y, other.z);
    }

    /**
     * 减去偏移量
     */
    public BlockOffset subtract(int x, int y, int z) {
        return new BlockOffset(this.x - x, this.y - y, this.z - z);
    }

    /**
     * 减去另一个偏移量
     */
    public BlockOffset subtract(BlockOffset other) {
        return subtract(other.x, other.y, other.z);
    }

    /**
     * 计算到另一个偏移量的距离
     */
    public double distance(BlockOffset other) {
        int dx = this.x - other.x;
        int dy = this.y - other.y;
        int dz = this.z - other.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * 检查是否在指定范围内
     */
    public boolean isWithinRange(int range) {
        return Math.abs(x) <= range && Math.abs(y) <= range && Math.abs(z) <= range;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\base\MultiblockStructure.java
==================================================
package cn.fandmc.flametech.multiblock.base;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.utils.LocationUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;

import java.util.HashMap;
import java.util.Map;

/**
 * 多方块结构基类
 */
public abstract class MultiblockStructure {

    protected final Main plugin;
    protected final String structureId;
    protected final String displayName;
    protected final Map<BlockOffset, Material> structure;
    protected final int unlockLevel;

    public MultiblockStructure(Main plugin, String structureId, String displayName,
                               Map<BlockOffset, Material> structure, int unlockLevel) {
        this.plugin = plugin;
        this.structureId = structureId;
        this.displayName = displayName;
        this.structure = structure != null ? new HashMap<>(structure) : new HashMap<>();
        this.unlockLevel = unlockLevel;

        validateStructure();
    }

    public MultiblockStructure(Main plugin, String structureId, String displayName,
                               Map<BlockOffset, Material> structure) {
        this(plugin, structureId, displayName, structure, 0);
    }

    private void validateStructure() {
        if (structure.isEmpty()) {
            throw new IllegalArgumentException("Multiblock structure cannot be empty");
        }

        // 检查是否有主方块（坐标原点）
        if (!structure.containsKey(BlockOffset.zero())) {
            MessageUtils.logWarning("Multiblock structure " + structureId + " has no main block at origin");
        }
    }

    /**
     * 检查指定位置是否符合结构
     */
    public boolean checkStructure(Location centerLocation) {
        if (!ValidationUtils.isValidLocation(centerLocation)) {
            return false;
        }

        try {
            for (Map.Entry<BlockOffset, Material> entry : structure.entrySet()) {
                BlockOffset offset = entry.getKey();
                Material requiredMaterial = entry.getValue();

                Block block = LocationUtils.getBlockAtOffset(centerLocation, offset);
                if (block == null || block.getType() != requiredMaterial) {
                    return false;
                }
            }
            return true;
        } catch (Exception e) {
            MessageUtils.logError("Error checking multiblock structure: " + e.getMessage());
            return false;
        }
    }

    /**
     * 激活结构时调用
     */
    public abstract void onActivate(Player player, Location location, PlayerInteractEvent event);

    /**
     * 检查结构是否可以制作指定配方
     */
    public boolean canCraft(String recipeId) {
        return true; // 默认实现，子类可以重写
    }

    /**
     * 检查玩家是否可以使用此结构
     */
    public boolean canUse(Player player) {
        if (!ValidationUtils.isValidPlayer(player)) {
            return false;
        }

        // 检查解锁状态
        String unlockId = "multiblock." + structureId;
        return plugin.getUnlockManager().isUnlocked(player, unlockId);
    }

    /**
     * 获取结构的边界框大小
     */
    public BoundingBox getBoundingBox() {
        if (structure.isEmpty()) {
            return new BoundingBox(0, 0, 0, 0, 0, 0);
        }

        int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE;
        int minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;
        int minZ = Integer.MAX_VALUE, maxZ = Integer.MIN_VALUE;

        for (BlockOffset offset : structure.keySet()) {
            minX = Math.min(minX, offset.getX());
            maxX = Math.max(maxX, offset.getX());
            minY = Math.min(minY, offset.getY());
            maxY = Math.max(maxY, offset.getY());
            minZ = Math.min(minZ, offset.getZ());
            maxZ = Math.max(maxZ, offset.getZ());
        }

        return new BoundingBox(minX, minY, minZ, maxX, maxY, maxZ);
    }

    /**
     * 获取结构中的方块数量
     */
    public int getBlockCount() {
        return structure.size();
    }

    /**
     * 检查结构是否包含指定材料
     */
    public boolean containsMaterial(Material material) {
        return structure.containsValue(material);
    }

    /**
     * 获取结构的描述信息
     */
    public Map<String, Object> getStructureInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("id", structureId);
        info.put("display_name", displayName);
        info.put("block_count", getBlockCount());
        info.put("unlock_level", unlockLevel);

        BoundingBox bbox = getBoundingBox();
        info.put("dimensions", String.format("%dx%dx%d",
                bbox.getWidth(), bbox.getHeight(), bbox.getDepth()));

        return info;
    }

    // Getter methods
    public String getStructureId() { return structureId; }
    public String getDisplayName() { return displayName; }
    public Map<BlockOffset, Material> getStructure() { return new HashMap<>(structure); }
    public int getUnlockLevel() { return unlockLevel; }
    public Main getPlugin() { return plugin; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        MultiblockStructure that = (MultiblockStructure) obj;
        return structureId.equals(that.structureId);
    }

    @Override
    public int hashCode() {
        return structureId.hashCode();
    }

    @Override
    public String toString() {
        return String.format("MultiblockStructure{id='%s', name='%s', blocks=%d}",
                structureId, displayName, getBlockCount());
    }

    /**
     * 边界框类
     */
    public static class BoundingBox {
        private final int minX, minY, minZ, maxX, maxY, maxZ;

        public BoundingBox(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
            this.minX = minX;
            this.minY = minY;
            this.minZ = minZ;
            this.maxX = maxX;
            this.maxY = maxY;
            this.maxZ = maxZ;
        }

        public int getWidth() { return maxX - minX + 1; }
        public int getHeight() { return maxY - minY + 1; }
        public int getDepth() { return maxZ - minZ + 1; }

        public int getMinX() { return minX; }
        public int getMinY() { return minY; }
        public int getMinZ() { return minZ; }
        public int getMaxX() { return maxX; }
        public int getMaxY() { return maxY; }
        public int getMaxZ() { return maxZ; }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\impl\EnhancedCraftingTable.java
==================================================
// ============= 优化后的 EnhancedCraftingTable.java =============
package cn.fandmc.flametech.multiblock.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.Dispenser;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class EnhancedCraftingTable extends MultiblockStructure {

    public EnhancedCraftingTable(Main plugin) {
        super(plugin, ItemKeys.ID_ENHANCED_CRAFTING_TABLE,
                plugin.getConfigManager().getLang("multiblock.enhanced_crafting_table.name"),
                createStructure(),
                10);
    }

    private static Map<BlockOffset, Material> createStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();
        structure.put(new BlockOffset(0, 0, 0), Material.CRAFTING_TABLE);
        structure.put(new BlockOffset(0, -1, 0), Material.DISPENSER);
        return structure;
    }

    @Override
    public void onActivate(Player player, Location location, PlayerInteractEvent event) {
        if (!canUse(player)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_NOT_UNLOCKED,
                    "%machine%", getDisplayName());
            return;
        }

        try {
            Block dispenserBlock = location.clone().add(0, -1, 0).getBlock();

            if (dispenserBlock.getType() != Material.DISPENSER) {
                MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_ERROR);
                return;
            }

            Dispenser dispenser = (Dispenser) dispenserBlock.getState();
            Inventory dispenserInv = dispenser.getInventory();

            if (isEmpty(dispenserInv)) {
                sendWelcomeMessages(player);
            } else {
                attemptAutoCrafting(player, dispenserInv);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in enhanced crafting table activation: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理多方块结构时发生错误");
        }
    }

    private boolean isEmpty(Inventory inventory) {
        for (ItemStack item : inventory.getContents()) {
            if (!ItemUtils.isAirOrNull(item)) {
                return false;
            }
        }
        return true;
    }

    private void sendWelcomeMessages(Player player) {
        MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_CREATED);
        MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_HINT);
    }

    private void attemptAutoCrafting(Player player, Inventory dispenserInv) {
        // 获取输入物品
        Map<Integer, ItemStack> inputs = getInputsFromDispenser(dispenserInv);

        // 查找匹配的配方
        Optional<Recipe> recipeOpt = plugin.getRecipeManager()
                .findMatchingRecipe(getStructureId(), inputs);

        if (recipeOpt.isEmpty()) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_NO_RECIPE);
            return;
        }

        Recipe recipe = recipeOpt.get();

        // 检查配方解锁状态
        String recipeUnlockId = "recipe." + recipe.getRecipeId();
        if (!plugin.getUnlockManager().isUnlocked(player, recipeUnlockId)) {
            MessageUtils.sendLocalizedMessage(player, Messages.RECIPE_NOT_UNLOCKED,
                    "%recipe%", recipe.getDisplayName());
            return;
        }

        ItemStack result = recipe.getResult();

        if (!canCraftWithCurrentInventory(dispenserInv, recipe, result)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_INVENTORY_FULL);
            return;
        }

        // 执行合成
        if (performCrafting(dispenserInv, recipe, result)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_ENHANCED_CRAFTING_CRAFT_SUCCESS,
                    "%item%", recipe.getDisplayName());
        } else {
            MessageUtils.sendMessage(player, "&c合成失败，请稍后重试");
        }
    }

    /**
     * 优化后的空间检测：考虑合成后材料消耗和结果物品的空间需求
     */
    private boolean canCraftWithCurrentInventory(Inventory inventory, Recipe recipe, ItemStack result) {
        try {
            // 创建库存副本进行模拟
            Inventory simulatedInv = createInventorySnapshot(inventory);

            // 模拟消耗材料
            if (!simulateConsumeIngredients(simulatedInv, recipe)) {
                return false; // 材料不足
            }

            // 尝试添加合成结果
            Map<Integer, ItemStack> leftover = simulatedInv.addItem(result.clone());

            // 如果没有剩余物品，说明可以完全放入
            return leftover.isEmpty();

        } catch (Exception e) {
            MessageUtils.logError("Error checking crafting space: " + e.getMessage());
            return false;
        }
    }

    /**
     * 创建库存快照用于模拟
     */
    private Inventory createInventorySnapshot(Inventory original) {
        Inventory snapshot = org.bukkit.Bukkit.createInventory(null, original.getSize());

        for (int i = 0; i < original.getSize(); i++) {
            ItemStack item = original.getItem(i);
            if (item != null) {
                snapshot.setItem(i, item.clone());
            }
        }

        return snapshot;
    }

    /**
     * 模拟消耗配方材料，不实际修改库存
     */
    private boolean simulateConsumeIngredients(Inventory simulatedInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 首先验证是否有足够材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= simulatedInv.getSize()) {
                return false;
            }

            ItemStack current = simulatedInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 模拟消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = simulatedInv.getItem(slot);
            if (current != null) {
                int newAmount = current.getAmount() - requiredItem.getAmount();
                if (newAmount <= 0) {
                    simulatedInv.setItem(slot, null);
                } else {
                    ItemStack newStack = current.clone();
                    newStack.setAmount(newAmount);
                    simulatedInv.setItem(slot, newStack);
                }
            }
        }

        return true;
    }

    /**
     * 执行实际的合成操作
     */
    private boolean performCrafting(Inventory dispenserInv, Recipe recipe, ItemStack result) {
        try {
            // 消耗材料
            if (!consumeIngredients(dispenserInv, recipe)) {
                return false;
            }

            // 添加结果物品
            Map<Integer, ItemStack> leftover = dispenserInv.addItem(result.clone());

            // 处理溢出物品（掉落到地面）
            if (!leftover.isEmpty()) {
                Location dropLocation = ((Dispenser) dispenserInv.getHolder()).getLocation().add(0.5, 1.5, 0.5);
                for (ItemStack overflow : leftover.values()) {
                    if (dropLocation.getWorld() != null) {
                        dropLocation.getWorld().dropItemNaturally(dropLocation, overflow);
                    }
                }
                MessageUtils.sendLocalizedMessage(null, Messages.MULTIBLOCK_ENHANCED_CRAFTING_CRAFT_PARTIAL);
            }

            return true;

        } catch (Exception e) {
            MessageUtils.logError("Error performing crafting: " + e.getMessage());
            return false;
        }
    }

    /**
     * 实际消耗配方材料
     */
    private boolean consumeIngredients(Inventory dispenserInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 验证材料是否足够
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= dispenserInv.getSize()) {
                return false;
            }

            ItemStack current = dispenserInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = dispenserInv.getItem(slot);
            if (current != null) {
                current.setAmount(current.getAmount() - requiredItem.getAmount());
                if (current.getAmount() <= 0) {
                    dispenserInv.setItem(slot, null);
                }
            }
        }

        return true;
    }

    /**
     * 检查是否有足够的材料
     */
    private boolean hasEnoughMaterial(ItemStack current, ItemStack required) {
        if (ItemUtils.isAirOrNull(required)) {
            return true;
        }

        if (ItemUtils.isAirOrNull(current)) {
            return false;
        }

        return current.getType() == required.getType() &&
                current.getAmount() >= required.getAmount() &&
                ItemUtils.isSimilar(current, required);
    }

    /**
     * 获取发射器中的输入物品映射
     */
    private Map<Integer, ItemStack> getInputsFromDispenser(Inventory dispenserInv) {
        Map<Integer, ItemStack> inputs = new HashMap<>();

        // 将发射器的9个槽位映射到3x3网格
        for (int i = 0; i < Math.min(9, dispenserInv.getSize()); i++) {
            ItemStack item = dispenserInv.getItem(i);
            if (!ItemUtils.isAirOrNull(item)) {
                inputs.put(i, item.clone());
            }
        }

        return inputs;
    }

    /**
     * 获取发射器当前的空间统计信息（调试用）
     */
    private InventorySpaceInfo analyzeInventorySpace(Inventory inventory) {
        int emptySlots = 0;
        int partialSlots = 0;
        int fullSlots = 0;

        for (int i = 0; i < inventory.getSize(); i++) {
            ItemStack item = inventory.getItem(i);
            if (ItemUtils.isAirOrNull(item)) {
                emptySlots++;
            } else if (item.getAmount() < item.getMaxStackSize()) {
                partialSlots++;
            } else {
                fullSlots++;
            }
        }

        return new InventorySpaceInfo(emptySlots, partialSlots, fullSlots);
    }

    @Override
    public boolean canCraft(String recipeId) {
        return plugin.getRecipeManager().getRecipe(recipeId)
                .map(recipe -> getStructureId().equals(recipe.getMultiblockId()))
                .orElse(false);
    }

    /**
     * 库存空间信息类（用于调试和优化）
     */
    private static class InventorySpaceInfo {
        final int emptySlots;
        final int partialSlots;
        final int fullSlots;

        InventorySpaceInfo(int emptySlots, int partialSlots, int fullSlots) {
            this.emptySlots = emptySlots;
            this.partialSlots = partialSlots;
            this.fullSlots = fullSlots;
        }

        boolean hasSpace() {
            return emptySlots > 0 || partialSlots > 0;
        }

        @Override
        public String toString() {
            return String.format("InventorySpace{empty=%d, partial=%d, full=%d}",
                    emptySlots, partialSlots, fullSlots);
        }
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\impl\OreSifter.java
==================================================
package cn.fandmc.flametech.multiblock.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.block.Dispenser;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * 筛矿机多方块结构
 * 结构：
 * 0 t 0  (Y+1)
 * 0 h 0  (Y+0) - 主方块层
 * 0 l 0  (Y-1)
 *
 * h = 木栅栏 (主方块)
 * t = 发射器
 * l = 炼药锅
 */
public class OreSifter extends MultiblockStructure {

    public OreSifter(Main plugin) {
        super(plugin, "ore_sifter",
                plugin.getConfigManager().getLang("multiblock.ore_sifter.name"),
                createStructure(),
                8);
    }

    private static Map<BlockOffset, Material> createStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+1 层：发射器
        structure.put(new BlockOffset(0, 1, 0), Material.DISPENSER);

        // Y+0 层：木栅栏（主方块）
        structure.put(new BlockOffset(0, 0, 0), Material.OAK_FENCE);

        // Y-1 层：炼药锅
        structure.put(new BlockOffset(0, -1, 0), Material.CAULDRON);

        return structure;
    }

    @Override
    public void onActivate(Player player, Location location, PlayerInteractEvent event) {
        if (!canUse(player)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_NOT_UNLOCKED,
                    "%machine%", getDisplayName());
            return;
        }

        try {
            // 获取发射器
            Block dispenserBlock = location.clone().add(0, 1, 0).getBlock();
            if (dispenserBlock.getType() != Material.DISPENSER) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.error");
                return;
            }

            Dispenser dispenser = (Dispenser) dispenserBlock.getState();
            Inventory dispenserInv = dispenser.getInventory();

            if (isEmpty(dispenserInv)) {
                sendWelcomeMessages(player);
            } else {
                attemptSifting(player, dispenserInv, location);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in ore sifter activation: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理筛矿机时发生错误");
        }
    }

    private boolean isEmpty(Inventory inventory) {
        for (ItemStack item : inventory.getContents()) {
            if (!ItemUtils.isAirOrNull(item)) {
                return false;
            }
        }
        return true;
    }

    private void sendWelcomeMessages(Player player) {
        MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.created");
        MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.hint");
    }

    private void attemptSifting(Player player, Inventory dispenserInv, Location location) {
        // 获取输入物品
        Map<Integer, ItemStack> inputs = getInputsFromDispenser(dispenserInv);

        // 查找匹配的配方
        Optional<Recipe> recipeOpt = plugin.getRecipeManager()
                .findMatchingRecipe(getStructureId(), inputs);

        if (recipeOpt.isEmpty()) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.no_recipe");
            return;
        }

        Recipe recipe = recipeOpt.get();

        // 检查配方解锁状态
        String recipeUnlockId = "recipe." + recipe.getRecipeId();
        if (!plugin.getUnlockManager().isUnlocked(player, recipeUnlockId)) {
            MessageUtils.sendLocalizedMessage(player, Messages.RECIPE_NOT_UNLOCKED,
                    "%recipe%", recipe.getDisplayName());
            return;
        }

        ItemStack result = recipe.getResult();

        if (!canSiftWithCurrentInventory(dispenserInv, recipe, result)) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.inventory_full");
            return;
        }

        // 执行筛选
        if (performSifting(dispenserInv, recipe, result, location)) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.ore_sifter.sifting_success",
                    "%item%", recipe.getDisplayName());
        } else {
            MessageUtils.sendMessage(player, "&c筛选失败，请稍后重试");
        }
    }

    private boolean canSiftWithCurrentInventory(Inventory inventory, Recipe recipe, ItemStack result) {
        try {
            // 创建库存副本进行模拟
            Inventory simulatedInv = createInventorySnapshot(inventory);

            // 模拟消耗材料
            if (!simulateConsumeIngredients(simulatedInv, recipe)) {
                return false;
            }

            // 尝试添加筛选结果
            Map<Integer, ItemStack> leftover = simulatedInv.addItem(result.clone());
            return leftover.isEmpty();

        } catch (Exception e) {
            MessageUtils.logError("Error checking sifting space: " + e.getMessage());
            return false;
        }
    }

    private Inventory createInventorySnapshot(Inventory original) {
        Inventory snapshot = org.bukkit.Bukkit.createInventory(null, original.getSize());
        for (int i = 0; i < original.getSize(); i++) {
            ItemStack item = original.getItem(i);
            if (item != null) {
                snapshot.setItem(i, item.clone());
            }
        }
        return snapshot;
    }

    private boolean simulateConsumeIngredients(Inventory simulatedInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 验证材料是否足够
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= simulatedInv.getSize()) {
                return false;
            }

            ItemStack current = simulatedInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 模拟消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = simulatedInv.getItem(slot);
            if (current != null) {
                int newAmount = current.getAmount() - requiredItem.getAmount();
                if (newAmount <= 0) {
                    simulatedInv.setItem(slot, null);
                } else {
                    ItemStack newStack = current.clone();
                    newStack.setAmount(newAmount);
                    simulatedInv.setItem(slot, newStack);
                }
            }
        }

        return true;
    }

    private boolean performSifting(Inventory dispenserInv, Recipe recipe, ItemStack result, Location location) {
        try {
            // 播放筛选效果
            playSiftingEffects(location);

            // 消耗材料
            if (!consumeIngredients(dispenserInv, recipe)) {
                return false;
            }

            // 添加结果物品到炼药锅位置（实际是掉落）
            Location dropLocation = location.clone().add(0.5, -0.5, 0.5);
            if (dropLocation.getWorld() != null) {
                dropLocation.getWorld().dropItemNaturally(dropLocation, result.clone());
            }

            return true;

        } catch (Exception e) {
            MessageUtils.logError("Error performing sifting: " + e.getMessage());
            return false;
        }
    }

    private void playSiftingEffects(Location location) {
        if (location.getWorld() != null) {
            // 筛选音效
            location.getWorld().playSound(location, Sound.BLOCK_SAND_BREAK, 1.0f, 1.2f);
            location.getWorld().playSound(location, Sound.BLOCK_GRAVEL_BREAK, 1.0f, 0.8f);

            // 筛选粒子效果
            Location effectLocation = location.clone().add(0.5, 0.5, 0.5);
            location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                    effectLocation, 15, 0.3, 0.3, 0.3, 0, Material.SAND.createBlockData());
            location.getWorld().spawnParticle(Particle.ITEM_SNOWBALL,
                    effectLocation, 10, 0.2, 0.2, 0.2, 0.1, new ItemStack(Material.GRAVEL));
        }
    }

    private boolean consumeIngredients(Inventory dispenserInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 验证材料是否足够
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= dispenserInv.getSize()) {
                return false;
            }

            ItemStack current = dispenserInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = dispenserInv.getItem(slot);
            if (current != null) {
                current.setAmount(current.getAmount() - requiredItem.getAmount());
                if (current.getAmount() <= 0) {
                    dispenserInv.setItem(slot, null);
                }
            }
        }

        return true;
    }

    private boolean hasEnoughMaterial(ItemStack current, ItemStack required) {
        if (ItemUtils.isAirOrNull(required)) {
            return true;
        }

        if (ItemUtils.isAirOrNull(current)) {
            return false;
        }

        return current.getType() == required.getType() &&
                current.getAmount() >= required.getAmount() &&
                ItemUtils.isSimilar(current, required);
    }

    private Map<Integer, ItemStack> getInputsFromDispenser(Inventory dispenserInv) {
        Map<Integer, ItemStack> inputs = new HashMap<>();

        for (int i = 0; i < Math.min(9, dispenserInv.getSize()); i++) {
            ItemStack item = dispenserInv.getItem(i);
            if (!ItemUtils.isAirOrNull(item)) {
                inputs.put(i, item.clone());
            }
        }

        return inputs;
    }

    @Override
    public boolean canCraft(String recipeId) {
        return plugin.getRecipeManager().getRecipe(recipeId)
                .map(recipe -> getStructureId().equals(recipe.getMultiblockId()))
                .orElse(false);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\impl\OreWasher.java
==================================================
package cn.fandmc.flametech.multiblock.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.utils.FoliaUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;

/**
 * 洗矿机多方块结构
 * 结构：
 * 0 0 0  (Y+1)
 * 0 h 0  (Y+0) - 主方块层
 * 0 t 0  (Y-1)
 *
 * h = 活版门 (主方块)
 * t = 炼药锅
 */
public class OreWasher extends MultiblockStructure {

    // 存储正在洗矿的位置
    private static final Map<String, Long> washingLocations = new ConcurrentHashMap<>();
    private static final long WASHING_TIME_MIN = 3000; // 3秒
    private static final long WASHING_TIME_MAX = 5000; // 5秒

    public OreWasher(Main plugin) {
        super(plugin, "ore_washer",
                plugin.getConfigManager().getLang("multiblock.ore_washer.name"),
                createStructure(),
                3);
    }

    private static Map<BlockOffset, Material> createStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+0 层：活版门（主方块）
        structure.put(new BlockOffset(0, 0, 0), Material.OAK_TRAPDOOR);

        // Y-1 层：炼药锅
        structure.put(new BlockOffset(0, -1, 0), Material.CAULDRON);

        return structure;
    }

    @Override
    public void onActivate(Player player, Location location, PlayerInteractEvent event) {
        if (!canUse(player)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_NOT_UNLOCKED,
                    "%machine%", getDisplayName());
            return;
        }

        try {
            ItemStack handItem = player.getInventory().getItemInMainHand();

            // 检查玩家是否手持沙砾
            if (handItem == null || handItem.getType() != Material.GRAVEL) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.ore_washer.need_gravel");
                return;
            }

            // 检查炼药锅是否有水
            if (!hasCauldronWater(location)) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.ore_washer.need_water");
                return;
            }

            // 开始洗矿过程
            startWashing(player, location, handItem);

        } catch (Exception e) {
            MessageUtils.logError("Error in ore washer activation: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理洗矿机时发生错误");
        }
    }

    private boolean hasCauldronWater(Location location) {
        // 检查炼药锅是否有水（这里简化处理，实际可以检查水位）
        // 在真实实现中可以检查 Levelled 数据
        return true; // 暂时返回true，后续可以完善
    }

    private void startWashing(Player player, Location location, ItemStack gravelItem) {
        // 消耗一个沙砾
        gravelItem.setAmount(gravelItem.getAmount() - 1);
        if (gravelItem.getAmount() <= 0) {
            player.getInventory().setItemInMainHand(null);
        }

        // 播放开始洗矿的音效
        if (location.getWorld() != null) {
            location.getWorld().playSound(location, Sound.ITEM_BUCKET_FILL, 1.0f, 1.2f);
        }

        // 记录洗矿位置
        String locationKey = getLocationKey(location);
        long washingTime = ThreadLocalRandom.current().nextLong(WASHING_TIME_MIN, WASHING_TIME_MAX + 1);
        washingLocations.put(locationKey, System.currentTimeMillis() + washingTime);

        // 开始粒子效果循环
        startWashingEffects(location, washingTime);

        // 设置洗矿完成的任务
        FoliaUtils.runTaskLater(location, () -> {
            completeWashing(player, location);
        }, washingTime / 50); // 转换为tick
    }

    private void startWashingEffects(Location location, long duration) {
        Location effectLocation = location.clone().add(0.5, 0.5, 0.5);

        // 计算粒子效果的次数
        long particleTicks = duration / 100; // 每100ms一次粒子效果

        for (int i = 0; i < particleTicks; i++) {
            FoliaUtils.runTaskLater(location, () -> {
                if (location.getWorld() != null) {
                    // 洗矿粒子效果
                    location.getWorld().spawnParticle(Particle.DRIPPING_WATER,
                            effectLocation, 3, 0.3, 0.1, 0.3, 0);
                    location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                            effectLocation, 5, 0.2, 0.1, 0.2, 0, Material.GRAVEL.createBlockData());

                    // 偶尔播放水滴声
                    if (ThreadLocalRandom.current().nextDouble() < 0.3) {
                        location.getWorld().playSound(location, Sound.BLOCK_POINTED_DRIPSTONE_DRIP_WATER, 0.5f, 1.0f);
                    }
                }
            }, i * 2); // 每2tick播放一次
        }
    }

    private void completeWashing(Player player, Location location) {
        String locationKey = getLocationKey(location);
        washingLocations.remove(locationKey);

        // 播放完成音效
        if (location.getWorld() != null) {
            location.getWorld().playSound(location, Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0f, 1.2f);
            location.getWorld().spawnParticle(Particle.HAPPY_VILLAGER,
                    location.clone().add(0.5, 0.5, 0.5), 8, 0.3, 0.3, 0.3, 0);
        }

        // TODO: 目前设置为什么也不掉落，后续可以在这里添加掉落物逻辑
        // giveWashingRewards(player, location);
    }

    private String getLocationKey(Location location) {
        return location.getWorld().getName() + "_" +
                location.getBlockX() + "_" +
                location.getBlockY() + "_" +
                location.getBlockZ();
    }

    /**
     * 检查指定位置是否正在洗矿
     */
    public static boolean isWashing(Location location) {
        String locationKey = location.getWorld().getName() + "_" +
                location.getBlockX() + "_" +
                location.getBlockY() + "_" +
                location.getBlockZ();

        Long endTime = washingLocations.get(locationKey);
        if (endTime == null) {
            return false;
        }

        if (System.currentTimeMillis() > endTime) {
            washingLocations.remove(locationKey);
            return false;
        }

        return true;
    }

    /**
     * 获取洗矿剩余时间（秒）
     */
    public static int getRemainingTime(Location location) {
        String locationKey = location.getWorld().getName() + "_" +
                location.getBlockX() + "_" +
                location.getBlockY() + "_" +
                location.getBlockZ();

        Long endTime = washingLocations.get(locationKey);
        if (endTime == null) {
            return 0;
        }

        long remaining = endTime - System.currentTimeMillis();
        return Math.max(0, (int) (remaining / 1000));
    }

    @Override
    public boolean canCraft(String recipeId) {
        // 洗矿机不使用传统配方系统
        return false;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\impl\PressureMachine.java
==================================================
package cn.fandmc.flametech.multiblock.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.utils.ItemUtils;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.block.Dispenser;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * 压力机多方块结构 - 支持X和Y两个方向的3x3竖直平面
 *
 * X方向结构布局（从前方看）：
 * Y+1: p h p  (平滑石头 活塞(朝下) 平滑石头)
 * Y+0: h g h  (活塞(朝右) 玻璃(主方块) 活塞(朝左))
 * Y-1: p t p  (平滑石头 发射器 平滑石头)
 *
 * Y方向结构布局（从前方看）：
 * Y+1: p h p  (平滑石头 活塞(朝下) 平滑石头)
 * Y+0: h g h  (活塞(朝前) 玻璃(主方块) 活塞(朝后))
 * Y-1: p t p  (平滑石头 发射器 平滑石头)
 *
 * 注意：两种方向的结构在检测时会自动匹配，玩家可以选择任意一个方向搭建
 */
public class PressureMachine extends MultiblockStructure {

    public PressureMachine(Main plugin) {
        super(plugin, "pressure_machine",
                plugin.getConfigManager().getLang("multiblock.pressure_machine.name"),
                createStructure(),
                12);
    }

    /**
     * 创建基础结构模板（X方向，用于GUI显示）
     */
    private static Map<BlockOffset, Material> createStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+1 层（上层）
        structure.put(new BlockOffset(-1, 1, 0), Material.SMOOTH_STONE);   // 左上
        structure.put(new BlockOffset(0, 1, 0), Material.PISTON);          // 中上：活塞(朝下)
        structure.put(new BlockOffset(1, 1, 0), Material.SMOOTH_STONE);    // 右上

        // Y+0 层（中层 - 主方块层）
        structure.put(new BlockOffset(-1, 0, 0), Material.PISTON);         // 左中：活塞(朝右)
        structure.put(new BlockOffset(0, 0, 0), Material.GLASS);           // 中心：玻璃（主方块）
        structure.put(new BlockOffset(1, 0, 0), Material.PISTON);          // 右中：活塞(朝左)

        // Y-1 层（下层）
        structure.put(new BlockOffset(-1, -1, 0), Material.SMOOTH_STONE);  // 左下
        structure.put(new BlockOffset(0, -1, 0), Material.DISPENSER);      // 中下：发射器
        structure.put(new BlockOffset(1, -1, 0), Material.SMOOTH_STONE);   // 右下

        return structure;
    }

    /**
     * 重写结构检查方法，支持X和Y两个方向
     */
    @Override
    public boolean checkStructure(Location centerLocation) {
        if (!ValidationUtils.isValidLocation(centerLocation)) {
            return false;
        }

        try {
            // 先检查X方向结构
            if (checkStructureDirection(centerLocation, true)) {
                return true;
            }

            // 如果X方向不匹配，检查Y方向结构
            return checkStructureDirection(centerLocation, false);

        } catch (Exception e) {
            MessageUtils.logError("Error checking pressure machine structure: " + e.getMessage());
            return false;
        }
    }

    /**
     * 检查特定方向的结构
     * @param centerLocation 中心位置
     * @param isXDirection true为X方向，false为Y方向
     * @return 是否匹配结构
     */
    private boolean checkStructureDirection(Location centerLocation, boolean isXDirection) {
        Map<BlockOffset, Material> structureToCheck = isXDirection ?
                getXDirectionStructure() : getYDirectionStructure();

        MessageUtils.logDebug("检查压力机结构 - 方向: " + (isXDirection ? "X" : "Y") +
                ", 中心位置: " + centerLocation.getBlockX() + "," +
                centerLocation.getBlockY() + "," + centerLocation.getBlockZ());

        for (Map.Entry<BlockOffset, Material> entry : structureToCheck.entrySet()) {
            BlockOffset offset = entry.getKey();
            Material requiredMaterial = entry.getValue();

            Location blockLocation = centerLocation.clone().add(offset.getX(), offset.getY(), offset.getZ());
            Block block = blockLocation.getBlock();

            MessageUtils.logDebug("  检查位置 " + offset + " -> " + blockLocation.getBlockX() + "," +
                    blockLocation.getBlockY() + "," + blockLocation.getBlockZ() +
                    " 需要: " + requiredMaterial + " 实际: " + block.getType());

            if (block == null || block.getType() != requiredMaterial) {
                MessageUtils.logDebug("  结构不匹配于位置 " + offset + " 需要 " + requiredMaterial + " 但找到 " + block.getType());
                return false;
            }
        }

        MessageUtils.logDebug("结构匹配成功 - 方向: " + (isXDirection ? "X" : "Y"));
        return true;
    }

    /**
     * 获取X方向结构定义
     */
    private Map<BlockOffset, Material> getXDirectionStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+1 层（上层）
        structure.put(new BlockOffset(-1, 1, 0), Material.SMOOTH_STONE);
        structure.put(new BlockOffset(0, 1, 0), Material.PISTON);
        structure.put(new BlockOffset(1, 1, 0), Material.SMOOTH_STONE);

        // Y+0 层（中层）
        structure.put(new BlockOffset(-1, 0, 0), Material.PISTON);
        structure.put(new BlockOffset(0, 0, 0), Material.GLASS);
        structure.put(new BlockOffset(1, 0, 0), Material.PISTON);

        // Y-1 层（下层）
        structure.put(new BlockOffset(-1, -1, 0), Material.SMOOTH_STONE);
        structure.put(new BlockOffset(0, -1, 0), Material.DISPENSER);
        structure.put(new BlockOffset(1, -1, 0), Material.SMOOTH_STONE);

        return structure;
    }

    /**
     * 获取Y方向结构定义
     */
    private Map<BlockOffset, Material> getYDirectionStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+1 层（上层）
        structure.put(new BlockOffset(0, 1, -1), Material.SMOOTH_STONE);
        structure.put(new BlockOffset(0, 1, 0), Material.PISTON);
        structure.put(new BlockOffset(0, 1, 1), Material.SMOOTH_STONE);

        // Y+0 层（中层）
        structure.put(new BlockOffset(0, 0, -1), Material.PISTON);
        structure.put(new BlockOffset(0, 0, 0), Material.GLASS);
        structure.put(new BlockOffset(0, 0, 1), Material.PISTON);

        // Y-1 层（下层）
        structure.put(new BlockOffset(0, -1, -1), Material.SMOOTH_STONE);
        structure.put(new BlockOffset(0, -1, 0), Material.DISPENSER);
        structure.put(new BlockOffset(0, -1, 1), Material.SMOOTH_STONE);

        return structure;
    }

    /**
     * 获取当前结构的方向和发射器位置
     * @param centerLocation 中心位置
     * @return 发射器的位置，如果结构无效返回null
     */
    private Location getDispenserLocation(Location centerLocation) {
        // 发射器在两个方向都位于 (0, -1, 0) 相对位置
        Location dispenserLoc = centerLocation.clone().add(0, -1, 0);

        if (dispenserLoc.getBlock().getType() == Material.DISPENSER) {
            // 检查X方向结构
            if (checkStructureDirection(centerLocation, true)) {
                return dispenserLoc;
            }
            // 检查Y方向结构
            if (checkStructureDirection(centerLocation, false)) {
                return dispenserLoc;
            }
        }

        return null;
    }

    @Override
    public void onActivate(Player player, Location location, PlayerInteractEvent event) {
        if (!canUse(player)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_NOT_UNLOCKED,
                    "%machine%", getDisplayName());
            return;
        }

        try {
            // 获取发射器位置
            Location dispenserLocation = getDispenserLocation(location);
            if (dispenserLocation == null) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.error");
                return;
            }

            Block dispenserBlock = dispenserLocation.getBlock();
            Dispenser dispenser = (Dispenser) dispenserBlock.getState();
            Inventory dispenserInv = dispenser.getInventory();

            if (isEmpty(dispenserInv)) {
                sendWelcomeMessages(player);
            } else {
                attemptPressing(player, dispenserInv, location);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in pressure machine activation: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理压力机时发生错误");
        }
    }

    private boolean isEmpty(Inventory inventory) {
        for (ItemStack item : inventory.getContents()) {
            if (!ItemUtils.isAirOrNull(item)) {
                return false;
            }
        }
        return true;
    }

    private void sendWelcomeMessages(Player player) {
        MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.created");
        MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.hint");
    }

    private void attemptPressing(Player player, Inventory dispenserInv, Location location) {
        // 获取输入物品
        Map<Integer, ItemStack> inputs = getInputsFromDispenser(dispenserInv);

        // 查找匹配的配方
        Optional<Recipe> recipeOpt = plugin.getRecipeManager()
                .findMatchingRecipe(getStructureId(), inputs);

        if (recipeOpt.isEmpty()) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.no_recipe");
            return;
        }

        Recipe recipe = recipeOpt.get();

        // 检查配方解锁状态
        String recipeUnlockId = "recipe." + recipe.getRecipeId();
        if (!plugin.getUnlockManager().isUnlocked(player, recipeUnlockId)) {
            MessageUtils.sendLocalizedMessage(player, Messages.RECIPE_NOT_UNLOCKED,
                    "%recipe%", recipe.getDisplayName());
            return;
        }

        ItemStack result = recipe.getResult();

        if (!canPressWithCurrentInventory(dispenserInv, recipe, result)) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.inventory_full");
            return;
        }

        // 执行压制
        if (performPressing(dispenserInv, recipe, result, location)) {
            MessageUtils.sendLocalizedMessage(player, "multiblock.pressure_machine.pressing_success",
                    "%item%", recipe.getDisplayName());
        } else {
            MessageUtils.sendMessage(player, "&c压制失败，请稍后重试");
        }
    }

    private boolean canPressWithCurrentInventory(Inventory inventory, Recipe recipe, ItemStack result) {
        try {
            // 创建库存副本进行模拟
            Inventory simulatedInv = createInventorySnapshot(inventory);

            // 模拟消耗材料
            if (!simulateConsumeIngredients(simulatedInv, recipe)) {
                return false;
            }

            // 尝试添加压制结果
            Map<Integer, ItemStack> leftover = simulatedInv.addItem(result.clone());
            return leftover.isEmpty();

        } catch (Exception e) {
            MessageUtils.logError("Error checking pressing space: " + e.getMessage());
            return false;
        }
    }

    private Inventory createInventorySnapshot(Inventory original) {
        Inventory snapshot = org.bukkit.Bukkit.createInventory(null, original.getSize());
        for (int i = 0; i < original.getSize(); i++) {
            ItemStack item = original.getItem(i);
            if (item != null) {
                snapshot.setItem(i, item.clone());
            }
        }
        return snapshot;
    }

    private boolean simulateConsumeIngredients(Inventory simulatedInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 验证材料是否足够
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= simulatedInv.getSize()) {
                return false;
            }

            ItemStack current = simulatedInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 模拟消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = simulatedInv.getItem(slot);
            if (current != null) {
                int newAmount = current.getAmount() - requiredItem.getAmount();
                if (newAmount <= 0) {
                    simulatedInv.setItem(slot, null);
                } else {
                    ItemStack newStack = current.clone();
                    newStack.setAmount(newAmount);
                    simulatedInv.setItem(slot, newStack);
                }
            }
        }

        return true;
    }

    private boolean performPressing(Inventory dispenserInv, Recipe recipe, ItemStack result, Location location) {
        try {
            // 播放压制效果
            playPressingEffects(location);

            // 消耗材料
            if (!consumeIngredients(dispenserInv, recipe)) {
                return false;
            }

            // 添加结果物品
            Map<Integer, ItemStack> leftover = dispenserInv.addItem(result.clone());

            // 处理溢出物品（掉落到地面）
            if (!leftover.isEmpty()) {
                Location dropLocation = location.clone().add(0.5, 1.5, 0.5);
                for (ItemStack overflow : leftover.values()) {
                    if (dropLocation.getWorld() != null) {
                        dropLocation.getWorld().dropItemNaturally(dropLocation, overflow);
                    }
                }
                MessageUtils.sendLocalizedMessage(null, "multiblock.pressure_machine.pressing_partial");
            }

            return true;

        } catch (Exception e) {
            MessageUtils.logError("Error performing pressing: " + e.getMessage());
            return false;
        }
    }

    private void playPressingEffects(Location location) {
        if (location.getWorld() != null) {
            // 压制音效 - 模拟活塞运动和压制
            location.getWorld().playSound(location, Sound.BLOCK_PISTON_EXTEND, 1.0f, 0.8f);
            location.getWorld().playSound(location, Sound.BLOCK_ANVIL_USE, 0.7f, 1.2f);

            // 压制粒子效果
            Location effectLocation = location.clone().add(0.5, 0.5, 0.5);

            // 压力效果 - 从四个活塞方向产生粒子
            location.getWorld().spawnParticle(Particle.CLOUD,
                    effectLocation, 12, 0.3, 0.1, 0.3, 0.02);

            // 冲击波效果
            location.getWorld().spawnParticle(Particle.CRIT,
                    effectLocation, 8, 0.4, 0.4, 0.4, 0.1);

            // 模拟活塞同时向中心挤压的效果
            // 上方活塞效果
            location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                    location.clone().add(0.5, 1.2, 0.5), 3, 0.1, 0.1, 0.1, 0, Material.PISTON.createBlockData());

            // 四周活塞效果（适应两个方向）
            if (checkStructureDirection(location, true)) {
                // X方向的活塞效果
                location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                        location.clone().add(-0.8, 0.5, 0.5), 3, 0.1, 0.1, 0.1, 0, Material.PISTON.createBlockData());
                location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                        location.clone().add(1.8, 0.5, 0.5), 3, 0.1, 0.1, 0.1, 0, Material.PISTON.createBlockData());
            } else {
                // Y方向的活塞效果
                location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                        location.clone().add(0.5, 0.5, -0.8), 3, 0.1, 0.1, 0.1, 0, Material.PISTON.createBlockData());
                location.getWorld().spawnParticle(Particle.BLOCK_CRUMBLE,
                        location.clone().add(0.5, 0.5, 1.8), 3, 0.1, 0.1, 0.1, 0, Material.PISTON.createBlockData());
            }

            // 延迟播放收缩音效
            plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
                if (location.getWorld() != null) {
                    location.getWorld().playSound(location, Sound.BLOCK_PISTON_CONTRACT, 1.0f, 0.8f);
                }
            }, 10L);
        }
    }

    private boolean consumeIngredients(Inventory dispenserInv, Recipe recipe) {
        Map<Integer, ItemStack> required = recipe.getIngredients();

        // 验证材料是否足够
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            if (slot >= dispenserInv.getSize()) {
                return false;
            }

            ItemStack current = dispenserInv.getItem(slot);
            if (!hasEnoughMaterial(current, requiredItem)) {
                return false;
            }
        }

        // 消耗材料
        for (Map.Entry<Integer, ItemStack> entry : required.entrySet()) {
            int slot = entry.getKey();
            ItemStack requiredItem = entry.getValue();

            ItemStack current = dispenserInv.getItem(slot);
            if (current != null) {
                current.setAmount(current.getAmount() - requiredItem.getAmount());
                if (current.getAmount() <= 0) {
                    dispenserInv.setItem(slot, null);
                }
            }
        }

        return true;
    }

    private boolean hasEnoughMaterial(ItemStack current, ItemStack required) {
        if (ItemUtils.isAirOrNull(required)) {
            return true;
        }

        if (ItemUtils.isAirOrNull(current)) {
            return false;
        }

        return current.getType() == required.getType() &&
                current.getAmount() >= required.getAmount() &&
                ItemUtils.isSimilar(current, required);
    }

    private Map<Integer, ItemStack> getInputsFromDispenser(Inventory dispenserInv) {
        Map<Integer, ItemStack> inputs = new HashMap<>();

        for (int i = 0; i < Math.min(9, dispenserInv.getSize()); i++) {
            ItemStack item = dispenserInv.getItem(i);
            if (!ItemUtils.isAirOrNull(item)) {
                inputs.put(i, item.clone());
            }
        }

        return inputs;
    }

    @Override
    public boolean canCraft(String recipeId) {
        return plugin.getRecipeManager().getRecipe(recipeId)
                .map(recipe -> getStructureId().equals(recipe.getMultiblockId()))
                .orElse(false);
    }

    /**
     * 获取结构信息，包含两个方向的说明
     */
    @Override
    public Map<String, Object> getStructureInfo() {
        Map<String, Object> info = super.getStructureInfo();
        info.put("directions", "支持X和Y两个方向");
        info.put("note", "可以选择任意一个方向搭建压力机");
        return info;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\impl\SmeltingFurnace.java
==================================================
package cn.fandmc.flametech.multiblock.impl;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.multiblock.base.BlockOffset;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.block.Dispenser;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 治炼炉多方块结构 - 修复版本
 * 结构：
 * 0 h 0  (Y+0) - 主方块层：下界砖栅栏（主方块）
 * 0 t 0  (Y-1) - 发射器
 * 0 f 0  (Y-2) - 火
 * <p>
 * h = 下界砖栅栏 (主方块)
 * t = 发射器
 * f = 火
 */
public class SmeltingFurnace extends MultiblockStructure {

    // 存储每个结构当前会话的使用次数（只在当前运行时有效）
    private static final Map<String, Integer> currentSessionUsage = new ConcurrentHashMap<>();
    private static final int MAX_USAGE_BEFORE_FIRE_OUT = 5;

    public SmeltingFurnace(Main plugin) {
        super(plugin, "smelting_furnace",
                plugin.getConfigManager().getLang("multiblock.smelting_furnace.name"),
                createStructure(),
                5);
    }

    private static Map<BlockOffset, Material> createStructure() {
        Map<BlockOffset, Material> structure = new HashMap<>();

        // Y+0 层：下界砖栅栏（主方块）
        structure.put(new BlockOffset(0, 0, 0), Material.NETHER_BRICK_FENCE);

        // Y-1 层：发射器
        structure.put(new BlockOffset(0, -1, 0), Material.DISPENSER);

        // Y-2 层：火
        structure.put(new BlockOffset(0, -2, 0), Material.FIRE);

        return structure;
    }

    @Override
    public void onActivate(Player player, Location location, PlayerInteractEvent event) {
        if (!canUse(player)) {
            MessageUtils.sendLocalizedMessage(player, Messages.MULTIBLOCK_NOT_UNLOCKED,
                    "%machine%", getDisplayName());
            return;
        }

        try {
            // 获取结构方块 - 注意：location现在是主方块（下界砖栅栏）位置
            Block dispenserBlock = location.clone().add(0, -1, 0).getBlock();
            Block fireBlock = location.clone().add(0, -2, 0).getBlock();

            if (dispenserBlock.getType() != Material.DISPENSER) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.error");
                return;
            }

            // 检查火是否还在 - 这是最重要的检查
            if (fireBlock.getType() != Material.FIRE) {
                MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.fire_out");
                MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.relight_hint");
                return;
            }

            Dispenser dispenser = (Dispenser) dispenserBlock.getState();
            Inventory dispenserInv = dispenser.getInventory();

            if (isEmpty(dispenserInv)) {
                sendWelcomeMessages(player);
                // 重要：为新建结构重置使用次数
                resetUsageCount(location);
            } else {
                attemptSmelting(player, dispenserInv, location);
            }

        } catch (Exception e) {
            MessageUtils.logError("Error in smelting furnace activation: " + e.getMessage());
            MessageUtils.sendMessage(player, "&c处理治炼炉时发生错误");
        }
    }

    private boolean isEmpty(Inventory inventory) {
        for (ItemStack item : inventory.getContents()) {
            if (item != null && item.getType() != Material.AIR) {
                return false;
            }
        }
        return true;
    }

    private void sendWelcomeMessages(Player player) {
        MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.created");
        MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.hint");
    }

    private void attemptSmelting(Player player, Inventory dispenserInv, Location location) {
        String locationKey = getLocationKey(location);

        // 获取当前会话的使用次数
        int currentUsage = currentSessionUsage.getOrDefault(locationKey, 0);
        boolean smeltingSuccess = performSmelting(player, dispenserInv, location);

        if (smeltingSuccess) {
            currentSessionUsage.put(locationKey, currentUsage + 1);
        }

        if (currentUsage >= MAX_USAGE_BEFORE_FIRE_OUT) {
            extinguishFire(location);
            currentSessionUsage.remove(locationKey);
            MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.final_use_warning");
            return;
        }
    }

    private boolean performSmelting(Player player, Inventory dispenserInv, Location location) {
        try {
            playSmeltingEffects(location);
            MessageUtils.sendLocalizedMessage(player, "multiblock.smelting_furnace.smelting_complete");
            return true;
        } catch (Exception e) {
            MessageUtils.logError("Error during smelting process: " + e.getMessage());
            return false;
        }
    }

    private void extinguishFire(Location location) {
        Block fireBlock = location.clone().add(0, -2, 0).getBlock();
        if (fireBlock.getType() == Material.FIRE) {
            fireBlock.setType(Material.AIR);

            // 播放火焰熄灭效果
            if (location.getWorld() != null) {
                location.getWorld().playSound(location, Sound.BLOCK_FIRE_EXTINGUISH, 1.0f, 1.0f);
                location.getWorld().spawnParticle(Particle.SMOKE,
                        location.clone().add(0.5, -1.5, 0.5), 10, 0.3, 0.3, 0.3, 0.1);
            }
        }
    }

    private void playSmeltingEffects(Location location) {
        if (location.getWorld() != null) {
            location.getWorld().playSound(location, Sound.BLOCK_FURNACE_FIRE_CRACKLE, 1.0f, 1.0f);
            location.getWorld().spawnParticle(Particle.FLAME,
                    location.clone().add(0.5, -1.5, 0.5), 8, 0.2, 0.2, 0.2, 0.02);
        }
    }

    /**
     * 重置使用次数（当重新点火或新建结构时调用）
     */
    private void resetUsageCount(Location location) {
        String locationKey = getLocationKey(location);
        currentSessionUsage.put(locationKey, 0);
        MessageUtils.logDebug("重置治炼炉使用次数: " + locationKey);
    }

    private String getLocationKey(Location location) {
        return location.getWorld().getName() + "_" +
                location.getBlockX() + "_" +
                location.getBlockY() + "_" +
                location.getBlockZ();
    }

    /**
     * 获取当前使用次数（用于调试）
     */
    public static int getCurrentUsage(Location location) {
        String locationKey = location.getWorld().getName() + "_" +
                location.getBlockX() + "_" +
                location.getBlockY() + "_" +
                location.getBlockZ();
        return currentSessionUsage.getOrDefault(locationKey, 0);
    }

    /**
     * 清理所有使用记录（可在插件重载时调用）
     */
    public static void clearAllUsageRecords() {
        currentSessionUsage.clear();
        MessageUtils.logDebug("清理所有治炼炉使用记录");
    }

    @Override
    public boolean canCraft(String recipeId) {
        // TODO: 这里可以添加治炼炉专用配方的检查
        return true;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\multiblock\manager\MultiblockManager.java
==================================================
package cn.fandmc.flametech.multiblock.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.multiblock.impl.*;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerInteractEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * 多方块结构管理器
 */
public class MultiblockManager {

    private final Main plugin;
    private final Map<String, MultiblockStructure> structures = new HashMap<>();

    public MultiblockManager(Main plugin) {
        this.plugin = plugin;
    }

    /**
     * 注册默认结构
     */
    public void registerDefaultStructures() {
        try {
            registerStructure(new EnhancedCraftingTable(plugin));
            registerStructure(new SmeltingFurnace(plugin));
            registerStructure(new OreWasher(plugin));
            registerStructure(new OreSifter(plugin));
            registerStructure(new PressureMachine(plugin));

            MessageUtils.logInfo("成功注册 " + structures.size() + " 个多方块结构");

        } catch (Exception e) {
            MessageUtils.logError("注册默认多方块结构失败: " + e.getMessage());
            throw e;
        }
    }

    /**
     * 注册多方块结构
     */
    public boolean registerStructure(MultiblockStructure structure) {
        if (structure == null) {
            MessageUtils.logWarning("尝试注册空多方块结构");
            return false;
        }

        String structureId = structure.getStructureId();
        if (structures.containsKey(structureId)) {
            MessageUtils.logWarning("ID为 '" + structureId + "' 的多方块结构已存在");
            return false;
        }

        structures.put(structureId, structure);
        //MessageUtils.logInfo("注册多方块结构: " + structure.getDisplayName() +
                //" (ID: " + structureId + ")");
        return true;
    }

    /**
     * 取消注册结构
     */
    public boolean unregisterStructure(String structureId) {
        MultiblockStructure removed = structures.remove(structureId);
        if (removed != null) {
            MessageUtils.logInfo("已取消注册多方块结构: " + structureId);
            return true;
        }
        return false;
    }

    /**
     * 获取多方块结构
     */
    public Optional<MultiblockStructure> getStructure(String structureId) {
        return Optional.ofNullable(structures.get(structureId));
    }

    /**
     * 检查结构是否存在
     */
    public boolean hasStructure(String structureId) {
        return structures.containsKey(structureId);
    }

    /**
     * 处理玩家交互事件
     */
    public boolean handleInteraction(Player player, Location location, PlayerInteractEvent event) {
        if (!ValidationUtils.isValidPlayer(player) || !ValidationUtils.isValidLocation(location)) {
            return false;
        }

        // 检查所有已注册的结构
        for (MultiblockStructure structure : structures.values()) {
            try {
                if (structure.checkStructure(location)) {
                    event.setCancelled(true);
                    structure.onActivate(player, location, event); // 修复：传递正确的参数
                    return true;
                }
            } catch (Exception e) {
                MessageUtils.logError("Error checking multiblock structure " + structure.getStructureId() + ": " + e.getMessage());
            }
        }

        return false;
    }

    /**
     * 获取指定位置的多方块结构
     */
    public Optional<MultiblockStructure> getStructureAtLocation(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return Optional.empty();
        }

        for (MultiblockStructure structure : structures.values()) {
            try {
                if (structure.checkStructure(location)) {
                    return Optional.of(structure);
                }
            } catch (Exception e) {
                MessageUtils.logError("Error checking structure at location: " + e.getMessage());
            }
        }

        return Optional.empty();
    }

    /**
     * 获取所有已注册的结构
     */
    public Map<String, MultiblockStructure> getAllStructures() {
        return new HashMap<>(structures);
    }

    /**
     * 获取已注册结构数量
     */
    public int getRegisteredStructureCount() {
        return structures.size();
    }

    /**
     * 清空所有结构
     */
    public void clearAllStructures() {
        structures.clear();
        MessageUtils.logDebug("Cleared all multiblock structures");
    }

    /**
     * 重新加载多方块管理器
     */
    public void reload() {
        clearAllStructures();
        registerDefaultStructures();
        MessageUtils.logDebug("Reloaded multiblock manager");
    }

    /**
     * 获取统计信息
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("total_structures", structures.size());

        Map<String, Object> structureInfo = new HashMap<>();
        for (MultiblockStructure structure : structures.values()) {
            structureInfo.put(structure.getStructureId(), structure.getStructureInfo());
        }
        stats.put("structures", structureInfo);

        return stats;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\base\Recipe.java
==================================================
package cn.fandmc.flametech.recipes.base;

import org.bukkit.inventory.ItemStack;
import java.util.Map;

/**
 * 配方基类
 */
public abstract class Recipe {

    protected final String recipeId;
    protected final String displayName;
    protected final ItemStack result;
    protected final String multiblockId;
    protected final int unlockLevel;
    protected final RecipeType type;

    public Recipe(String recipeId, String displayName, ItemStack result,
                  String multiblockId, RecipeType type, int unlockLevel) {
        this.recipeId = recipeId;
        this.displayName = displayName;
        this.result = result != null ? result.clone() : null;
        this.multiblockId = multiblockId;
        this.type = type;
        this.unlockLevel = unlockLevel;
    }

    public Recipe(String recipeId, String displayName, ItemStack result,
                  String multiblockId, RecipeType type) {
        this(recipeId, displayName, result, multiblockId, type, 0);
    }

    /**
     * 检查输入是否匹配此配方
     */
    public abstract boolean matches(Map<Integer, ItemStack> inputs);

    /**
     * 获取配方所需的材料
     */
    public abstract Map<Integer, ItemStack> getIngredients();

    /**
     * 验证配方是否有效
     */
    public boolean isValid() {
        return recipeId != null && !recipeId.isEmpty() &&
                displayName != null && !displayName.isEmpty() &&
                result != null &&
                multiblockId != null && !multiblockId.isEmpty() &&
                type != null;
    }

    // Getter methods
    public String getRecipeId() { return recipeId; }
    public String getDisplayName() { return displayName; }
    public ItemStack getResult() { return result != null ? result.clone() : null; }
    public String getMultiblockId() { return multiblockId; }
    public int getUnlockLevel() { return unlockLevel; }
    public RecipeType getType() { return type; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Recipe recipe = (Recipe) obj;
        return recipeId.equals(recipe.recipeId);
    }

    @Override
    public int hashCode() {
        return recipeId.hashCode();
    }

    @Override
    public String toString() {
        return "Recipe{" +
                "id='" + recipeId + '\'' +
                ", name='" + displayName + '\'' +
                ", type=" + type +
                ", multiblock='" + multiblockId + '\'' +
                '}';
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\base\RecipeType.java
==================================================
package cn.fandmc.flametech.recipes.base;

/**
 * 配方类型枚举
 */
public enum RecipeType {
    SHAPED("有序合成", "gui.recipe_types.shaped"),
    SHAPELESS("无序合成", "gui.recipe_types.shapeless"),
    SMELTING("熔炼", "gui.recipe_types.smelting"),
    CRUSHING("粉碎", "gui.recipe_types.crushing"),
    COMPRESSING("压缩", "gui.recipe_types.compressing"),
    CUSTOM("自定义", "gui.recipe_types.custom");

    private final String displayName;
    private final String langKey;

    RecipeType(String displayName, String langKey) {
        this.displayName = displayName;
        this.langKey = langKey;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getLangKey() {
        return langKey;
    }

    /**
     * 根据名称获取配方类型
     */
    public static RecipeType fromName(String name) {
        for (RecipeType type : values()) {
            if (type.name().equalsIgnoreCase(name)) {
                return type;
            }
        }
        return CUSTOM;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\base\ShapedRecipe.java
==================================================
package cn.fandmc.flametech.recipes.base;

import cn.fandmc.flametech.utils.ItemUtils;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;

/**
 * 有序配方
 */
public class ShapedRecipe extends Recipe {

    private final String[] pattern;
    private final Map<Character, ItemStack> ingredients;
    private final int width;
    private final int height;

    public ShapedRecipe(String recipeId, String displayName, ItemStack result,
                        String multiblockId, String[] pattern,
                        Map<Character, ItemStack> ingredients, int unlockLevel) {
        super(recipeId, displayName, result, multiblockId, RecipeType.SHAPED, unlockLevel);

        this.pattern = pattern != null ? pattern.clone() : new String[0];
        this.ingredients = ingredients != null ? new HashMap<>(ingredients) : new HashMap<>();
        this.height = this.pattern.length;
        this.width = this.pattern.length > 0 ? this.pattern[0].length() : 0;

        validatePattern();
    }

    public ShapedRecipe(String recipeId, String displayName, ItemStack result,
                        String multiblockId, String[] pattern,
                        Map<Character, ItemStack> ingredients) {
        this(recipeId, displayName, result, multiblockId, pattern, ingredients, 0);
    }

    private void validatePattern() {
        if (pattern.length == 0) {
            throw new IllegalArgumentException("Pattern cannot be empty");
        }

        if (pattern.length > 3) {
            throw new IllegalArgumentException("Pattern height cannot exceed 3");
        }

        for (String row : pattern) {
            if (row.length() > 3) {
                throw new IllegalArgumentException("Pattern width cannot exceed 3");
            }
        }
    }

    @Override
    public boolean matches(Map<Integer, ItemStack> inputs) {
        // 尝试在3x3网格中的所有可能位置匹配图案
        for (int startRow = 0; startRow <= 3 - height; startRow++) {
            for (int startCol = 0; startCol <= 3 - width; startCol++) {
                if (matchesAt(inputs, startRow, startCol)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean matchesAt(Map<Integer, ItemStack> inputs, int startRow, int startCol) {
        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 3; col++) {
                int slot = row * 3 + col;
                ItemStack input = inputs.get(slot);

                boolean inPattern = row >= startRow && row < startRow + height &&
                        col >= startCol && col < startCol + width;

                if (inPattern) {
                    char patternChar = pattern[row - startRow].charAt(col - startCol);
                    ItemStack required = ingredients.get(patternChar);

                    if (patternChar == ' ') {
                        // 空格表示此位置应该为空
                        if (!ItemUtils.isAirOrNull(input)) {
                            return false;
                        }
                    } else if (!itemMatches(input, required)) {
                        return false;
                    }
                } else {
                    // 图案外的位置应该为空
                    if (!ItemUtils.isAirOrNull(input)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private boolean itemMatches(ItemStack input, ItemStack required) {
        if (required == null) {
            return ItemUtils.isAirOrNull(input);
        }

        if (ItemUtils.isAirOrNull(input)) {
            return false;
        }

        return input.getType() == required.getType() &&
                input.getAmount() >= required.getAmount() &&
                ItemUtils.isSimilar(input, required);
    }

    @Override
    public Map<Integer, ItemStack> getIngredients() {
        Map<Integer, ItemStack> result = new HashMap<>();

        for (int row = 0; row < height; row++) {
            for (int col = 0; col < width; col++) {
                char patternChar = pattern[row].charAt(col);
                if (patternChar != ' ' && ingredients.containsKey(patternChar)) {
                    int slot = row * 3 + col;
                    result.put(slot, ItemUtils.cloneSafely(ingredients.get(patternChar)));
                }
            }
        }

        return result;
    }

    @Override
    public boolean isValid() {
        if (!super.isValid()) {
            return false;
        }

        if (pattern.length == 0 || width == 0) {
            return false;
        }

        // 检查所有模式字符都有对应的材料
        for (String row : pattern) {
            for (char c : row.toCharArray()) {
                if (c != ' ' && !ingredients.containsKey(c)) {
                    return false;
                }
            }
        }

        return true;
    }

    // Getter methods
    public String[] getPattern() {
        return pattern.clone();
    }

    public Map<Character, ItemStack> getIngredientMap() {
        Map<Character, ItemStack> result = new HashMap<>();
        for (Map.Entry<Character, ItemStack> entry : ingredients.entrySet()) {
            result.put(entry.getKey(), ItemUtils.cloneSafely(entry.getValue()));
        }
        return result;
    }

    public int getWidth() { return width; }
    public int getHeight() { return height; }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\impl\ToolRecipes.java
==================================================
package cn.fandmc.flametech.recipes.impl;

import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.recipes.manager.RecipeManager;
import cn.fandmc.flametech.recipes.registrar.RecipeRegistrar;
import cn.fandmc.flametech.recipes.impl.tool.*;
import cn.fandmc.flametech.utils.MessageUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 工具配方管理器 - 负责注册所有工具配方
 */
public final class ToolRecipes {

    private static final List<RecipeRegistrar> RECIPE_REGISTRARS = new ArrayList<>();

    static {
        RECIPE_REGISTRARS.add(new ExplosivePickaxeRecipe());
        RECIPE_REGISTRARS.add(new SmeltingPickaxeRecipe());
        RECIPE_REGISTRARS.add(new MagnetRecipe());
    }

    /**
     * 注册所有工具配方
     */
    public static void registerAll(RecipeManager recipeManager) {
        for (RecipeRegistrar registrar : RECIPE_REGISTRARS) {
            registrar.register(recipeManager);
        }
    }

    private ToolRecipes() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\impl\tool\ExplosivePickaxeRecipe.java
==================================================
package cn.fandmc.flametech.recipes.impl.tool;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.recipes.base.ShapedRecipe;
import cn.fandmc.flametech.recipes.manager.RecipeManager;
import cn.fandmc.flametech.recipes.registrar.RecipeRegistrar;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;

/**
 * 爆炸镐配方注册器
 */
public class ExplosivePickaxeRecipe implements RecipeRegistrar {

    private static final String[] PATTERN = {
            "ITI",
            " S ",
            " S "
    };

    private static final int UNLOCK_LEVEL = 15;

    @Override
    public boolean register(RecipeManager recipeManager) {
        Main plugin = Main.getInstance();

        // 创建爆炸镐物品
        ItemStack explosivePickaxe = plugin.getItemManager().createExplosivePickaxe();

        // 获取配方显示名称
        String displayName = plugin.getConfigManager().getLang(Messages.RECIPES_EXPLOSIVE_PICKAXE_NAME);

        // 定义材料映射
        Map<Character, ItemStack> ingredients = createIngredients();

        // 创建配方
        ShapedRecipe recipe = new ShapedRecipe(
                ItemKeys.ID_EXPLOSIVE_PICKAXE,
                displayName,
                explosivePickaxe,
                ItemKeys.ID_ENHANCED_CRAFTING_TABLE,
                PATTERN,
                ingredients,
                UNLOCK_LEVEL
        );

        return recipeManager.registerRecipe(recipe);
    }

    @Override
    public String getRecipeName() {
        try {
            return Main.getInstance().getConfigManager().getLang(Messages.RECIPES_EXPLOSIVE_PICKAXE_NAME);
        } catch (Exception e) {
            return "爆炸镐";
        }
    }

    /**
     * 创建配方材料映射
     */
    private Map<Character, ItemStack> createIngredients() {
        Map<Character, ItemStack> ingredients = new HashMap<>();
        ingredients.put('I', new ItemStack(Material.IRON_INGOT, 1));
        ingredients.put('T', new ItemStack(Material.TNT, 1));
        ingredients.put('S', new ItemStack(Material.STICK, 1));
        return ingredients;
    }

    /**
     * 获取配方图案
     */
    public static String[] getPattern() {
        return PATTERN.clone();
    }

    /**
     * 获取解锁等级
     */
    public static int getUnlockLevel() {
        return UNLOCK_LEVEL;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\impl\tool\MagnetRecipe.java
==================================================
package cn.fandmc.flametech.recipes.impl.tool;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.recipes.base.ShapedRecipe;
import cn.fandmc.flametech.recipes.manager.RecipeManager;
import cn.fandmc.flametech.recipes.registrar.RecipeRegistrar;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;

/**
 * 吸铁石配方注册器
 */
public class MagnetRecipe implements RecipeRegistrar {

    private static final String[] PATTERN = {
            "IMI",
            "RCR",
            "IMI"
    };

    private static final int UNLOCK_LEVEL = 10;

    @Override
    public boolean register(RecipeManager recipeManager) {
        Main plugin = Main.getInstance();

        // 创建吸铁石物品
        ItemStack magnet = plugin.getItemManager().createMagnet();

        // 获取配方显示名称
        String displayName = plugin.getConfigManager().getLang(Messages.RECIPES_MAGNET_NAME);

        // 定义材料映射
        Map<Character, ItemStack> ingredients = createIngredients();

        // 创建配方
        ShapedRecipe recipe = new ShapedRecipe(
                ItemKeys.ID_MAGNET,
                displayName,
                magnet,
                ItemKeys.ID_ENHANCED_CRAFTING_TABLE,
                PATTERN,
                ingredients,
                UNLOCK_LEVEL
        );

        return recipeManager.registerRecipe(recipe);
    }

    @Override
    public String getRecipeName() {
        try {
            return Main.getInstance().getConfigManager().getLang(Messages.RECIPES_MAGNET_NAME);
        } catch (Exception e) {
            return "吸铁石";
        }
    }

    /**
     * 创建配方材料映射
     * I = 铁锭, M = 磁石, R = 红石, C = 指南针
     */
    private Map<Character, ItemStack> createIngredients() {
        Map<Character, ItemStack> ingredients = new HashMap<>();
        ingredients.put('I', new ItemStack(Material.IRON_INGOT, 1));
        ingredients.put('M', new ItemStack(Material.LODESTONE, 1));
        ingredients.put('R', new ItemStack(Material.REDSTONE, 1));
        ingredients.put('C', new ItemStack(Material.COMPASS, 1));
        return ingredients;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\impl\tool\SmeltingPickaxeRecipe.java
==================================================
package cn.fandmc.flametech.recipes.impl.tool;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.constants.Messages;
import cn.fandmc.flametech.recipes.base.ShapedRecipe;
import cn.fandmc.flametech.recipes.manager.RecipeManager;
import cn.fandmc.flametech.recipes.registrar.RecipeRegistrar;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.HashMap;
import java.util.Map;

/**
 * 熔炼镐配方注册器
 */
public class SmeltingPickaxeRecipe implements RecipeRegistrar {

    private static final String[] PATTERN = {
            "IFI",
            " S ",
            " S "
    };

    private static final int UNLOCK_LEVEL = 20;

    @Override
    public boolean register(RecipeManager recipeManager) {
        Main plugin = Main.getInstance();

        ItemStack smeltingPickaxe = plugin.getItemManager().createSmeltingPickaxe();

        String displayName = plugin.getConfigManager().getLang(Messages.RECIPES_SMELTING_PICKAXE_NAME);

        Map<Character, ItemStack> ingredients = createIngredients();

        ShapedRecipe recipe = new ShapedRecipe(
                ItemKeys.ID_SMELTING_PICKAXE,
                displayName,
                smeltingPickaxe,
                ItemKeys.ID_ENHANCED_CRAFTING_TABLE,
                PATTERN,
                ingredients,
                UNLOCK_LEVEL
        );

        return recipeManager.registerRecipe(recipe);

    }

    @Override
    public String getRecipeName() {
        try {
            return Main.getInstance().getConfigManager().getLang(Messages.RECIPES_SMELTING_PICKAXE_NAME);
        } catch (Exception e) {
            return "熔炼镐";
        }
    }

    /**
     * 创建配方材料映射
     */
    private Map<Character, ItemStack> createIngredients() {
        Map<Character, ItemStack> ingredients = new HashMap<>();
        ingredients.put('I', new ItemStack(Material.IRON_INGOT, 1));
        ingredients.put('F', new ItemStack(Material.FURNACE, 1));
        ingredients.put('S', new ItemStack(Material.STICK, 1));
        return ingredients;
    }

    /**
     * 获取配方图案
     */
    public static String[] getPattern() {
        return PATTERN.clone();
    }

    /**
     * 获取解锁等级
     */
    public static int getUnlockLevel() {
        return UNLOCK_LEVEL;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\manager\RecipeManager.java
==================================================
package cn.fandmc.flametech.recipes.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.recipes.base.RecipeType;
import cn.fandmc.flametech.recipes.impl.ToolRecipes;
import cn.fandmc.flametech.utils.MessageUtils;
import org.bukkit.inventory.ItemStack;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * 配方管理器
 */
public class RecipeManager {

    private final Main plugin;
    private final Map<String, Recipe> recipes = new ConcurrentHashMap<>();
    private final Map<String, List<Recipe>> recipesByMultiblock = new ConcurrentHashMap<>();
    private final Map<RecipeType, List<Recipe>> recipesByType = new ConcurrentHashMap<>();

    public RecipeManager(Main plugin) {
        this.plugin = plugin;
    }

    /**
     * 注册默认配方
     */
    public void registerDefaultRecipes() {
        try {
            ToolRecipes.registerAll(this);
            MessageUtils.logInfo("注册了 " + recipes.size() + " 个配方");
        } catch (Exception e) {
            MessageUtils.logError("注册默认配方失败: " + e.getMessage());
            throw e;
        }
    }

    /**
     * 注册配方
     */
    public boolean registerRecipe(Recipe recipe) {
        if (recipe == null) {
            MessageUtils.logWarning("尝试注册空配方");
            return false;
        }

        if (!recipe.isValid()) {
            MessageUtils.logWarning("尝试注册无效的配方: " + recipe.getRecipeId());
            return false;
        }

        String recipeId = recipe.getRecipeId();
        if (recipes.containsKey(recipeId)) {
            MessageUtils.logWarning("ID为 '" + recipeId + "' 的配方已存在");
            return false;
        }

        if (!plugin.getMultiblockManager().hasStructure(recipe.getMultiblockId())) {
            MessageUtils.logWarning("ID为 " + recipeId + " 的配方绑定了无效的多方快结构ID: " + recipe.getMultiblockId());
        }

        recipes.put(recipeId, recipe);

        recipesByMultiblock.computeIfAbsent(recipe.getMultiblockId(), k -> new ArrayList<>())
                .add(recipe);

        recipesByType.computeIfAbsent(recipe.getType(), k -> new ArrayList<>())
                .add(recipe);

        //MessageUtils.logInfo("注册配方: " + recipe.getDisplayName() +
               // " (ID: " + recipeId + ", 多方块结构: " + recipe.getMultiblockId() + ")");
        return true;
    }

    /**
     * 取消注册配方
     */
    public boolean unregisterRecipe(String recipeId) {
        Recipe removed = recipes.remove(recipeId);
        if (removed != null) {
            // 从分组中移除
            recipesByMultiblock.getOrDefault(removed.getMultiblockId(), new ArrayList<>())
                    .remove(removed);
            recipesByType.getOrDefault(removed.getType(), new ArrayList<>())
                    .remove(removed);

            MessageUtils.logDebug("Unregistered recipe: " + recipeId);
            return true;
        }
        return false;
    }

    /**
     * 获取配方
     */
    public Optional<Recipe> getRecipe(String recipeId) {
        return Optional.ofNullable(recipes.get(recipeId));
    }

    /**
     * 获取指定多方块的所有配方
     */
    public List<Recipe> getRecipesForMultiblock(String multiblockId) {
        return new ArrayList<>(recipesByMultiblock.getOrDefault(multiblockId, new ArrayList<>()));
    }

    /**
     * 获取指定类型的所有配方
     */
    public List<Recipe> getRecipesByType(RecipeType type) {
        return new ArrayList<>(recipesByType.getOrDefault(type, new ArrayList<>()));
    }

    /**
     * 查找匹配的配方
     */
    public Optional<Recipe> findMatchingRecipe(String multiblockId, Map<Integer, ItemStack> inputs) {
        List<Recipe> possibleRecipes = getRecipesForMultiblock(multiblockId);

        for (Recipe recipe : possibleRecipes) {
            try {
                if (recipe.matches(inputs)) {
                    return Optional.of(recipe);
                }
            } catch (Exception e) {
                MessageUtils.logWarning("Error checking recipe match for " + recipe.getRecipeId() + ": " + e.getMessage());
            }
        }

        return Optional.empty();
    }

    /**
     * 获取所有配方
     */
    public Collection<Recipe> getAllRecipes() {
        return new ArrayList<>(recipes.values());
    }

    /**
     * 根据关键词搜索配方
     */
    public List<Recipe> searchRecipes(String keyword) {
        if (keyword == null || keyword.trim().isEmpty()) {
            return new ArrayList<>(recipes.values());
        }

        String lowerKeyword = keyword.toLowerCase();
        return recipes.values().stream()
                .filter(recipe -> recipe.getDisplayName().toLowerCase().contains(lowerKeyword) ||
                        recipe.getRecipeId().toLowerCase().contains(lowerKeyword))
                .collect(Collectors.toList());
    }

    /**
     * 获取配方统计信息
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("total_recipes", recipes.size());
        stats.put("recipes_by_type", recipesByType.entrySet().stream()
                .collect(Collectors.toMap(
                        entry -> entry.getKey().name(),
                        entry -> entry.getValue().size()
                )));
        stats.put("recipes_by_multiblock", recipesByMultiblock.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        entry -> entry.getValue().size()
                )));
        return stats;
    }

    /**
     * 验证所有配方
     */
    public List<String> validateAllRecipes() {
        List<String> errors = new ArrayList<>();

        for (Recipe recipe : recipes.values()) {
            try {
                if (!recipe.isValid()) {
                    errors.add("Invalid recipe: " + recipe.getRecipeId());
                }
            } catch (Exception e) {
                errors.add("Error validating recipe " + recipe.getRecipeId() + ": " + e.getMessage());
            }
        }

        return errors;
    }

    /**
     * 清空所有配方
     */
    public void clearAllRecipes() {
        recipes.clear();
        recipesByMultiblock.clear();
        recipesByType.clear();
        MessageUtils.logDebug("Cleared all recipes");
    }

    /**
     * 重新加载配方
     */
    public void reload() {
        clearAllRecipes();
        registerDefaultRecipes();
        MessageUtils.logDebug("Reloaded recipe manager");
    }

    /**
     * 获取已注册配方数量
     */
    public int getRecipeCount() {
        return recipes.size();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\recipes\registrar\RecipeRegistrar.java
==================================================
package cn.fandmc.flametech.recipes.registrar;

import cn.fandmc.flametech.recipes.manager.RecipeManager;

/**
 * 配方注册器接口
 */
public interface RecipeRegistrar {

    /**
     * 注册配方到配方管理器
     * @param recipeManager 配方管理器
     * @return 是否注册成功
     */
    boolean register(RecipeManager recipeManager);

    /**
     * 获取配方名称（用于日志）
     * @return 配方名称
     */
    String getRecipeName();
}


==================================================
路径：.\java\cn\fandmc\flametech\unlock\Unlockable.java
==================================================
package cn.fandmc.flametech.unlock;

/**
 * 可解锁内容接口
 * 所有需要解锁的内容（配方、多方块结构等）都应该实现此接口
 */
public interface Unlockable {

    /**
     * 获取解锁ID
     * @return 唯一的解锁标识符
     */
    String getUnlockId();

    /**
     * 获取解锁所需的经验等级
     * @return 经验等级，0表示不需要解锁
     */
    int getUnlockLevel();

    /**
     * 获取解锁类别
     * @return 类别名称（如 "recipe", "multiblock" 等）
     */
    String getUnlockCategory();

    /**
     * 获取显示名称
     * @return 用于显示的名称
     */
    String getDisplayName();

    /**
     * 获取解锁描述
     * @return 描述信息（可选）
     */
    default String getDescription() {
        return "";
    }

    /**
     * 是否需要解锁
     * @return 如果需要解锁返回true
     */
    default boolean requiresUnlock() {
        return getUnlockLevel() > 0;
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\unlock\data\PlayerUnlocks.java
==================================================
package cn.fandmc.flametech.unlock.data;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

/**
 * 玩家解锁数据
 */
public class PlayerUnlocks {

    private final UUID playerId;
    private final Set<String> unlockedItems = new HashSet<>();
    private long lastSaveTime;

    public PlayerUnlocks(UUID playerId) {
        this.playerId = playerId;
        this.lastSaveTime = System.currentTimeMillis();
    }

    /**
     * 解锁物品
     */
    public boolean unlock(String itemId) {
        if (itemId == null || itemId.isEmpty()) {
            return false;
        }

        boolean added = unlockedItems.add(itemId);
        if (added) {
            updateSaveTime();
        }
        return added;
    }

    /**
     * 检查物品是否已解锁
     */
    public boolean isUnlocked(String itemId) {
        return itemId != null && unlockedItems.contains(itemId);
    }

    /**
     * 获取所有已解锁的物品
     */
    public Set<String> getUnlockedItems() {
        return new HashSet<>(unlockedItems);
    }

    /**
     * 获取已解锁物品数量
     */
    public int getUnlockedCount() {
        return unlockedItems.size();
    }

    /**
     * 批量添加解锁物品
     */
    public void addUnlockedItems(Set<String> items) {
        if (items != null && !items.isEmpty()) {
            unlockedItems.addAll(items);
            updateSaveTime();
        }
    }

    /**
     * 移除解锁物品（用于重置）
     */
    public boolean removeUnlock(String itemId) {
        if (itemId == null || itemId.isEmpty()) {
            return false;
        }

        boolean removed = unlockedItems.remove(itemId);
        if (removed) {
            updateSaveTime();
        }
        return removed;
    }

    /**
     * 清空所有解锁
     */
    public void clearAllUnlocks() {
        if (!unlockedItems.isEmpty()) {
            unlockedItems.clear();
            updateSaveTime();
        }
    }

    /**
     * 检查指定类别的解锁进度
     */
    public int getUnlockedCountByCategory(String category, Set<String> categoryItems) {
        if (category == null || categoryItems == null) {
            return 0;
        }

        return (int) categoryItems.stream()
                .filter(unlockedItems::contains)
                .count();
    }

    private void updateSaveTime() {
        this.lastSaveTime = System.currentTimeMillis();
    }

    public UUID getPlayerId() { return playerId; }
    public long getLastSaveTime() { return lastSaveTime; }

    @Override
    public String toString() {
        return String.format("PlayerUnlocks{player=%s, unlocked=%d}",
                playerId, unlockedItems.size());
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\unlock\data\UnlockResult.java
==================================================
package cn.fandmc.flametech.unlock.data;

/**
 * 解锁操作结果
 */
public class UnlockResult {

    public enum Status {
        SUCCESS,
        ALREADY_UNLOCKED,
        INSUFFICIENT_EXP,
        ITEM_NOT_FOUND,
        PLAYER_NOT_FOUND,
        ERROR
    }

    private final Status status;
    private final String message;
    private final int requiredExp;
    private final String itemId;

    public UnlockResult(Status status, String message) {
        this(status, message, 0, null);
    }

    public UnlockResult(Status status, String message, int requiredExp) {
        this(status, message, requiredExp, null);
    }

    public UnlockResult(Status status, String message, int requiredExp, String itemId) {
        this.status = status;
        this.message = message != null ? message : "";
        this.requiredExp = Math.max(0, requiredExp);
        this.itemId = itemId;
    }

    public boolean isSuccess() {
        return status == Status.SUCCESS;
    }

    public Status getStatus() { return status; }
    public String getMessage() { return message; }
    public int getRequiredExp() { return requiredExp; }
    public String getItemId() { return itemId; }

    // 静态工厂方法
    public static UnlockResult success(String itemId) {
        return new UnlockResult(Status.SUCCESS, "success", 0, itemId);
    }

    public static UnlockResult alreadyUnlocked(String itemId) {
        return new UnlockResult(Status.ALREADY_UNLOCKED, "already_unlocked", 0, itemId);
    }

    public static UnlockResult insufficientExp(int required, String itemId) {
        return new UnlockResult(Status.INSUFFICIENT_EXP, "insufficient_exp", required, itemId);
    }

    public static UnlockResult itemNotFound(String itemId) {
        return new UnlockResult(Status.ITEM_NOT_FOUND, "item_not_found", 0, itemId);
    }

    public static UnlockResult playerNotFound() {
        return new UnlockResult(Status.PLAYER_NOT_FOUND, "player_not_found");
    }

    public static UnlockResult error(String message) {
        return new UnlockResult(Status.ERROR, message);
    }

    @Override
    public String toString() {
        return String.format("UnlockResult{status=%s, message='%s', item='%s'}",
                status, message, itemId);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\unlock\data\UnlockableItem.java
==================================================
package cn.fandmc.flametech.unlock.data;

/**
 * 可解锁物品数据类
 */
public class UnlockableItem {

    private final String itemId;
    private final int requiredExp;
    private final String category;
    private final String description;

    public UnlockableItem(String itemId, int requiredExp) {
        this(itemId, requiredExp, "default", "");
    }

    public UnlockableItem(String itemId, int requiredExp, String category) {
        this(itemId, requiredExp, category, "");
    }

    public UnlockableItem(String itemId, int requiredExp, String category, String description) {
        this.itemId = itemId;
        this.requiredExp = Math.max(0, requiredExp);
        this.category = category != null ? category : "default";
        this.description = description != null ? description : "";
    }

    public String getItemId() { return itemId; }
    public int getRequiredExp() { return requiredExp; }
    public String getCategory() { return category; }
    public String getDescription() { return description; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        UnlockableItem that = (UnlockableItem) obj;
        return itemId.equals(that.itemId);
    }

    @Override
    public int hashCode() {
        return itemId.hashCode();
    }

    @Override
    public String toString() {
        return String.format("UnlockableItem{id='%s', exp=%d, category='%s'}",
                itemId, requiredExp, category);
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\unlock\manager\UnlockManager.java
==================================================
package cn.fandmc.flametech.unlock.manager;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.multiblock.base.MultiblockStructure;
import cn.fandmc.flametech.recipes.base.Recipe;
import cn.fandmc.flametech.unlock.data.PlayerUnlocks;
import cn.fandmc.flametech.unlock.data.UnlockResult;
import cn.fandmc.flametech.unlock.data.UnlockableItem;
import cn.fandmc.flametech.utils.MessageUtils;
import cn.fandmc.flametech.utils.ValidationUtils;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 解锁管理器
 */
public class UnlockManager {

    private final Main plugin;
    private final Map<UUID, PlayerUnlocks> playerUnlocks = new ConcurrentHashMap<>();
    private final Map<String, UnlockableItem> unlockableItems = new ConcurrentHashMap<>();

    private File unlocksFile;
    private FileConfiguration unlocksConfig;

    public UnlockManager(Main plugin) {
        this.plugin = plugin;
        initializeDataFile();
    }

    private void initializeDataFile() {
        unlocksFile = new File(plugin.getDataFolder(), "player_unlocks.yml");
        if (!unlocksFile.exists()) {
            try {
                unlocksFile.createNewFile();
            } catch (IOException e) {
                MessageUtils.logError("Failed to create player unlocks file: " + e.getMessage());
            }
        }
        unlocksConfig = YamlConfiguration.loadConfiguration(unlocksFile);
        loadPlayerData();
    }

    /**
     * 注册默认可解锁物品
     * 现在改为从已注册的配方和多方块结构中动态加载
     */
    public void registerDefaultUnlockables() {
        try {
            unlockableItems.clear();

            // 从配方管理器加载所有配方的解锁信息
            loadRecipeUnlockables();

            // 从多方块管理器加载所有结构的解锁信息
            loadMultiblockUnlockables();

            MessageUtils.logInfo("动态加载了 " + unlockableItems.size() + " 个可解锁物品");

        } catch (Exception e) {
            MessageUtils.logError("注册默认可解锁物品失败: " + e.getMessage());
            throw e;
        }
    }

    /**
     * 从配方管理器加载配方解锁项
     */
    private void loadRecipeUnlockables() {
        Collection<Recipe> allRecipes = plugin.getRecipeManager().getAllRecipes();

        for (Recipe recipe : allRecipes) {
            if (recipe.getUnlockLevel() > 0) {
                String unlockId = "recipe." + recipe.getRecipeId();
                UnlockableItem unlockable = new UnlockableItem(
                        unlockId,
                        recipe.getUnlockLevel(),
                        "recipe",
                        recipe.getDisplayName() + " 配方"
                );

                registerUnlockable(unlockable);
                MessageUtils.logDebug("注册配方解锁: " + unlockId + " (等级: " + recipe.getUnlockLevel() + ")");
            }
        }
    }

    /**
     * 从多方块管理器加载结构解锁项
     */
    private void loadMultiblockUnlockables() {
        Map<String, MultiblockStructure> allStructures = plugin.getMultiblockManager().getAllStructures();

        for (Map.Entry<String, MultiblockStructure> entry : allStructures.entrySet()) {
            MultiblockStructure structure = entry.getValue();
            if (structure.getUnlockLevel() > 0) {
                String unlockId = "multiblock." + structure.getStructureId();
                UnlockableItem unlockable = new UnlockableItem(
                        unlockId,
                        structure.getUnlockLevel(),
                        "multiblock",
                        structure.getDisplayName()
                );

                registerUnlockable(unlockable);

                MessageUtils.logDebug("注册多方块解锁: " + unlockId + " (等级: " + structure.getUnlockLevel() + ")");

            }
        }
    }

    /**
     * 注册可解锁物品
     */
    public void registerUnlockable(UnlockableItem item) {
        if (item == null) {
            MessageUtils.logWarning("尝试注册空可解锁物品");
            return;
        }

        String itemId = item.getItemId();
        if (unlockableItems.containsKey(itemId)) {
            MessageUtils.logWarning("ID为 '" + itemId + "' 的可解锁物品已存在");
            return;
        }

        unlockableItems.put(itemId, item);
    }

    /**
     * 检查玩家是否已解锁指定物品
     */
    public boolean isUnlocked(Player player, String itemId) {
        if (!ValidationUtils.isValidPlayer(player) || !ValidationUtils.isValidString(itemId)) {
            return false;
        }

        PlayerUnlocks unlocks = getOrCreatePlayerUnlocks(player.getUniqueId());
        return unlocks.isUnlocked(itemId);
    }

    /**
     * 检查玩家是否可以解锁指定物品
     */
    public boolean canUnlock(Player player, String itemId) {
        if (!ValidationUtils.isValidPlayer(player) || !ValidationUtils.isValidString(itemId)) {
            return false;
        }

        UnlockableItem item = unlockableItems.get(itemId);
        if (item == null) {
            return true; // 如果没有注册解锁需求，默认可解锁
        }

        return player.getLevel() >= item.getRequiredExp();
    }

    /**
     * 尝试解锁物品
     */
    public UnlockResult unlock(Player player, String itemId) {
        if (!ValidationUtils.isValidPlayer(player)) {
            return UnlockResult.playerNotFound();
        }

        if (!ValidationUtils.isValidString(itemId)) {
            return UnlockResult.itemNotFound(itemId);
        }

        // 检查是否已解锁
        if (isUnlocked(player, itemId)) {
            return UnlockResult.alreadyUnlocked(itemId);
        }

        UnlockableItem item = unlockableItems.get(itemId);
        if (item == null) {
            // 如果没有注册，直接解锁
            PlayerUnlocks unlocks = getOrCreatePlayerUnlocks(player.getUniqueId());
            unlocks.unlock(itemId);
            savePlayerDataAsync(player.getUniqueId());
            return UnlockResult.success(itemId);
        }

        // 检查经验是否足够
        if (player.getLevel() < item.getRequiredExp()) {
            return UnlockResult.insufficientExp(item.getRequiredExp(), itemId);
        }

        try {
            // 扣除经验
            player.setLevel(player.getLevel() - item.getRequiredExp());

            // 添加解锁
            PlayerUnlocks unlocks = getOrCreatePlayerUnlocks(player.getUniqueId());
            unlocks.unlock(itemId);

            // 异步保存数据
            savePlayerDataAsync(player.getUniqueId());

            return UnlockResult.success(itemId);

        } catch (Exception e) {
            MessageUtils.logError("Error during unlock process: " + e.getMessage());
            return UnlockResult.error("unlock_error");
        }
    }

    /**
     * 获取物品的解锁经验需求
     */
    public int getRequiredExp(String itemId) {
        UnlockableItem item = unlockableItems.get(itemId);
        return item != null ? item.getRequiredExp() : 0;
    }

    /**
     * 获取或创建玩家解锁数据
     */
    private PlayerUnlocks getOrCreatePlayerUnlocks(UUID playerId) {
        return playerUnlocks.computeIfAbsent(playerId, PlayerUnlocks::new);
    }

    /**
     * 加载所有玩家数据
     */
    private void loadPlayerData() {
        if (unlocksConfig == null) {
            return;
        }

        try {
            for (String uuidStr : unlocksConfig.getKeys(false)) {
                UUID uuid = UUID.fromString(uuidStr);
                List<String> unlockedItems = unlocksConfig.getStringList(uuidStr);

                PlayerUnlocks unlocks = new PlayerUnlocks(uuid);
                unlocks.addUnlockedItems(new HashSet<>(unlockedItems));

                playerUnlocks.put(uuid, unlocks);
            }

            MessageUtils.logInfo("加载了 " + playerUnlocks.size() + " 个玩家的数据");

        } catch (Exception e) {
            MessageUtils.logError("Error loading player unlock data: " + e.getMessage());
        }
    }

    /**
     * 保存指定玩家的数据
     */
    private void savePlayerData(UUID playerId) {
        PlayerUnlocks unlocks = playerUnlocks.get(playerId);
        if (unlocks != null && unlocksConfig != null) {
            unlocksConfig.set(playerId.toString(), new ArrayList<>(unlocks.getUnlockedItems()));
            try {
                unlocksConfig.save(unlocksFile);
            } catch (IOException e) {
                MessageUtils.logError("Failed to save player unlock data: " + e.getMessage());
            }
        }
    }

    /**
     * 异步保存玩家数据
     */
    private void savePlayerDataAsync(UUID playerId) {
        plugin.getServer().getScheduler().runTaskAsynchronously(plugin, () -> savePlayerData(playerId));
    }

    /**
     * 保存所有玩家数据
     */
    public void saveAllData() {
        try {
            for (UUID playerId : playerUnlocks.keySet()) {
                savePlayerData(playerId);
            }
            MessageUtils.logInfo("已储存所有玩家数据");
        } catch (Exception e) {
            MessageUtils.logError("Error saving all player unlock data: " + e.getMessage());
        }
    }

    /**
     * 获取玩家的解锁统计
     */
    public Map<String, Object> getPlayerStatistics(Player player) {
        if (!ValidationUtils.isValidPlayer(player)) {
            return new HashMap<>();
        }

        PlayerUnlocks unlocks = playerUnlocks.get(player.getUniqueId());
        if (unlocks == null) {
            unlocks = new PlayerUnlocks(player.getUniqueId());
        }

        Map<String, Object> stats = new HashMap<>();
        stats.put("total_unlocked", unlocks.getUnlockedCount());
        stats.put("total_available", unlockableItems.size());

        // 计算每个类别的解锁进度
        Map<String, Map<String, Integer>> categoryProgress = new HashMap<>();
        Map<String, Integer> categoryTotals = new HashMap<>();
        Map<String, Integer> categoryUnlocked = new HashMap<>();

        // 统计每个类别的总数
        for (UnlockableItem item : unlockableItems.values()) {
            String category = item.getCategory();
            categoryTotals.put(category, categoryTotals.getOrDefault(category, 0) + 1);

            // 如果玩家已解锁，增加解锁计数
            if (unlocks.isUnlocked(item.getItemId())) {
                categoryUnlocked.put(category, categoryUnlocked.getOrDefault(category, 0) + 1);
            }
        }

        // 组合统计数据
        for (String category : categoryTotals.keySet()) {
            Map<String, Integer> progress = new HashMap<>();
            progress.put("total", categoryTotals.get(category));
            progress.put("unlocked", categoryUnlocked.getOrDefault(category, 0));
            categoryProgress.put(category, progress);
        }

        stats.put("by_category", categoryProgress);

        return stats;
    }

    /**
     * 重置玩家的所有解锁
     */
    public boolean resetPlayerUnlocks(UUID playerId) {
        PlayerUnlocks unlocks = playerUnlocks.get(playerId);
        if (unlocks != null) {
            unlocks.clearAllUnlocks();
            savePlayerDataAsync(playerId);
            return true;
        }
        return false;
    }

    /**
     * 获取所有可解锁物品
     */
    public Map<String, UnlockableItem> getAllUnlockableItems() {
        return new HashMap<>(unlockableItems);
    }

    /**
     * 重新加载解锁管理器
     */
    public void reload() {
        // 保存当前数据
        saveAllData();

        // 清空缓存
        playerUnlocks.clear();
        unlockableItems.clear();

        // 重新加载
        initializeDataFile();
        registerDefaultUnlockables();

        MessageUtils.logInfo("Reloaded unlock manager");
    }

    /**
     * 刷新解锁项（当配方或多方块结构变化时调用）
     */
    public void refreshUnlockables() {
        unlockableItems.clear();
        registerDefaultUnlockables();
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\BookUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.constants.ItemKeys;
import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

/**
 * 书籍相关工具类
 */
public final class BookUtils {

    private static final NamespacedKey GUIDE_BOOK_KEY = new NamespacedKey(Main.getInstance(), ItemKeys.FLAME_TECH_GUIDE);

    /**
     * 创建指南书
     */
    public static ItemStack createGuideBook() {
        return createGuideBook("main");
    }

    /**
     * 创建指向特定GUI的指南书
     */
    public static ItemStack createGuideBook(String targetGUI) {
        Main plugin = Main.getInstance();

        String displayName = plugin.getConfigManager().getLang("guide_book.display_name");
        java.util.List<String> lore = plugin.getConfigManager().getStringList("guide_book.lore");

        return new ItemBuilder(Material.ENCHANTED_BOOK)
                .displayName(displayName)
                .lore(lore)
                .nbt(ItemKeys.FLAME_TECH_GUIDE, targetGUI)
                .glow()
                .build();
    }

    /**
     * 检查物品是否为指南书
     */
    public static boolean isGuideBook(ItemStack item) {
        if (ItemUtils.isAirOrNull(item) || item.getType() != Material.ENCHANTED_BOOK) {
            return false;
        }

        return ItemUtils.hasCustomNBT(item, ItemKeys.FLAME_TECH_GUIDE);
    }

    private BookUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\FileUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

/**
 * 文件操作工具类
 */
public final class FileUtils {

    /**
     * 安全地创建文件
     */
    public static boolean createFileIfNotExists(File file) {
        if (file == null) {
            return false;
        }

        try {
            if (!file.exists()) {
                // 确保父目录存在
                File parentDir = file.getParentFile();
                if (parentDir != null && !parentDir.exists()) {
                    parentDir.mkdirs();
                }

                return file.createNewFile();
            }
            return true;
        } catch (IOException e) {
            MessageUtils.logError("Failed to create file: " + file.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 安全地创建目录
     */
    public static boolean createDirectoryIfNotExists(File directory) {
        if (directory == null) {
            return false;
        }

        try {
            if (!directory.exists()) {
                return directory.mkdirs();
            }
            return true;
        } catch (Exception e) {
            MessageUtils.logError("Failed to create directory: " + directory.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 读取文件内容为字符串
     */
    public static String readFileToString(File file) {
        if (file == null || !file.exists() || !file.isFile()) {
            return null;
        }

        try {
            return Files.readString(file.toPath(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            MessageUtils.logError("Failed to read file: " + file.getPath() + " - " + e.getMessage());
            return null;
        }
    }

    /**
     * 读取文件内容为行列表
     */
    public static List<String> readFileToLines(File file) {
        if (file == null || !file.exists() || !file.isFile()) {
            return new ArrayList<>();
        }

        try {
            return Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            MessageUtils.logError("Failed to read file lines: " + file.getPath() + " - " + e.getMessage());
            return new ArrayList<>();
        }
    }

    /**
     * 将字符串写入文件
     */
    public static boolean writeStringToFile(File file, String content) {
        if (file == null || content == null) {
            return false;
        }

        try {
            // 确保父目录存在
            createDirectoryIfNotExists(file.getParentFile());

            Files.writeString(file.toPath(), content, StandardCharsets.UTF_8);
            return true;
        } catch (IOException e) {
            MessageUtils.logError("Failed to write file: " + file.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 将行列表写入文件
     */
    public static boolean writeLinesToFile(File file, List<String> lines) {
        if (file == null || lines == null) {
            return false;
        }

        try {
            // 确保父目录存在
            createDirectoryIfNotExists(file.getParentFile());

            Files.write(file.toPath(), lines, StandardCharsets.UTF_8);
            return true;
        } catch (IOException e) {
            MessageUtils.logError("Failed to write file lines: " + file.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 安全地删除文件
     */
    public static boolean deleteFile(File file) {
        if (file == null || !file.exists()) {
            return true;
        }

        try {
            return file.delete();
        } catch (Exception e) {
            MessageUtils.logError("Failed to delete file: " + file.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 复制文件
     */
    public static boolean copyFile(File source, File destination) {
        if (source == null || destination == null || !source.exists()) {
            return false;
        }

        try {
            // 确保目标目录存在
            createDirectoryIfNotExists(destination.getParentFile());

            Files.copy(source.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
            return true;
        } catch (IOException e) {
            MessageUtils.logError("Failed to copy file: " + source.getPath() + " to " + destination.getPath() + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * 获取文件大小（字节）
     */
    public static long getFileSize(File file) {
        if (file == null || !file.exists() || !file.isFile()) {
            return 0;
        }

        try {
            return Files.size(file.toPath());
        } catch (IOException e) {
            MessageUtils.logError("Failed to get file size: " + file.getPath() + " - " + e.getMessage());
            return 0;
        }
    }

    /**
     * 检查文件是否可读
     */
    public static boolean isReadable(File file) {
        return file != null && file.exists() && file.canRead();
    }

    /**
     * 检查文件是否可写
     */
    public static boolean isWritable(File file) {
        return file != null && file.exists() && file.canWrite();
    }

    /**
     * 获取插件数据目录下的文件
     */
    public static File getPluginFile(String relativePath) {
        return new File(Main.getInstance().getDataFolder(), relativePath);
    }

    /**
     * 创建备份文件
     */
    public static boolean createBackup(File originalFile) {
        if (originalFile == null || !originalFile.exists()) {
            return false;
        }

        String backupName = originalFile.getName() + ".backup." + System.currentTimeMillis();
        File backupFile = new File(originalFile.getParent(), backupName);

        return copyFile(originalFile, backupFile);
    }

    /**
     * 清理旧的备份文件（保留最新的几个）
     */
    public static void cleanupBackups(File directory, String filePrefix, int keepCount) {
        if (directory == null || !directory.exists() || !directory.isDirectory()) {
            return;
        }

        try {
            File[] backupFiles = directory.listFiles((dir, name) ->
                    name.startsWith(filePrefix + ".backup."));

            if (backupFiles != null && backupFiles.length > keepCount) {
                // 按修改时间排序
                java.util.Arrays.sort(backupFiles,
                        (f1, f2) -> Long.compare(f2.lastModified(), f1.lastModified()));

                // 删除多余的备份
                for (int i = keepCount; i < backupFiles.length; i++) {
                    deleteFile(backupFiles[i]);
                }
            }
        } catch (Exception e) {
            MessageUtils.logError("Failed to cleanup backups: " + e.getMessage());
        }
    }

    private FileUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\FoliaUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;
import com.tcoded.folialib.FoliaLib;
import com.tcoded.folialib.wrapper.task.WrappedTask;
import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.event.player.PlayerTeleportEvent;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

/**
 * Folia服务器兼容性工具类
 */
public final class FoliaUtils {

    private static FoliaLib foliaLib;
    private static boolean initialized = false;

    /**
     * 初始化FoliaLib
     */
    public static void initialize(Main plugin) {
        if (!initialized) {
            foliaLib = new FoliaLib(plugin);
            initialized = true;
        }
    }

    /**
     * 确保FoliaLib已初始化
     */
    private static void ensureInitialized() {
        if (!initialized || foliaLib == null) {
            throw new IllegalStateException("FoliaUtils not initialized! Call initialize() first.");
        }
    }

    /**
     * 在正确的线程上下文中运行任务
     * @param location 任务相关的位置（用于Folia区域调度）
     * @param task 要执行的任务
     */
    public static void runTask(Location location, Runnable task) {
        ensureInitialized();
        foliaLib.getScheduler().runAtLocation(location, wrappedTask -> task.run());
    }

    /**
     * 在实体所在区域运行任务
     * @param entity 实体
     * @param task 要执行的任务
     */
    public static void runTask(Entity entity, Runnable task) {
        ensureInitialized();
        foliaLib.getScheduler().runAtEntity(entity, wrappedTask -> task.run());
    }

    /**
     * 运行全局任务（仅用于特定操作，如世界时间、天气等）
     * @param task 要执行的任务
     */
    public static void runGlobalTask(Runnable task) {
        ensureInitialized();
        foliaLib.getScheduler().runNextTick(wrappedTask -> task.run());
    }

    /**
     * 延迟运行任务
     * @param location 任务相关的位置
     * @param task 要执行的任务
     * @param delay 延迟时间（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runTaskLater(Location location, Runnable task, long delay) {
        ensureInitialized();
        return foliaLib.getScheduler().runAtLocationLater(location, task, delay);
    }

    /**
     * 在实体上延迟运行任务
     * @param entity 实体
     * @param task 要执行的任务
     * @param delay 延迟时间（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runTaskLater(Entity entity, Runnable task, long delay) {
        ensureInitialized();
        return foliaLib.getScheduler().runAtEntityLater(entity, task, delay);
    }

    /**
     * 延迟运行全局任务
     * @param task 要执行的任务
     * @param delay 延迟时间（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runGlobalTaskLater(Runnable task, long delay) {
        ensureInitialized();
        return foliaLib.getScheduler().runLater(task, delay);
    }

    /**
     * 运行重复任务
     * @param location 任务相关的位置
     * @param task 要执行的任务
     * @param delay 初始延迟（tick）
     * @param period 重复周期（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runTaskTimer(Location location, Runnable task, long delay, long period) {
        ensureInitialized();
        return foliaLib.getScheduler().runAtLocationTimer(location, task, delay, period);
    }

    /**
     * 在实体上运行重复任务
     * @param entity 实体
     * @param task 要执行的任务
     * @param delay 初始延迟（tick）
     * @param period 重复周期（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runTaskTimer(Entity entity, Runnable task, long delay, long period) {
        ensureInitialized();
        return foliaLib.getScheduler().runAtEntityTimer(entity, task, delay, period);
    }

    /**
     * 运行全局重复任务
     * @param task 要执行的任务
     * @param delay 初始延迟（tick）
     * @param period 重复周期（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runGlobalTaskTimer(Runnable task, long delay, long period) {
        ensureInitialized();
        return foliaLib.getScheduler().runTimer(task, delay, period);
    }

    /**
     * 运行异步任务
     * @param task 要执行的任务
     */
    public static void runAsync(Runnable task) {
        ensureInitialized();
        foliaLib.getScheduler().runAsync(wrappedTask -> task.run());
    }

    /**
     * 延迟运行异步任务
     * @param task 要执行的任务
     * @param delay 延迟时间（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runAsyncLater(Runnable task, long delay) {
        ensureInitialized();
        return foliaLib.getScheduler().runLaterAsync(task, delay);
    }

    /**
     * 运行重复异步任务
     * @param task 要执行的任务
     * @param delay 初始延迟（tick）
     * @param period 重复周期（tick）
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runAsyncTimer(Runnable task, long delay, long period) {
        ensureInitialized();
        return foliaLib.getScheduler().runTimerAsync(task, delay, period);
    }

    /**
     * 使用TimeUnit运行重复异步任务
     * @param task 要执行的任务
     * @param delay 初始延迟
     * @param period 重复周期
     * @param timeUnit 时间单位
     * @return WrappedTask 对象，可用于取消任务
     */
    public static WrappedTask runAsyncTimer(Runnable task, long delay, long period, TimeUnit timeUnit) {
        ensureInitialized();
        return foliaLib.getScheduler().runTimerAsync(task, delay, period, timeUnit);
    }

    /**
     * 异步传送实体
     * @param entity 要传送的实体
     * @param location 目标位置
     * @return CompletableFuture<Boolean> 表示传送是否成功
     */
    public static CompletableFuture<Boolean> teleportAsync(Entity entity, Location location) {
        ensureInitialized();
        return foliaLib.getScheduler().teleportAsync(entity, location);
    }

    /**
     * 异步传送实体（带传送原因）
     * @param entity 要传送的实体
     * @param location 目标位置
     * @param cause 传送原因
     * @return CompletableFuture<Boolean> 表示传送是否成功
     */
    public static CompletableFuture<Boolean> teleportAsync(Entity entity, Location location, PlayerTeleportEvent.TeleportCause cause) {
        ensureInitialized();
        return foliaLib.getScheduler().teleportAsync(entity, location, cause);
    }

    /**
     * 取消所有任务（应在插件onDisable时调用）
     */
    public static void cancelAllTasks() {
        ensureInitialized();
        foliaLib.getScheduler().cancelAllTasks();
    }

    /**
     * 取消特定任务
     * @param task 要取消的任务
     */
    public static void cancelTask(WrappedTask task) {
        if (task != null) {
            task.cancel();
        }
    }

    /**
     * 检查任务是否已取消
     * @param task 要检查的任务
     * @return 如果任务已取消返回true
     */
    public static boolean isTaskCancelled(WrappedTask task) {
        return task != null && task.isCancelled();
    }

    /**
     * 获取调度器类型描述
     */
    public static String getSchedulerInfo() {
        ensureInitialized();
        if (foliaLib.isFolia()) {
            return "Folia (Region-based scheduling via FoliaLib)";
        } else if (foliaLib.isPaper()) {
            return "Paper (Traditional scheduling with async teleport support via FoliaLib)";
        } else {
            return "Spigot (Traditional scheduling via FoliaLib)";
        }
    }

    /**
     * 获取FoliaLib实例（供高级用法使用）
     */
    public static FoliaLib getFoliaLib() {
        ensureInitialized();
        return foliaLib;
    }

    private FoliaUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\ItemUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

import java.util.List;

public final class ItemUtils {

    /**
     * 创建带有NBT标记的物品
     */
    public static ItemStack createCustomItem(Material material, String displayName, List<String> lore, String nbtKey, String nbtValue) {
        ItemStack item = new ItemStack(material);
        ItemMeta meta = item.getItemMeta();

        if (meta != null) {
            if (displayName != null) {
                meta.setDisplayName(displayName);
            }
            if (lore != null) {
                meta.setLore(lore);
            }
            if (nbtKey != null && nbtValue != null) {
                NamespacedKey key = new NamespacedKey(Main.getInstance(), nbtKey);
                meta.getPersistentDataContainer().set(key, PersistentDataType.STRING, nbtValue);
            }
            item.setItemMeta(meta);
        }

        return item;
    }

    /**
     * 检查物品是否包含特定的NBT标记
     */
    public static boolean hasCustomNBT(ItemStack item, String nbtKey) {
        if (item == null || item.getItemMeta() == null) {
            return false;
        }

        NamespacedKey key = new NamespacedKey(Main.getInstance(), nbtKey);
        return item.getItemMeta().getPersistentDataContainer().has(key, PersistentDataType.STRING);
    }

    /**
     * 获取物品的NBT值
     */
    public static String getCustomNBTValue(ItemStack item, String nbtKey) {
        if (!hasCustomNBT(item, nbtKey)) {
            return null;
        }

        NamespacedKey key = new NamespacedKey(Main.getInstance(), nbtKey);
        return item.getItemMeta().getPersistentDataContainer().get(key, PersistentDataType.STRING);
    }

    /**
     * 安全地损坏物品耐久度
     */
    public static void damageItem(ItemStack item, int damage) {
        if (item == null || damage <= 0) {
            return;
        }

        try {
            if (item.getType().getMaxDurability() > 0) {
                org.bukkit.inventory.meta.Damageable meta = (org.bukkit.inventory.meta.Damageable) item.getItemMeta();
                if (meta != null) {
                    int currentDamage = meta.getDamage();
                    int newDamage = currentDamage + damage;

                    if (newDamage >= item.getType().getMaxDurability()) {
                        item.setType(Material.AIR);
                    } else {
                        meta.setDamage(newDamage);
                        item.setItemMeta(meta);
                    }
                }
            }
        } catch (Exception e) {
            Main.getInstance().getLogger().warning("Failed to damage item: " + e.getMessage());
        }
    }

    /**
     * 检查物品是否为空气或null
     */
    public static boolean isAirOrNull(ItemStack item) {
        return item == null || item.getType() == Material.AIR || item.getType().isAir();
    }

    /**
     * 克隆物品堆叠，安全处理null情况
     */
    public static ItemStack cloneSafely(ItemStack item) {
        return item != null ? item.clone() : null;
    }

    /**
     * 比较两个物品是否相似（类型和数据相同，忽略数量）
     */
    public static boolean isSimilar(ItemStack item1, ItemStack item2) {
        if (item1 == null || item2 == null) {
            return item1 == item2;
        }
        return item1.isSimilar(item2);
    }

    /**
     * 检查物品是否可以用镐子挖掘
     */
    public static boolean canBreakWithPickaxe(Material material) {
        switch (material) {
            case STONE:
            case COBBLESTONE:
            case MOSSY_COBBLESTONE:
            case STONE_BRICKS:
            case MOSSY_STONE_BRICKS:
            case CRACKED_STONE_BRICKS:
            case CHISELED_STONE_BRICKS:
            case GRANITE:
            case POLISHED_GRANITE:
            case DIORITE:
            case POLISHED_DIORITE:
            case ANDESITE:
            case POLISHED_ANDESITE:
            case DEEPSLATE:
            case COBBLED_DEEPSLATE:
            case POLISHED_DEEPSLATE:
            case DEEPSLATE_BRICKS:
            case CRACKED_DEEPSLATE_BRICKS:
            case DEEPSLATE_TILES:
            case CRACKED_DEEPSLATE_TILES:
            case CHISELED_DEEPSLATE:
            case TUFF:
            case CALCITE:
            case DRIPSTONE_BLOCK:
            case COAL_ORE:
            case DEEPSLATE_COAL_ORE:
            case IRON_ORE:
            case DEEPSLATE_IRON_ORE:
            case GOLD_ORE:
            case DEEPSLATE_GOLD_ORE:
            case DIAMOND_ORE:
            case DEEPSLATE_DIAMOND_ORE:
            case EMERALD_ORE:
            case DEEPSLATE_EMERALD_ORE:
            case LAPIS_ORE:
            case DEEPSLATE_LAPIS_ORE:
            case REDSTONE_ORE:
            case DEEPSLATE_REDSTONE_ORE:
            case COPPER_ORE:
            case DEEPSLATE_COPPER_ORE:
            case NETHER_GOLD_ORE:
            case NETHER_QUARTZ_ORE:
            case SANDSTONE:
            case RED_SANDSTONE:
            case NETHERRACK:
            case BLACKSTONE:
            case BASALT:
            case SMOOTH_BASALT:
            case END_STONE:
            case PURPUR_BLOCK:
            case PURPUR_PILLAR:
                return true;
            default:
                return false;
        }
    }

    private ItemUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\LocationUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.multiblock.base.BlockOffset;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;

/**
 * 位置相关工具类
 */
public final class LocationUtils {

    /**
     * 根据偏移量获取方块
     */
    public static Block getBlockAtOffset(Location center, BlockOffset offset) {
        if (!ValidationUtils.isValidLocation(center) || offset == null) {
            return null;
        }

        return center.clone().add(offset.getX(), offset.getY(), offset.getZ()).getBlock();
    }

    /**
     * 检查两个位置是否在同一个世界
     */
    public static boolean isSameWorld(Location loc1, Location loc2) {
        if (loc1 == null || loc2 == null) {
            return false;
        }

        World world1 = loc1.getWorld();
        World world2 = loc2.getWorld();

        return world1 != null && world2 != null && world1.equals(world2);
    }

    /**
     * 计算两个位置之间的距离
     */
    public static double getDistance(Location loc1, Location loc2) {
        if (!isSameWorld(loc1, loc2)) {
            return Double.MAX_VALUE;
        }

        return loc1.distance(loc2);
    }

    /**
     * 检查位置是否在指定范围内
     */
    public static boolean isWithinRange(Location center, Location target, double range) {
        return getDistance(center, target) <= range;
    }

    /**
     * 获取位置的简短描述
     */
    public static String getLocationString(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return "Invalid Location";
        }

        return String.format("World: %s, X: %.1f, Y: %.1f, Z: %.1f",
                location.getWorld().getName(),
                location.getX(),
                location.getY(),
                location.getZ());
    }

    /**
     * 获取方块坐标的简短描述
     */
    public static String getBlockLocationString(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return "Invalid Location";
        }

        return String.format("World: %s, X: %d, Y: %d, Z: %d",
                location.getWorld().getName(),
                location.getBlockX(),
                location.getBlockY(),
                location.getBlockZ());
    }

    /**
     * 克隆位置（安全处理null）
     */
    public static Location cloneSafely(Location location) {
        return location != null ? location.clone() : null;
    }

    /**
     * 获取位置的中心点（方块中心）
     */
    public static Location getBlockCenter(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return location;
        }

        return new Location(
                location.getWorld(),
                location.getBlockX() + 0.5,
                location.getBlockY() + 0.5,
                location.getBlockZ() + 0.5
        );
    }

    /**
     * 检查位置是否为整数坐标
     */
    public static boolean isBlockLocation(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return false;
        }

        return location.getX() == location.getBlockX() &&
                location.getY() == location.getBlockY() &&
                location.getZ() == location.getBlockZ();
    }

    /**
     * 将位置转换为方块位置
     */
    public static Location toBlockLocation(Location location) {
        if (!ValidationUtils.isValidLocation(location)) {
            return location;
        }

        return new Location(
                location.getWorld(),
                location.getBlockX(),
                location.getBlockY(),
                location.getBlockZ()
        );
    }

    private LocationUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\MaterialRecipeUtils.java
==================================================
package cn.fandmc.flametech.utils;

public class MaterialRecipeUtils {
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\MessageUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;
import cn.fandmc.flametech.gui.buttons.tools.MagnetButton;
import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.util.List;
import java.util.stream.Collectors;

public final class MessageUtils {
    private static final Main plugin = Main.getInstance();
    /**
     * 发送带颜色代码的消息
     */
    public static void sendMessage(CommandSender sender, String message) {
        if (sender != null && message != null) {
            sender.sendMessage(colorize(message));
        }
    }

    /**
     * 发送多行消息
     */
    public static void sendMessages(CommandSender sender, List<String> messages) {
        if (sender != null && messages != null) {
            messages.forEach(message -> sendMessage(sender, message));
        }
    }

    /**
     * 发送国际化消息
     */
    public static void sendLocalizedMessage(CommandSender sender, String key) {
        String message = plugin.getConfigManager().getLang(key);
        sendMessage(sender, message);
    }

    /**
     * 发送带参数替换的国际化消息
     */
    public static void sendLocalizedMessage(CommandSender sender, String key, String... replacements) {
        String message = plugin.getConfigManager().getLang(key);

        // 替换参数 %param1%, %param2% 等
        for (int i = 0; i < replacements.length; i += 2) {
            if (i + 1 < replacements.length) {
                message = message.replace(replacements[i], replacements[i + 1]);
            }
        }

        sendMessage(sender, message);
    }

    /**
     * 转换颜色代码
     */
    public static String colorize(String text) {
        return text != null ? ChatColor.translateAlternateColorCodes('&', text) : "";
    }

    /**
     * 转换颜色代码列表
     */
    public static List<String> colorize(List<String> texts) {
        return texts != null ?
                texts.stream().map(MessageUtils::colorize).collect(Collectors.toList()) :
                List.of();
    }

    /**
     * 向玩家发送动作栏消息
     */
    public static void sendActionBar(Player player, String message) {
        if (player != null && message != null) {
            try {
                player.sendActionBar(colorize(message));
            } catch (Exception e) {
                // 如果动作栏不支持，则发送普通消息
                sendMessage(player, message);
            }
        }
    }

    /**
     * 向玩家发送标题
     */
    public static void sendTitle(Player player, String title, String subtitle, int fadeIn, int stay, int fadeOut) {
        if (player != null) {
            try {
                player.sendTitle(
                        title != null ? colorize(title) : "",
                        subtitle != null ? colorize(subtitle) : "",
                        fadeIn, stay, fadeOut
                );
            } catch (Exception e) {
                plugin.getLogger().warning("Failed to send title to player: " + e.getMessage());
            }
        }
    }

    /**
     * 发送本地化的消息列表
     * @param sender 消息接收者
     * @param key 语言文件中的key
     * @param replacements 替换参数（可选）
     */
    public static void sendLocalizedMessageList(CommandSender sender, String key, String... replacements) {
        try {
            List<String> messages = plugin.getConfigManager().getStringList(key);

            if (messages != null && !messages.isEmpty()) {
                for (String message : messages) {
                    // 应用参数替换
                    String processedMessage = applyReplacements(message, replacements);
                    sendMessage(sender, processedMessage);
                }
            } else {
                // 如果列表为空或不存在，发送错误提示
                sendMessage(sender, "&c未找到帮助信息: " + key);
            }
        } catch (Exception e) {
            logError("Error sending localized message list for key: " + key + " - " + e.getMessage());
            sendMessage(sender, "&c发送消息时发生错误");
        }
    }

    /**
     * 发送本地化的消息列表（带标题）
     * @param sender 消息接收者
     * @param titleKey 标题key
     * @param listKey 列表key
     * @param replacements 替换参数（可选）
     */
    public static void sendLocalizedMessageListWithTitle(CommandSender sender, String titleKey, String listKey, String... replacements) {
        // 先发送标题
        sendLocalizedMessage(sender, titleKey, replacements);
        // 再发送列表
        sendLocalizedMessageList(sender, listKey, replacements);
    }

    /**
     * 应用参数替换的辅助方法
     */
    private static String applyReplacements(String message, String... replacements) {
        if (replacements.length == 0) {
            return message;
        }

        String result = message;
        for (int i = 0; i < replacements.length - 1; i += 2) {
            if (i + 1 < replacements.length) {
                String placeholder = replacements[i];
                String replacement = replacements[i + 1];
                result = result.replace(placeholder, replacement);
            }
        }
        return result;
    }

    /**
     * 记录带颜色的控制台消息
     */
    public static void logInfo(String message) {
        plugin.getLogger().info(stripColors(message));
    }

    /**
     * 记录警告消息
     */
    public static void logWarning(String message) {
        plugin.getLogger().warning(stripColors(message));
    }

    /**
     * 记录错误消息
     */
    public static void logError(String message) {
        plugin.getLogger().severe(stripColors(message));
    }

    /**
     * 记录带颜色的控制台消息
     */
    public static void logDebug(String message) {

        if (plugin.isDebugMode()) {
            plugin.getLogger().info("[Debug]"+stripColors(message));
        }
    }

    /**
     * 移除颜色代码
     */
    public static String stripColors(String text) {
        return text != null ? ChatColor.stripColor(colorize(text)) : "";
    }

    /**
     * 格式化玩家名称
     */
    public static String formatPlayerName(Player player) {
        return player != null ? player.getName() : "Unknown";
    }

    /**
     * 检查字符串是否为空或null
     */
    public static boolean isEmpty(String text) {
        return text == null || text.trim().isEmpty();
    }

    private MessageUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\SkullUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.items.builders.ItemBuilder;
import org.bukkit.Material;
import org.bukkit.OfflinePlayer;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.List;

/**
 * 简化的头颅工具类 - 只为特定材料使用
 */
public final class SkullUtils {

    // 预设玩家名（用于获取头颅）
    private static final String DEFAULT_SKULL_PLAYER = "20018";

    /**
     * 创建玩家头颅
     */
    public static ItemStack createPlayerSkull(String playerName, String displayName, List<String> lore) {
        ItemStack skull = new ItemStack(Material.PLAYER_HEAD);
        SkullMeta meta = (SkullMeta) skull.getItemMeta();

        if (meta != null) {
            // 设置头颅所有者
            try {
                OfflinePlayer player = org.bukkit.Bukkit.getOfflinePlayer(playerName);
                meta.setOwningPlayer(player);
            } catch (Exception e) {
                // 如果设置失败，使用默认玩家
                try {
                    OfflinePlayer defaultPlayer = org.bukkit.Bukkit.getOfflinePlayer(DEFAULT_SKULL_PLAYER);
                    meta.setOwningPlayer(defaultPlayer);
                } catch (Exception fallbackError) {
                    MessageUtils.logWarning("Failed to set skull owner, using default");
                }
            }

            // 设置显示名称
            if (displayName != null) {
                meta.setDisplayName(MessageUtils.colorize(displayName));
            }

            // 设置lore
            if (lore != null) {
                meta.setLore(MessageUtils.colorize(lore));
            }

            skull.setItemMeta(meta);
        }

        return skull;
    }

    /**
     * 创建默认玩家头颅（使用预设玩家）
     */
    public static ItemStack createDefaultSkull(String displayName, List<String> lore) {
        return createPlayerSkull(DEFAULT_SKULL_PLAYER, displayName, lore);
    }

    /**
     * 通过ItemBuilder创建头颅
     */
    public static ItemBuilder createSkullBuilder(String playerName) {
        ItemStack skull = createPlayerSkull(playerName, null, null);
        return new ItemBuilder(skull);
    }

    /**
     * 检查是否为玩家头颅
     */
    public static boolean isPlayerHead(ItemStack item) {
        return item != null && item.getType() == Material.PLAYER_HEAD;
    }

    private SkullUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\java\cn\fandmc\flametech\utils\ValidationUtils.java
==================================================
package cn.fandmc.flametech.utils;

import cn.fandmc.flametech.Main;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

public final class ValidationUtils {

    /**
     * 验证玩家是否有效
     */
    public static boolean isValidPlayer(Player player) {
        return player != null && player.isOnline() && player.isValid();
    }

    /**
     * 验证物品是否有效
     */
    public static boolean isValidItem(ItemStack item) {
        return item != null && !ItemUtils.isAirOrNull(item);
    }

    /**
     * 验证位置是否有效
     */
    public static boolean isValidLocation(Location location) {
        return location != null && location.getWorld() != null;
    }

    /**
     * 验证字符串是否有效（非空且非null）
     */
    public static boolean isValidString(String str) {
        return str != null && !str.trim().isEmpty();
    }

    /**
     * 验证数字是否在指定范围内
     */
    public static boolean isInRange(int value, int min, int max) {
        return value >= min && value <= max;
    }

    /**
     * 验证数字是否在指定范围内
     */
    public static boolean isInRange(double value, double min, double max) {
        return value >= min && value <= max;
    }

    /**
     * 安全获取整数配置值
     */
    public static int getConfigInt(String path, int defaultValue, int min, int max) {
        try {
            int value = Main.getInstance().getConfig().getInt(path, defaultValue);
            return Math.max(min, Math.min(max, value));
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to read config value '" + path + "', using default: " + defaultValue);
            return defaultValue;
        }
    }

    /**
     * 安全获取布尔配置值
     */
    public static boolean getConfigBoolean(String path, boolean defaultValue) {
        try {
            return Main.getInstance().getConfig().getBoolean(path, defaultValue);
        } catch (Exception e) {
            MessageUtils.logWarning("Failed to read config value '" + path + "', using default: " + defaultValue);
            return defaultValue;
        }
    }

    /**
     * 检查玩家是否可以破坏指定距离内的方块
     */
    public static boolean canPlayerBreakAtDistance(Player player, Location blockLocation, double maxDistance) {
        if (!isValidPlayer(player) || !isValidLocation(blockLocation)) {
            return false;
        }

        Location playerLocation = player.getLocation();
        if (!playerLocation.getWorld().equals(blockLocation.getWorld())) {
            return false;
        }

        double distance = playerLocation.distance(blockLocation);
        return distance <= maxDistance;
    }

    private ValidationUtils() {
        throw new UnsupportedOperationException("Utility class");
    }
}


==================================================
路径：.\resources\config.yml
==================================================
language: zh_cn
update-checker:
  enabled: true

# 工具配置
tools:
  explosive_pickaxe:
    enabled: true
    explosion_radius: 2
    max_blocks: 50
    max_durability_damage: 10
    permission_check: true

  smelting_pickaxe:
    enabled: true
    particle_effects: true
    sound_effects: true
    success_rate: 100

# 调试选项
debug:
  enabled: false
  log_tool_usage: false


==================================================
路径：.\resources\plugin.yml
==================================================
name: FlameTech
version: '0.1.2'
main: cn.fandmc.flametech.Main
api-version: '1.21'
authors: [20018]
folia-supported: true
commands:
  flametech:
    description: 主命令
    usage: /flametech <二级命令>
    aliases: [ft]


==================================================
路径：.\resources\lang\zh_cn.yml
==================================================
command:
  help:
    messages:
      - "&e&l----&eFlameTech 帮助&l----"
      - "&2/flametech help &3- &b显示此帮助信息"
      - "&2/flametech guide &3- &b获取指南书"
      - "&2/flametech open &3- &b打开主界面"
      - "&2/flametech reload &3- &b重新加载插件配置"
      - "&2/flametech info &3- &b显示插件信息"
  reload:
    success: "&a配置已成功重载！"
  guide:
    success: "&a已发放 %book%"
    only_player: "&c只能由玩家执行此操作"
  open:
    invalid_gui: "&c无法打开指定的界面: %gui%"
    error: "&c打开界面时发生错误"
  info:
    title: "&e&l=== FlameTech 插件信息 ==="
    version: "&7版本: &e%version%"
    items: "&7已注册物品: &e%count%"
    recipes: "&7已注册配方: &e%count%"
    multiblocks: "&7已注册多方块: &e%count%"
    guis: "&7已注册GUI: &e%count%"
    debug: "&7调试模式: &e%status%"
    player_progress: "&7解锁进度: &e%unlocked%/%total%"
  error:
    generic: "&c执行命令时发生错误"
    no_permission: "&c你没有权限执行此命令"

# 通用消息
common:
  error:
    generic: "&c发生了未知错误"
    invalid_player: "&c玩家不存在或已离线"
    invalid_item: "&c无效的物品"
    invalid_location: "&c无效的位置"
    permission_denied: "&c权限不足"
    config_error: "&c配置文件错误"
    data_save_failed: "&c数据保存失败"
    reload_failed: "&c重载失败"
    operation_failed: "&c操作失败，请稍后重试"
  success:
    operation_completed: "&a操作成功完成"
    data_saved: "&a数据已保存"
    reload_completed: "&a重载完成"
  status:
    enabled: "启用"
    disabled: "禁用"
    loading: "&e加载中..."
    processing: "&e处理中..."
  navigation:
    back: "&a← 返回"
    next_page: "&a下一页 →"
    previous_page: "&a← 上一页"
    close: "&c关闭"
    confirm: "&a确认"
    cancel: "&c取消"
  placeholders:
    no_next_page: "&7没有下一页"
    no_previous_page: "&7没有上一页"
    empty_slot: "&7空槽位"
    loading: "&e加载中..."

# 指南书
guide_book:
  display_name: "&6&l热力科技指南"
  lore:
    - "&7你的科技之旅从这里开始"
    - "&7右键点击打开主界面"
  actions:
    open_main: "&e点击打开主界面"

# 多方块结构
multiblock:
  not_unlocked: "&c你还未解锁 %machine%！"
  debug:
    space_before: "&7合成前：空槽 %empty%，部分满 %partial%，已满 %full%"
    space_after: "&7合成后：空槽 %empty%，部分满 %partial%，已满 %full%"
    simulation_success: "&a模拟合成成功，实际执行中..."
    simulation_failed: "&c模拟合成失败：%reason%"
  enhanced_crafting_table:
    name: "&6增强型工作台"
    description: "&7一个增强版的工作台，可以合成特殊物品"
    created: "&a✔ 成功创建了增强型工作台！"
    hint: "&7将物品放入下方的发射器中，再次右键工作台即可自动合成"
    no_recipe: "&c发射器中的物品无法匹配任何配方！"
    inventory_full: "&c发射器已满！无法放入合成结果"
    craft_success: "&a✔ 成功合成了 %item%！"
    craft_partial: "&e合成完成，但部分物品掉落在地上"
    structure_info:
      - "&7结构要求："
      - "&7上层：工作台（主方块）"
      - "&7下层：发射器"
      - ""
      - "&e右键工作台激活结构"
    activation_failed: "&c激活多方块结构失败"
    structure_mismatch: "&c结构不匹配，请检查搭建"
    inventory_analysis: "&7发射器状态：空槽 %empty%，部分满 %partial%，已满 %full%"
    craft_failed: "&c合成失败，请检查材料和空间"
    insufficient_materials: "&c材料不足！请检查配方要求"
    materials_consumed: "&7已消耗 %count% 种材料"
  # 治炼炉
  smelting_furnace:
    name: "&c&l治炼炉"
    description: "&7高温熔炼设备，可以熔炼各种金属"
    created: "&a✔ 成功创建了治炼炉！"
    hint: "&7将材料放入发射器中，右键下界砖栅栏开始熔炼"
    fire_out: "&c火焰已熄灭！无法进行熔炼"
    final_use_warning: "&c⚠ 注意：这是最后一次使用，火焰即将熄灭！"
    relight_hint: "&7使用打火石重新点燃底部的火焰"
    relight_required: "&7请重新点火后继续使用"
    relight_success: "&a✔ 火焰重新点燃成功！"
    smelting_complete: "&a熔炼完成！"
    remaining_uses: "&7火焰还可使用 &e%count% &7次"
    structure_info:
      - "&7结构要求："
      - "&7上层(Y+1)：下界砖栅栏（主方块）"
      - "&7中层(Y+0)：发射器"
      - "&7下层(Y-1)：火焰"
      - ""
      - "&c搭建提示："
      - "&e• 先搭建发射器和下界砖栅栏"
      - "&e• 用打火石在最下层点火"
      - "&e• 确保火焰持续燃烧"
      - ""
      - "&c注意：每5次使用火焰会熄灭一次"
      - "&7火焰熄灭后用打火石重新点燃"
      - "&e右键下界砖栅栏激活结构"

  # 洗矿机
  ore_washer:
    name: "&b&l洗矿机"
    description: "&7清洗矿物杂质的设备"
    created: "&a✔ 成功创建了洗矿机！"
    hint: "&7手持沙砾右键活版门开始洗矿"
    need_gravel: "&c请手持沙砾来进行洗矿！"
    need_water: "&c炼药锅中需要有水才能洗矿！"
    structure_info:
      - "&7结构要求："
      - "&7上层(Y+0)：活版门（主方块）"
      - "&7下层(Y-1)：炼药锅（需要有水）"
      - ""
      - "&7使用方法："
      - "&e• 手持沙砾右键活版门"
      - "&e• 消耗1个沙砾开始洗矿"

  # 筛矿机
  ore_sifter:
    name: "&e&l筛矿机"
    description: "&7筛选矿物的精密设备"
    created: "&a✔ 成功创建了筛矿机！"
    hint: "&7将材料放入上方发射器中，右键木栅栏开始筛选"
    no_recipe: "&c发射器中的物品无法匹配任何筛选配方！"
    inventory_full: "&c发射器已满！无法放入筛选结果"
    sifting_success: "&a✔ 成功筛选了 %item%！"
    structure_info:
      - "&7结构要求："
      - "&7上层(Y+1)：发射器"
      - "&7中层(Y+0)：木栅栏（主方块）"
      - "&7下层(Y-1)：炼药锅（收集筛选物）"
      - ""
      - "&e右键木栅栏激活结构"

  # 压力机
  pressure_machine:
    name: "&d&l压力机"
    description: "&7高压压制设备，制造压缩物品"
    created: "&a✔ 成功创建了压力机！"
    hint: "&7将材料放入发射器中，右键玻璃开始压制"
    no_recipe: "&c发射器中的物品无法匹配任何压制配方！"
    inventory_full: "&c发射器已满！无法放入压制结果"
    pressing_success: "&a✔ 成功压制了 %item%！"
    pressing_partial: "&e压制完成，但部分物品掉落在地上"
    structure_info:
      - "&7结构要求（3x3布局）："
      - "&7平滑石头 活塞 平滑石头"
      - "&7活塞 玻璃(主方块) 活塞"
      - "&7平滑石头 发射器 平滑石头"
      - ""
      - "&e右键中心玻璃激活结构"
# GUI界面
gui:
  main:
    title: "&6&l热力科技主界面"
    welcome: "&e欢迎使用热力科技！"

  basic_machines:
    title: "&6基础机器"
    description: "&7查看所有基础机器的信息和配方"
    enhanced_crafting:
      name: "&6增强型工作台"
      lore:
        - "&7一个增强版的工作台"
        - "&7可以合成特殊物品和工具"
        - ""
        - "&e多方块结构："
        - "&7上层：工作台（主方块）"
        - "&7下层：发射器（存放材料）"
        - ""
        - "&a点击查看配方和结构"
        - ""
        - "&c[基础机器]"
        # 治炼炉GUI
    smelting_furnace:
      name: "&c&l治炼炉"
      lore:
        - "&7高温熔炼设备"
        - "&7可以熔炼各种金属和矿物"
        - "&c使用5次后火焰会熄灭"
        - ""
        - "&e多方块结构："
        - "&7上层：下界砖栅栏（主方块）"
        - "&7中层：发射器（存放材料）"
        - "&7下层：火焰（用打火石点燃）"
        - ""
        - "&c搭建注意事项："
        - "&e• 先搭建发射器和栅栏"
        - "&e• 用打火石在下层点火"
        - "&e• 火焰熄灭后需重新点燃"
        - ""
        - "&a点击查看配方和结构"
        - ""
        - "&c[基础机器]"

    # 洗矿机GUI
    ore_washer:
      name: "&b&l洗矿机"
      lore:
        - "&7清洗矿物杂质的设备"
        - "&7手持沙砾右键使用"
        - "&b洗矿时间：3-5秒"
        - ""
        - "&e多方块结构："
        - "&7上层：活版门（主方块）"
        - "&7下层：炼药锅（需要有水）"
        - ""
        - "&7使用方法："
        - "&e• 手持沙砾右键活版门"
        - "&e• 消耗1个沙砾进行洗矿"
        - ""
        - "&a点击查看详细信息"
        - ""
        - "&b[基础机器]"

    # 筛矿机GUI
    ore_sifter:
      name: "&e&l筛矿机"
      lore:
        - "&7筛选矿物的精密设备"
        - "&7通过配方系统筛选材料"
        - "&e需要特定的筛选配方"
        - ""
        - "&e多方块结构："
        - "&7上层：发射器"
        - "&7中层：木栅栏（主方块）"
        - "&7下层：炼药锅（收集物）"
        - ""
        - "&a点击查看配方和结构"
        - ""
        - "&e[基础机器]"

    # 压力机GUI
    pressure_machine:
      name: "&d&l压力机"
      lore:
        - "&7高压压制设备"
        - "&7制造各种压缩物品"
        - "&d复杂的3x3多方块结构"
        - ""
        - "&e多方块结构："
        - "&7四角：平滑石头"
        - "&7四边：活塞 + 发射器"
        - "&7中心：玻璃（主方块）"
        - ""
        - "&7布局：p-h-p / h-g-h / p-t-p"
        - "&8(p=平滑石头, h=活塞, g=玻璃, t=发射器)"
        - ""
        - "&a点击查看配方和结构"
        - ""
        - "&d[基础机器]"
  materials:
    title: "&6&l矿物材料"
    category_selection: "&e选择材料类别"
    search_placeholder: "&7搜索材料..."
    no_materials: "&c该类别暂无材料"
    no_materials_desc: "&7该类别还没有注册任何材料，敬请期待！"

    categories:
      raw_materials:
        name: "&8&l原材料"
        description: "&7未经加工的原始材料"
      dusts:
        name: "&7&l金属粉末"
        description: "&7各种金属的粉末形态"
      ingots:
        name: "&f&l金属锭"
        description: "&7不同纯度的金属锭"
      alloys:
        name: "&6&l合金"
        description: "&7多种金属混合制成的合金"
      gems:
        name: "&b&l宝石"
        description: "&7人造宝石和稀有矿物"
      processed:
        name: "&e&l加工品"
        description: "&7经过特殊处理的材料"
  material_viewer:
    title: "&6材料查看器: %material%"

    # 材料信息面板
    info:
      title: "&e&l材料信息"
      category: "&7类别: &e"
      id: "&7ID: &e"
      created_by: "&7制作方式:"
      no_source_recipes: "&7• §c暂无制作配方"
      used_in_count: "&7用于制作: &e%count% &7种配方"
      view_recipes_hint: "&e右侧可查看所有相关配方"

    # 材料展示
    display:
      material_info: "&7这是一个工业材料"
      category: "&7类别: %category%"

    # 相关配方按钮
    related_recipes:
      title: "&6&l相关配方"
      description: "&7查看使用此材料的所有配方"
      count: "&7找到 &e%count% &7个相关配方:"
      no_recipes: "&c暂无相关配方"
      no_recipes_message: "&c该材料暂未用于任何配方中"
      click_to_view: "&a点击查看所有相关配方"
      open_error: "&c打开相关配方时发生错误"

  # 材料相关配方列表
  material_related_recipes:
    title: "&6%material% 的相关配方 &7(%count%个)"

    # 配方项
    recipe_type: "&7配方类型: &e%type%"
    material_usage: "&7使用 &e%material% &7x%amount%"
    click_view_recipe: "&a点击查看配方详情"

    # 未解锁配方
    recipe_locked_name: "&c%recipe% &7(未解锁)"
    recipe_locked_lore_exp: "&7需要经验等级: &e%required%"
    recipe_locked_lore_click: "&e点击解锁配方"

    # 错误消息
    unlock_failed_default: "&c解锁失败: %message%"
    error_open_recipe: "&c打开配方详情时发生错误"
    error_click_event: "&c处理点击事件时发生错误"

    # 材料信息组件
    material_info:
      title: "&e当前查看的材料"
      id: "&7材料ID: &e%id%"
      usage_count: "&7相关配方数: &e%count%"

  buttons:
    tools:
      name: "&b工具"
      lore:
        - "&7查看所有特殊工具的配方"
        - "&7包含：爆炸镐、熔炼镐等"
        - ""
        - "&e点击查看工具列表"
    basic_machines:
      name: "&6基础机器"
      lore:
        - "&7查看所有基础机器的配方和信息"
        - "&7包含：熔炉、压缩机、粉碎机等"
        - ""
        - "&e点击查看基础机器列表"
    materials:
      name: "&6&l矿物材料"
      lore:
        - "&7查看和获取各种工业材料"
        - "&7包含：粉末、锭、合金、宝石等"
        - ""
        - "&e点击进入材料大全"
  tools:
    title: "&b工具配方"
    description: "&7查看所有特殊工具的配方和功能"
    explosive_pickaxe:
      name: "&c&l爆炸镐"
      lore:
        - "&7一把充满破坏力的镐子"
        - "&7能够炸毁大片区域的方块"
        - "&c小心使用！威力巨大"
        - ""
        - "&e功能特性："
        - "&7• 破坏 %radius% 格半径内的方块"
        - "&7• 产生爆炸效果和音效"
        - "&7• 最多破坏 %max_blocks% 个方块"
        - "&7• 消耗额外耐久度"
        - ""
        - "&a点击查看详细配方"
    smelting_pickaxe:
      name: "&6&l熔炼镐"
      lore:
        - "&7一把能够自动熔炼的神奇镐子"
        - "&7挖掘矿物时自动熔炼成锭"
        - "&6节省燃料，提高效率！"
        - ""
        - "&e功能特性："
        - "&7• 矿石直接掉落对应的锭"
        - "&7• 支持铁、金、铜等矿石"
        - "&7• 播放熔炼音效和粒子特效"
        - "&7• 100% 成功率"
        - ""
        - "&a点击查看详细配方"

    magnet:
      name: "&b&l吸铁石"
      lore:
        - "&7一个神奇的磁力装置"
        - "&7可以吸引附近的掉落物品"
        - "&b挖矿刷怪的好帮手！"
        - ""
        - "&e功能特性："
        - "&7• 8格范围物品吸引"
        - "&7• 自动吸引经验球"
        - "&7• 3秒冷却时间"
        - "&7• 最多30个物品/次"
        - ""
        - "&a点击查看详细配方"

  recipe_viewer:
    title: "&6%machine% - 结构展示"
    language_key_not_found: "未找到语言键"
    structure_not_found: "&c无法找到结构定义"
    structure_layout_error: "&c打开结构布局时发生错误"
    operation_failed: "&c操作失败，请稍后重试"
    recipes_list_error: "&c打开配方列表时发生错误"
    structure_load_failed: "&c结构加载失败"
    structure_load_failed.lore:
      - "&7无法找到结构定义"
      - "&7结构ID: &e%id%"
      - ""
      - "&c请联系管理员检查插件配置"
    view_recipes:
      name: "&a查看配方"
      lore:
        - "&7查看此结构的所有配方"
        - "&7包含合成材料和产出物"
        - ""
        - "&e点击打开配方列表"
    structure_info:
      name: "&6&l结构布局图"
      lore:
        - "&7结构名称: &e%name%"
        - "&7方块数量: &e%blocks%"
        - "&7结构尺寸: &e%dimensions%"
        - ""
        - "&7搭建说明:"
        - "&7• 按照指定布局搭建"
        - "&7• 搭建完成后右键主方块"
        - "&7• 严格按照层级和位置摆放"
        - ""
        - "&a&l▶ 点击查看详细搭建图"
        - "&7查看每一层的具体摆放方式"
        - ""
        - "&e[结构布局]"

  structure_layout:
    title: "&6结构布局: %name%"
    empty_layer:
      name: "&7空层级"
      lore:
        - "&7此层级没有方块"
        - "&7Y = %layer%"
        - ""
        - "&7使用上下按钮切换到有方块的层级"
    oversized:
      name: "&e结构过大"
      lore:
        - "&7此层级的结构超过了显示范围"
        - "&7尺寸: %size%"
        - "&7显示限制: 7x3"
        - ""
        - "&7请参考坐标信息进行搭建"
    block:
      crafting_table_name: "&6工作台 &7(主方块)"
      dispenser_name: "&e发射器"
      generic_name: "&f%material%"
      coordinates: "&7坐标: &e(%x%, %y%, %z%)"
      main_marker: "&6⭐ 主方块位置"
      crafting_table_lore:
        - "&7这是结构的主方块"
        - "&7右键点击此方块来激活结构"
      dispenser_lore:
        - "&7用于存放合成材料"
        - "&7将物品放入其中进行合成"
      generic_lore:
        - "&7结构组成方块"
      fire_name: "&c火焰 &7(用打火石点燃)"
      fire_lore:
        - "&c需要保持燃烧状态"
        - "&7使用打火石在此位置点火"
        - "&7火焰会在使用5次后熄灭"
        - "&c重要：必须有火焰才能工作"

      # 下界砖栅栏 (治炼炉)
      nether_brick_fence_name: "&c下界砖栅栏 &7(主方块)"
      nether_brick_fence_lore:
        - "&7治炼炉的主控制方块"
        - "&7右键点击激活治炼炉"
        - "&c确保下方有火焰在燃烧"

      # 活版门 (洗矿机)
      oak_trapdoor_name: "&6活版门 &7(主方块)"
      oak_trapdoor_lore:
        - "&7洗矿机的操作界面"
        - "&7手持沙砾右键使用"
        - "&b需要下方炼药锅有水"

      # 炼药锅
      cauldron_name: "&9炼药锅"
      cauldron_lore:
        - "&7用于收集和储存"
        - "&7洗矿机：需要装水"
        - "&7筛矿机：收集筛选物"

      # 木栅栏 (筛矿机)
      oak_fence_name: "&6木栅栏 &7(主方块)"
      oak_fence_lore:
        - "&7筛矿机的控制中心"
        - "&7右键点击开始筛选"
        - "&e需要上方发射器有材料"

      # 活塞 (压力机)
      piston_name: "&7活塞"
      piston_lore:
        - "&7提供压制力量"
        - "&7压力机的关键组件"
        - "&d必须按正确位置摆放"

      # 平滑石头 (压力机)
      smooth_stone_name: "&f平滑石头"
      smooth_stone_lore:
        - "&7压力机的支撑结构"
        - "&7提供稳定的基础"
        - "&7摆放在四个角落"

      # 玻璃 (压力机)
      glass_name: "&b玻璃 &7(主方块)"
      glass_lore:
        - "&7压力机的控制中心"
        - "&7右键点击开始压制"
        - "&d复杂的3x3结构中心"
    layer_up:
      enabled: "&a▲ 上一层"
      disabled: "&7▲ 已是最高层"
      enabled_lore:
        - "&7点击查看上一层"
        - "&7当前: Y=%current%"
        - "&7上层: Y=%next%"
      disabled_lore:
        - "&7已经是最高层了"
    layer_down:
      enabled: "&c▼ 下一层"
      disabled: "&7▼ 已是最底层"
      enabled_lore:
        - "&7点击查看下一层"
        - "&7当前: Y=%current%"
        - "&7下层: Y=%next%"
      disabled_lore:
        - "&7已经是最底层了"
    layer_info:
      name: "&e当前层级信息"
      lore:
        - "&7当前层级: &eY = %current%"
        - "&7结构范围: &eY %min% ~ %max%"
        - "&7总层数: &e%total%"
        - ""
        - "&7使用上下按钮切换层级"
    structure_info:
      name: "&6结构信息"
      lore:
        - "&7结构名称: &e%name%"
        - "&7总方块数: &e%blocks%"
        - "&7结构尺寸: &e%dimensions%"
        - ""
        - "&7搭建提示:"
        - "&e• 严格按照层级从下往上搭建"
        - "&e• 确保每个方块位置正确"
        - "&e• 主方块(0,0,0)为激活点"

  structure_recipes:
    title: "&6%machine% - 配方列表"
    no_recipes: "&c该结构暂无配方"
    no_recipes_lore:
      - "&7该结构尚未配置任何配方"
      - "&7请联系管理员添加配方"
    click_view_recipe: "&a点击查看配方详情"
    recipe_locked_name: "&c%recipe% &7(未解锁)"
    recipe_locked_lore_exp: "&7需要经验等级: &e%required%"
    recipe_locked_lore_click: "&e点击解锁配方"
    unlock_failed_default: "&c解锁失败: %message%"
    error_open_recipe: "&c打开配方详情时发生错误"
    error_click_event: "&c处理点击事件时发生错误"

  item_recipe:
    title: "&6配方详情: %item%"
    ingredient_amount: "&7需要数量: x%amount%"
    unknown_structure: "未知结构"
    enhanced_crafting_table: "增强工作台"
    type_indicator:
      name: "&e配方信息"
      type: "&7配方类型: &e%type%"
      source: "&7合成来源: &e%source%"
      usage_line1: "&7在指定结构中使用此配方"
      usage_line2: "&7来合成所需物品"
    result:
      title: "&e&l合成结果"
      amount: "&7数量: &ax%amount%"
      instruction_line1: "&7将上方材料按图案摆放"
      instruction_line2: "&7在 &e%machine% &7中合成"

# 物品和工具
items:
  explosive_pickaxe:
    name: "&c&l爆炸镐"
    lore:
      - "&7一把充满破坏力的镐子"
      - "&7能够炸毁大片区域的方块"
      - "&c小心使用！"
      - ""
      - "&e功能:"
      - "&7• 破坏%radius%格半径内的方块"
      - "&7• 可以破坏任何可破坏的方块"
      - "&7• 产生爆炸效果和音效"
      - "&7• 消耗额外耐久度"

  smelting_pickaxe:
    name: "&6&l熔炼镐"
    lore:
      - "&7一把能够自动熔炼的镐子"
      - "&7挖掘矿物时自动熔炼成锭"
      - "&6节省熔炉燃料！"
      - ""
      - "&e功能:"
      - "&7• 矿石直接掉落锭"

  border_item:
    name: " "

  buttons:
    back:
      name: "&a← 返回"
    next_page:
      name: "&a下一页 →"
    previous_page:
      name: "&a← 上一页"
    close:
      name: "&c关闭"
    page_info:
      name: "&e页面信息"
      current_page: "&7当前页: &e%current%&7/&e%total%"
      total_items: "&7物品总数: &e%items%"
      lore:
        - "&7当前页: &e%current%&7/&e%total%"
        - "&7物品总数: &e%items%"
    basic_machines:
      name: "&6基础机器"
      lore:
        - "&7查看所有基础机器的配方和信息"
        - "&7包含：熔炉、压缩机、粉碎机等"
        - ""
        - "&e点击查看基础机器列表"
    tools:
      name: "&b工具"
      lore:
        - "&7查看所有特殊工具的配方"
        - "&7包含：爆炸镐、熔炼镐等"
        - ""
        - "&e点击查看工具列表"
  magnet:
    name: "&b&l吸铁石"
    lore:
      - "&7一个神奇的磁力装置"
      - "&7可以吸引附近的掉落物品"
      - "&b省时省力的好帮手！"
      - ""
      - "&e功能:"
      - "&7• 吸引 8 格范围内的物品"
      - "&7• 同时吸引经验球"
      - "&7• 最多吸引 30 个物品"
      - "&7• 3秒冷却时间"
      - ""
      - "&a右键点击使用"

# 解锁系统
unlock:
  success: "&a✔ 成功解锁: &e%item%"
  insufficient_exp: "&c经验不足！需要 &e%required% &c级经验才能解锁"
  already_unlocked: "&e该项目已经解锁了"
  item_not_found: "&c未找到指定的解锁项目"
  player_not_found: "&c玩家不存在"
  error: "&c解锁时发生错误: %message%"

# 配方系统
recipe:
  not_unlocked: "&c你还未解锁配方: %recipe%！"
  types:
    shaped: "有序合成"
    shapeless: "无序合成"
    smelting: "熔炼"
    crushing: "粉碎"
    compressing: "压缩"
    custom: "自定义"
  categories:
    basic: "基础配方"
    advanced: "高级配方"
    machines: "机器配方"
    tools: "工具配方"
    materials: "材料配方"
  errors:
    not_found: "&c配方不存在"
    invalid: "&c无效的配方"
    registration_failed: "&c配方注册失败"

# 工具相关消息
tools:
  special_tool:
    display_name_format: "&6&l%name%"
    default_lore:
      - "&7特殊工具"
      - "&7具有独特的功能"
  explosive_pickaxe:
    cooldown_message: "&c工具冷却中，请稍后再试！"
    no_permission: "&c你没有使用爆炸镐的权限"
    error: "&c使用爆炸镐时发生错误"

  smelting_pickaxe:
    smelting_message: "&6✨ 自动熔炼: %material%"
    no_permission: "&c你没有使用熔炼镐的权限"
    error: "&c使用熔炼镐时发生错误"

  magnet:
    cooldown_message: "&c吸铁石冷却中，还需 %time% 秒"
    no_items_found: "&7附近没有可吸引的物品"
    success_message: "&a✨ 成功吸引了 &e%count% &a个物品！"
    no_permission: "&c你没有使用吸铁石的权限"

  general:
    permission_denied: "&c你没有使用此工具的权限"
    tool_broken: "&c工具已损坏"
    invalid_tool: "&c无效的工具"
# 错误和调试信息
debug:
  config_loaded: "配置文件已加载"
  item_registered: "物品已注册: %item%"
  recipe_registered: "配方已注册: %recipe%"
  multiblock_registered: "多方块已注册: %multiblock%"
  gui_registered: "GUI已注册: %gui%"
  player_unlock: "玩家 %player% 解锁了 %item%"
  language_file_loaded: "&7语言文件已加载: &e%language%"
  config_reload_completed: "&a配置重载完成"

errors:
  config:
    language_not_found: "&c未找到语言配置文件"
    language_key_not_found: "&c未找到语言键: &e%key%"
    language_list_not_found: "&c未找到语言列表: &e%path%"
    load_failed: "&c配置文件加载失败: &e%error%"
    save_failed: "&c配置文件保存失败: &e%error%"
    reload_failed: "&c配置重载失败: &e%error%"
    invalid_value: "配置项 %key% 的值无效"
    missing_key: "缺少配置项: %key%"

  item:
    creation_failed: "物品创建失败: %item%"
    invalid_nbt: "无效的NBT数据"
    damage_failed: "物品损坏失败"

  gui:
    open_failed: "GUI打开失败: %gui%"
    component_error: "GUI组件错误: %error%"
    invalid_slot: "无效的槽位: %slot%"

  multiblock:
    structure_invalid: "多方块结构无效"
    activation_failed: "多方块激活失败"
    not_found: "未找到多方块结构: %id%"

  recipe:
    match_failed: "配方匹配失败"
    ingredient_missing: "缺少配方材料"
    result_invalid: "配方结果无效"

  data:
    save_failed: "数据保存失败"
    load_failed: "数据加载失败"
    corruption: "数据文件损坏"

# 帮助和提示
help:
  getting_started:
    title: "&e新手指南"
    steps:
      - "&71. 获取指南书: &e/flametech guide"
      - "&72. 打开主界面: &e/flametech open"
      - "&73. 查看基础机器和工具配方"
      - "&74. 收集材料并搭建结构"
      - "&75. 开始你的科技之旅！"

  tips:
    - "&e💡 提示: 使用指南书可以快速访问主界面"
    - "&e💡 提示: 搭建多方块结构时要确保位置准确"
    - "&e💡 提示: 某些配方需要解锁后才能使用"
    - "&e💡 提示: 特殊工具有独特的功能和效果"

# 成就和统计
stats:
  unlocked_items: "已解锁物品"
  total_items: "总物品数"
  crafted_items: "已合成物品"
  structures_built: "已建造结构"

# 管理员相关
admin:
  reload_success: "&a插件重载成功"
  reload_failed: "&c插件重载失败: %error%"
  debug_enabled: "&a调试模式已启用"
  debug_disabled: "&c调试模式已禁用"
  player_reset: "&a已重置玩家 %player% 的数据"

# 时间和数值格式
format:
  time:
    seconds: "%time% 秒"
    minutes: "%time% 分钟"
    hours: "%time% 小时"

  numbers:
    thousands: "%number%K"
    millions: "%number%M"

materials:
  interaction:
    left_click: "&7左键：查看详细信息"
    shift_left: "&7Shift+左键：查看相关配方"

  actions:
    opening_viewer: "&a正在打开材料查看器..."
    found_recipes: "&a找到 %count% 个相关配方"
    no_related_recipes: "&e该材料暂无相关配方"
    obtained_material: "&a获得了 %amount% 个 %material%"
    obtained_partial: "&e获得了 %received% 个 %material%，剩余掉落在地上"
    creation_failed: "&c无法创建材料物品"
    give_error: "&c给予材料时发生错误"
  category:
    raw_materials: "原材料"
    dusts: "粉末"
    ingots: "锭"
    alloys: "合金"
    gems: "宝石"
    processed: "加工品"

  common:
    purity: "纯度"
    rarity: "稀有度"
    description: "描述"
    get_one: "左键获取 1 个"
    get_stack: "右键获取 64 个"
    get_half_stack: "Shift+左键获取 16 个"
    inventory_full: "背包已满，部分物品掉落在地上"
    obtained: "获得了材料"

  names:
    # 粉末类
    iron_dust: "铁粉"
    copper_dust: "铜粉"
    zinc_dust: "锌粉"
    aluminum_dust: "铝粉"
    chrome_dust: "铬粉"
    silver_dust: "银粉"
    tin_dust: "锡粉"

    # 合金
    bronze_ingot: "青铜锭"

    # 加工品
    ore_dust: "矿粉"
    silicon: "硅"
    raw_silicon: "原硅"

    # 人造宝石
    artificial_diamond: "人造钻石"
    artificial_emerald: "人造绿宝石"
    artificial_sapphire: "人造蓝宝石"
recipes:
  explosive_pickaxe:
    name: "爆炸镐"
  smelting_pickaxe:
    name: "熔炼镐"
  register:
    all_success: "成功注册所有工具配方"
    all_failed: "注册工具配方失败: %error%"
    explosive_pickaxe_failed: "注册爆炸镐配方失败"
    smelting_pickaxe_failed: "注册熔炼镐配方失败"
  magnet:
    name: "吸铁石"


